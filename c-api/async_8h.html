<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wasmtime: async.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Wasmtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('async_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">async.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Wasmtime async functionality.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="wasm_8h_source.html">wasm.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="config_8h_source.html">wasmtime/config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="error_8h_source.html">wasmtime/error.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="func_8h_source.html">wasmtime/func.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="linker_8h_source.html">wasmtime/linker.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="store_8h_source.html">wasmtime/store.h</a>&gt;</code><br />
</div>
<p><a href="async_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwasmtime__async__continuation__t.html">wasmtime_async_continuation_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwasmtime__stack__memory__t.html">wasmtime_stack_memory_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwasmtime__stack__creator__t.html">wasmtime_stack_creator_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acccdba20eece02d81457c00f8f7ca6de"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#acccdba20eece02d81457c00f8f7ca6de">wasmtime_func_async_continuation_callback_t</a>) (void *env)</td></tr>
<tr class="separator:acccdba20eece02d81457c00f8f7ca6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fead8db7d36c554e84374caa6e7fef"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structwasmtime__async__continuation__t.html">wasmtime_async_continuation_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#a42fead8db7d36c554e84374caa6e7fef">wasmtime_async_continuation_t</a></td></tr>
<tr class="separator:a42fead8db7d36c554e84374caa6e7fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a33b6560ced2f920f72d12759467b0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#a45a33b6560ced2f920f72d12759467b0">wasmtime_func_async_callback_t</a>) (void *env, <a class="el" href="func_8h.html#abad1840db69084f226feec107cc23d5e">wasmtime_caller_t</a> *caller, const <a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353">wasmtime_val_t</a> *args, size_t nargs, <a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353">wasmtime_val_t</a> *results, size_t nresults, <a class="el" href="structwasm__trap__t.html">wasm_trap_t</a> **trap_ret, <a class="el" href="structwasmtime__async__continuation__t.html">wasmtime_async_continuation_t</a> *continuation_ret)</td></tr>
<tr class="memdesc:a45a33b6560ced2f920f72d12759467b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback signature for <a class="el" href="async_8h.html#a9d432ffbf227a581e93388d4142c4d98" title="Defines a new async function in this linker.">wasmtime_linker_define_async_func</a>.  <a href="async_8h.html#a45a33b6560ced2f920f72d12759467b0">More...</a><br /></td></tr>
<tr class="separator:a45a33b6560ced2f920f72d12759467b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b55a7a8c4c5ac50ad0cbd56f82a77b"><td class="memItemLeft" align="right" valign="top">typedef struct wasmtime_call_future&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a></td></tr>
<tr class="memdesc:a54b55a7a8c4c5ac50ad0cbd56f82a77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure representing a asynchronously running function.  <a href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">More...</a><br /></td></tr>
<tr class="separator:a54b55a7a8c4c5ac50ad0cbd56f82a77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff8e4199dfe7eacb712398783a37fea"><td class="memItemLeft" align="right" valign="top">typedef uint8_t *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#adff8e4199dfe7eacb712398783a37fea">wasmtime_stack_memory_get_callback_t</a>) (void *env, size_t *out_len)</td></tr>
<tr class="separator:adff8e4199dfe7eacb712398783a37fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043f38e279d4ab660a1f0e0d6b19dfed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#a043f38e279d4ab660a1f0e0d6b19dfed">wasmtime_new_stack_memory_callback_t</a>) (void *env, size_t size, <a class="el" href="structwasmtime__stack__memory__t.html">wasmtime_stack_memory_t</a> *stack_ret)</td></tr>
<tr class="separator:a043f38e279d4ab660a1f0e0d6b19dfed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2bb7f188ac93c9734c916f80929ee28d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#a2bb7f188ac93c9734c916f80929ee28d">wasmtime_config_async_support_set</a> (<a class="el" href="structwasm__config__t.html">wasm_config_t</a> *, bool)</td></tr>
<tr class="memdesc:a2bb7f188ac93c9734c916f80929ee28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not to enable support for asynchronous functions in Wasmtime.  <a href="async_8h.html#a2bb7f188ac93c9734c916f80929ee28d">More...</a><br /></td></tr>
<tr class="separator:a2bb7f188ac93c9734c916f80929ee28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0912c2ed7f057aab0cebf29481311af9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#a0912c2ed7f057aab0cebf29481311af9">wasmtime_config_async_stack_size_set</a> (<a class="el" href="structwasm__config__t.html">wasm_config_t</a> *, uint64_t)</td></tr>
<tr class="memdesc:a0912c2ed7f057aab0cebf29481311af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the size of the stacks used for asynchronous execution.  <a href="async_8h.html#a0912c2ed7f057aab0cebf29481311af9">More...</a><br /></td></tr>
<tr class="separator:a0912c2ed7f057aab0cebf29481311af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1161879d69bfaf8ab47637f92111874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#af1161879d69bfaf8ab47637f92111874">wasmtime_context_fuel_async_yield_interval</a> (<a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *context, uint64_t interval)</td></tr>
<tr class="memdesc:af1161879d69bfaf8ab47637f92111874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures a Store to yield execution of async WebAssembly code periodically.  <a href="async_8h.html#af1161879d69bfaf8ab47637f92111874">More...</a><br /></td></tr>
<tr class="separator:af1161879d69bfaf8ab47637f92111874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c9cb4468d68a4cc4193a5e252645c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#ab9c9cb4468d68a4cc4193a5e252645c7">wasmtime_context_epoch_deadline_async_yield_and_update</a> (<a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *context, uint64_t delta)</td></tr>
<tr class="memdesc:ab9c9cb4468d68a4cc4193a5e252645c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures epoch-deadline expiration to yield to the async caller and the update the deadline.  <a href="async_8h.html#ab9c9cb4468d68a4cc4193a5e252645c7">More...</a><br /></td></tr>
<tr class="separator:ab9c9cb4468d68a4cc4193a5e252645c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5d36c0b5e480483b436ab66b6edfaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#adc5d36c0b5e480483b436ab66b6edfaf">wasmtime_call_future_poll</a> (<a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> *future)</td></tr>
<tr class="memdesc:adc5d36c0b5e480483b436ab66b6edfaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes WebAssembly in the function.  <a href="async_8h.html#adc5d36c0b5e480483b436ab66b6edfaf">More...</a><br /></td></tr>
<tr class="separator:adc5d36c0b5e480483b436ab66b6edfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66ef3248ec0e470ba3fd0e33d0c61cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#ac66ef3248ec0e470ba3fd0e33d0c61cd">wasmtime_call_future_delete</a> (<a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> *future)</td></tr>
<tr class="separator:ac66ef3248ec0e470ba3fd0e33d0c61cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db619eeb7eb53ecd2a3c7dfac07b293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#a1db619eeb7eb53ecd2a3c7dfac07b293">wasmtime_func_call_async</a> (<a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *context, const <a class="el" href="extern_8h.html#ac3661fabd7972df1ade869f17de29dc5">wasmtime_func_t</a> *func, const <a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353">wasmtime_val_t</a> *args, size_t nargs, <a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353">wasmtime_val_t</a> *results, size_t nresults, <a class="el" href="structwasm__trap__t.html">wasm_trap_t</a> **trap_ret, <a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> **error_ret)</td></tr>
<tr class="memdesc:a1db619eeb7eb53ecd2a3c7dfac07b293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes this function with the params given, returning the results asynchronously.  <a href="async_8h.html#a1db619eeb7eb53ecd2a3c7dfac07b293">More...</a><br /></td></tr>
<tr class="separator:a1db619eeb7eb53ecd2a3c7dfac07b293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d432ffbf227a581e93388d4142c4d98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#a9d432ffbf227a581e93388d4142c4d98">wasmtime_linker_define_async_func</a> (<a class="el" href="linker_8h.html#adcd278d48fae4abd464e95b98889104b">wasmtime_linker_t</a> *linker, const char *module, size_t module_len, const char *name, size_t name_len, const <a class="el" href="structwasm__functype__t.html">wasm_functype_t</a> *ty, <a class="el" href="async_8h.html#a45a33b6560ced2f920f72d12759467b0">wasmtime_func_async_callback_t</a> cb, void *data, void(*finalizer)(void *))</td></tr>
<tr class="memdesc:a9d432ffbf227a581e93388d4142c4d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a new async function in this linker.  <a href="async_8h.html#a9d432ffbf227a581e93388d4142c4d98">More...</a><br /></td></tr>
<tr class="separator:a9d432ffbf227a581e93388d4142c4d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5c0a5283c37e581b5bbe33c7437b09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#a2c5c0a5283c37e581b5bbe33c7437b09">wasmtime_linker_instantiate_async</a> (const <a class="el" href="linker_8h.html#adcd278d48fae4abd464e95b98889104b">wasmtime_linker_t</a> *linker, <a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *store, const <a class="el" href="module_8h.html#a3eb01c0fedee86fea2a4244a702eb107">wasmtime_module_t</a> *module, <a class="el" href="instance_8h.html#ac0398434f88148fd429f3f0185199875">wasmtime_instance_t</a> *instance, <a class="el" href="structwasm__trap__t.html">wasm_trap_t</a> **trap_ret, <a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> **error_ret)</td></tr>
<tr class="memdesc:a2c5c0a5283c37e581b5bbe33c7437b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a <a class="el" href="structwasm__module__t.html" title="Opaque struct representing a compiled wasm module.">wasm_module_t</a> with the items defined in this linker for an async store.  <a href="async_8h.html#a2c5c0a5283c37e581b5bbe33c7437b09">More...</a><br /></td></tr>
<tr class="separator:a2c5c0a5283c37e581b5bbe33c7437b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b8f35380f5a4836621750fc49c8f50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#af5b8f35380f5a4836621750fc49c8f50">wasmtime_instance_pre_instantiate_async</a> (const <a class="el" href="instance_8h.html#a0fc8e2a8b786d56fd32d1ea896961f7d">wasmtime_instance_pre_t</a> *instance_pre, <a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *store, <a class="el" href="instance_8h.html#ac0398434f88148fd429f3f0185199875">wasmtime_instance_t</a> *instance, <a class="el" href="structwasm__trap__t.html">wasm_trap_t</a> **trap_ret, <a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> **error_ret)</td></tr>
<tr class="memdesc:af5b8f35380f5a4836621750fc49c8f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates instance within the given store.  <a href="async_8h.html#af5b8f35380f5a4836621750fc49c8f50">More...</a><br /></td></tr>
<tr class="separator:af5b8f35380f5a4836621750fc49c8f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcec72103519d0d47694a68daba81bd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="async_8h.html#abcec72103519d0d47694a68daba81bd0">wasmtime_config_host_stack_creator_set</a> (<a class="el" href="structwasm__config__t.html">wasm_config_t</a> *, <a class="el" href="structwasmtime__stack__creator__t.html">wasmtime_stack_creator_t</a> *)</td></tr>
<tr class="separator:abcec72103519d0d47694a68daba81bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Wasmtime async functionality. </p>
<p >Async functionality in Wasmtime is well documented here: <a href="https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_support">https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_support</a></p>
<p >All WebAssembly executes synchronously, but an async support enables the Wasm code be executed on a seperate stack, so it can be paused and resumed. There are three mechanisms for yielding control from wasm to the caller: fuel, epochs, and async host functions.</p>
<p >When WebAssembly is executed, a <a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b" title="The structure representing a asynchronously running function.">wasmtime_call_future_t</a> is returned. This struct represents the state of the execution and each call to <a class="el" href="async_8h.html#adc5d36c0b5e480483b436ab66b6edfaf" title="Executes WebAssembly in the function.">wasmtime_call_future_poll</a> will execute the WebAssembly code on a seperate stack until the function returns or yields control back to the caller.</p>
<p >It's expected these futures are pulled in a loop until completed, at which point the future should be deleted. Functions that return a <a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b" title="The structure representing a asynchronously running function.">wasmtime_call_future_t</a> are special in that all parameters to that function should not be modified in any way and must be kept alive until the future is deleted. This includes concurrent calls for a single store - another function on a store should not be called while there is a <a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b" title="The structure representing a asynchronously running function.">wasmtime_call_future_t</a> alive.</p>
<p >As for asynchronous host calls - the reverse contract is upheld. Wasmtime will keep all parameters to the function alive and unmodified until the <a class="el" href="async_8h.html#acccdba20eece02d81457c00f8f7ca6de">wasmtime_func_async_continuation_callback_t</a> returns true. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a42fead8db7d36c554e84374caa6e7fef" name="a42fead8db7d36c554e84374caa6e7fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fead8db7d36c554e84374caa6e7fef">&#9670;&nbsp;</a></span>wasmtime_async_continuation_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structwasmtime__async__continuation__t.html">wasmtime_async_continuation_t</a> <a class="el" href="structwasmtime__async__continuation__t.html">wasmtime_async_continuation_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A continuation for the current state of the host function's execution. </p>

</div>
</div>
<a id="a54b55a7a8c4c5ac50ad0cbd56f82a77b" name="a54b55a7a8c4c5ac50ad0cbd56f82a77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b55a7a8c4c5ac50ad0cbd56f82a77b">&#9670;&nbsp;</a></span>wasmtime_call_future_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct wasmtime_call_future <a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The structure representing a asynchronously running function. </p>
<p >This structure is always owned by the caller and must be deleted using <a class="el" href="async_8h.html#ac66ef3248ec0e470ba3fd0e33d0c61cd">wasmtime_call_future_delete</a>.</p>
<p >Functions that return this type require that the parameters to the function are unmodified until this future is destroyed. </p>

</div>
</div>
<a id="a45a33b6560ced2f920f72d12759467b0" name="a45a33b6560ced2f920f72d12759467b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a33b6560ced2f920f72d12759467b0">&#9670;&nbsp;</a></span>wasmtime_func_async_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* wasmtime_func_async_callback_t) (void *env, <a class="el" href="func_8h.html#abad1840db69084f226feec107cc23d5e">wasmtime_caller_t</a> *caller, const <a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353">wasmtime_val_t</a> *args, size_t nargs, <a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353">wasmtime_val_t</a> *results, size_t nresults, <a class="el" href="structwasm__trap__t.html">wasm_trap_t</a> **trap_ret, <a class="el" href="structwasmtime__async__continuation__t.html">wasmtime_async_continuation_t</a> *continuation_ret)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback signature for <a class="el" href="async_8h.html#a9d432ffbf227a581e93388d4142c4d98" title="Defines a new async function in this linker.">wasmtime_linker_define_async_func</a>. </p>
<p >This is a host function that returns a continuation to be called later.</p>
<p >All the arguments to this function will be kept alive until the continuation returns that it has errored or has completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>user-provided argument passed to <a class="el" href="async_8h.html#a9d432ffbf227a581e93388d4142c4d98" title="Defines a new async function in this linker.">wasmtime_linker_define_async_func</a> </td></tr>
    <tr><td class="paramname">caller</td><td>a temporary object that can only be used during this function call. Used to acquire <a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81" title="Convenience alias for wasmtime_context.">wasmtime_context_t</a> or caller's state </td></tr>
    <tr><td class="paramname">args</td><td>the arguments provided to this function invocation </td></tr>
    <tr><td class="paramname">nargs</td><td>how many arguments are provided </td></tr>
    <tr><td class="paramname">results</td><td>where to write the results of this function </td></tr>
    <tr><td class="paramname">nresults</td><td>how many results must be produced </td></tr>
    <tr><td class="paramname">trap_ret</td><td>if assigned a not <code>NULL</code> value then the called function will trap with the returned error. Note that ownership of trap is transferred to wasmtime. </td></tr>
    <tr><td class="paramname">continuation_ret</td><td>the returned continuation that determines when the async function has completed executing.</td></tr>
  </table>
  </dd>
</dl>
<p>Only supported for async stores.</p>
<p >See <a class="el" href="func_8h.html#af90ff6b594f05f23e381ac16c22b70cf" title="Callback signature for wasmtime_func_new.">wasmtime_func_callback_t</a> for more information. </p>

</div>
</div>
<a id="acccdba20eece02d81457c00f8f7ca6de" name="acccdba20eece02d81457c00f8f7ca6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccdba20eece02d81457c00f8f7ca6de">&#9670;&nbsp;</a></span>wasmtime_func_async_continuation_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* wasmtime_func_async_continuation_callback_t) (void *env)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The callback to determine a continuation's current state.</p>
<p >Return true if the host call has completed, otherwise false will continue to yield WebAssembly execution. </p>

</div>
</div>
<a id="a043f38e279d4ab660a1f0e0d6b19dfed" name="a043f38e279d4ab660a1f0e0d6b19dfed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043f38e279d4ab660a1f0e0d6b19dfed">&#9670;&nbsp;</a></span>wasmtime_new_stack_memory_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> *(* wasmtime_new_stack_memory_callback_t) (void *env, size_t size, <a class="el" href="structwasmtime__stack__memory__t.html">wasmtime_stack_memory_t</a> *stack_ret)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A callback to create a new StackMemory from the specified parameters.</p>
<p >The result should be written to <code>stack_ret</code> and wasmtime will own the values written into that struct.</p>
<p >This callback must be thread-safe.</p>
<p >For more information about the parameters see the Rust documentation at <a href="https://docs.wasmtime.dev/api/wasmtime/trait.StackCreator.html#tymethod.new_stack">https://docs.wasmtime.dev/api/wasmtime/trait.StackCreator.html#tymethod.new_stack</a> </p>

</div>
</div>
<a id="adff8e4199dfe7eacb712398783a37fea" name="adff8e4199dfe7eacb712398783a37fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff8e4199dfe7eacb712398783a37fea">&#9670;&nbsp;</a></span>wasmtime_stack_memory_get_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t *(* wasmtime_stack_memory_get_callback_t) (void *env, size_t *out_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A callback to get the top of the stack address and the length of the stack, excluding guard pages.</p>
<p >For more information about the parameters see the Rust documentation at <a href="https://docs.wasmtime.dev/api/wasmtime/trait.StackMemory.html">https://docs.wasmtime.dev/api/wasmtime/trait.StackMemory.html</a> </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac66ef3248ec0e470ba3fd0e33d0c61cd" name="ac66ef3248ec0e470ba3fd0e33d0c61cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66ef3248ec0e470ba3fd0e33d0c61cd">&#9670;&nbsp;</a></span>wasmtime_call_future_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wasmtime_call_future_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> *&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >/brief Frees the underlying memory for a future.</p>
<p >All wasmtime_call_future_t are owned by the caller and should be deleted using this function. </p>

</div>
</div>
<a id="adc5d36c0b5e480483b436ab66b6edfaf" name="adc5d36c0b5e480483b436ab66b6edfaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5d36c0b5e480483b436ab66b6edfaf">&#9670;&nbsp;</a></span>wasmtime_call_future_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wasmtime_call_future_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> *&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes WebAssembly in the function. </p>
<p >Returns true if the function call has completed. After this function returns true, it should <em>not</em> be called again for a given future.</p>
<p >This function returns false if execution has yielded either due to being out of fuel (see wasmtime_context_fuel_async_yield_interval), or the epoch has been incremented enough (see wasmtime_context_epoch_deadline_async_yield_and_update). The function may also return false if asynchronous host functions have been called, which then calling this function will call the continuation from the async host function.</p>
<p >For more see the information at <a href="https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#asynchronous-wasm">https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#asynchronous-wasm</a> </p>

</div>
</div>
<a id="a0912c2ed7f057aab0cebf29481311af9" name="a0912c2ed7f057aab0cebf29481311af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0912c2ed7f057aab0cebf29481311af9">&#9670;&nbsp;</a></span>wasmtime_config_async_stack_size_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wasmtime_config_async_stack_size_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwasm__config__t.html">wasm_config_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the size of the stacks used for asynchronous execution. </p>
<p >This setting configures the size of the stacks that are allocated for asynchronous execution.</p>
<p >The value cannot be less than max_wasm_stack.</p>
<p >The amount of stack space guaranteed for host functions is async_stack_size - max_wasm_stack, so take care not to set these two values close to one another; doing so may cause host functions to overflow the stack and abort the process.</p>
<p >By default this option is 2 MiB.</p>
<p >For more information see the Rust documentation at <a href="https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_stack_size">https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_stack_size</a> </p>

</div>
</div>
<a id="a2bb7f188ac93c9734c916f80929ee28d" name="a2bb7f188ac93c9734c916f80929ee28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb7f188ac93c9734c916f80929ee28d">&#9670;&nbsp;</a></span>wasmtime_config_async_support_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wasmtime_config_async_support_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwasm__config__t.html">wasm_config_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether or not to enable support for asynchronous functions in Wasmtime. </p>
<p >When enabled, the config can optionally define host functions with async. Instances created and functions called with this Config must be called through their asynchronous APIs, however. For example using wasmtime_func_call will panic when used with this config.</p>
<p >For more information see the Rust documentation at <a href="https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_support">https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_support</a> </p>

</div>
</div>
<a id="abcec72103519d0d47694a68daba81bd0" name="abcec72103519d0d47694a68daba81bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcec72103519d0d47694a68daba81bd0">&#9670;&nbsp;</a></span>wasmtime_config_host_stack_creator_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wasmtime_config_host_stack_creator_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwasm__config__t.html">wasm_config_t</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwasmtime__stack__creator__t.html">wasmtime_stack_creator_t</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets a custom stack creator.</p>
<p >Custom memory creators are used when creating creating async instance stacks for the on-demand instance allocation strategy.</p>
<p >The config does <b>not</b> take ownership of the <a class="el" href="structwasmtime__stack__creator__t.html">wasmtime_stack_creator_t</a> passed in, but instead copies all the values in the struct.</p>
<p >For more information see the Rust documentation at <a href="https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.with_host_stack">https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.with_host_stack</a> </p>

</div>
</div>
<a id="ab9c9cb4468d68a4cc4193a5e252645c7" name="ab9c9cb4468d68a4cc4193a5e252645c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9c9cb4468d68a4cc4193a5e252645c7">&#9670;&nbsp;</a></span>wasmtime_context_epoch_deadline_async_yield_and_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> * wasmtime_context_epoch_deadline_async_yield_and_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures epoch-deadline expiration to yield to the async caller and the update the deadline. </p>
<p >This is only suitable with use of a store associated with an async config because only then are futures used and yields are possible.</p>
<p >See the Rust documentation for more: <a href="https://docs.wasmtime.dev/api/wasmtime/struct.Store.html#method.epoch_deadline_async_yield_and_update">https://docs.wasmtime.dev/api/wasmtime/struct.Store.html#method.epoch_deadline_async_yield_and_update</a> </p>

</div>
</div>
<a id="af1161879d69bfaf8ab47637f92111874" name="af1161879d69bfaf8ab47637f92111874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1161879d69bfaf8ab47637f92111874">&#9670;&nbsp;</a></span>wasmtime_context_fuel_async_yield_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> * wasmtime_context_fuel_async_yield_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures a Store to yield execution of async WebAssembly code periodically. </p>
<p >When a Store is configured to consume fuel with <code>wasmtime_config_consume_fuel</code> this method will configure what happens when fuel runs out. Specifically executing WebAssembly will be suspended and control will be yielded back to the caller.</p>
<p >This is only suitable with use of a store associated with an async config because only then are futures used and yields are possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>the context for the store to configure. </td></tr>
    <tr><td class="paramname">interval</td><td>the amount of fuel at which to yield. A value of 0 will disable yielding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1db619eeb7eb53ecd2a3c7dfac07b293" name="a1db619eeb7eb53ecd2a3c7dfac07b293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db619eeb7eb53ecd2a3c7dfac07b293">&#9670;&nbsp;</a></span>wasmtime_func_call_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> * wasmtime_func_call_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="extern_8h.html#ac3661fabd7972df1ade869f17de29dc5">wasmtime_func_t</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353">wasmtime_val_t</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353">wasmtime_val_t</a> *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nresults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwasm__trap__t.html">wasm_trap_t</a> **&#160;</td>
          <td class="paramname"><em>trap_ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> **&#160;</td>
          <td class="paramname"><em>error_ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes this function with the params given, returning the results asynchronously. </p>
<p >This function is the same as wasmtime_func_call except that it is asynchronous. This is only compatible with stores associated with an asynchronous config.</p>
<p >The result is a future that is owned by the caller and must be deleted via <a class="el" href="async_8h.html#ac66ef3248ec0e470ba3fd0e33d0c61cd">wasmtime_call_future_delete</a>.</p>
<p >The <code>args</code> and <code>results</code> pointers may be <code>NULL</code> if the corresponding length is zero. The <code>trap_ret</code> and <code>error_ret</code> pointers may <em>not</em> be <code>NULL</code>.</p>
<p >Does not take ownership of <a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353" title="Convenience alias for wasmtime_val_t.">wasmtime_val_t</a> arguments or <a class="el" href="val_8h.html#a97038492e2cc547de6c95cf597453353" title="Convenience alias for wasmtime_val_t.">wasmtime_val_t</a> results, and all parameters to this function must be kept alive and not modified until the returned <a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b" title="The structure representing a asynchronously running function.">wasmtime_call_future_t</a> is deleted. This includes the context and store parameters. Only a single future can be alive for a given store at a single time (meaning only call this function after the previous call's future was deleted).</p>
<p >See the header documentation for for more information.</p>
<p >For more information see the Rust documentation at <a href="https://docs.wasmtime.dev/api/wasmtime/struct.Func.html#method.call_async">https://docs.wasmtime.dev/api/wasmtime/struct.Func.html#method.call_async</a> </p>

</div>
</div>
<a id="af5b8f35380f5a4836621750fc49c8f50" name="af5b8f35380f5a4836621750fc49c8f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b8f35380f5a4836621750fc49c8f50">&#9670;&nbsp;</a></span>wasmtime_instance_pre_instantiate_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> * wasmtime_instance_pre_instantiate_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="instance_8h.html#a0fc8e2a8b786d56fd32d1ea896961f7d">wasmtime_instance_pre_t</a> *&#160;</td>
          <td class="paramname"><em>instance_pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="instance_8h.html#ac0398434f88148fd429f3f0185199875">wasmtime_instance_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwasm__trap__t.html">wasm_trap_t</a> **&#160;</td>
          <td class="paramname"><em>trap_ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> **&#160;</td>
          <td class="paramname"><em>error_ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates instance within the given store. </p>
<p >This will also run the function's startup function, if there is one.</p>
<p >For more information on async instantiation see <a class="el" href="async_8h.html#a2c5c0a5283c37e581b5bbe33c7437b09" title="Instantiates a wasm_module_t with the items defined in this linker for an async store.">wasmtime_linker_instantiate_async</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance_pre</td><td>the pre-initialized instance </td></tr>
    <tr><td class="paramname">store</td><td>the store in which to create the instance </td></tr>
    <tr><td class="paramname">instance</td><td>where to store the returned instance </td></tr>
    <tr><td class="paramname">trap_ret</td><td>where to store the returned trap </td></tr>
    <tr><td class="paramname">error_ret</td><td>where to store the returned trap</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>trap_ret</code> and <code>error_ret</code> pointers may <em>not</em> be <code>NULL</code> and the returned memory is owned by the caller.</p>
<p >All arguments to this function must outlive the returned future and be unmodified until the future is deleted. </p>

</div>
</div>
<a id="a9d432ffbf227a581e93388d4142c4d98" name="a9d432ffbf227a581e93388d4142c4d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d432ffbf227a581e93388d4142c4d98">&#9670;&nbsp;</a></span>wasmtime_linker_define_async_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> * wasmtime_linker_define_async_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="linker_8h.html#adcd278d48fae4abd464e95b98889104b">wasmtime_linker_t</a> *&#160;</td>
          <td class="paramname"><em>linker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>module_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structwasm__functype__t.html">wasm_functype_t</a> *&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="async_8h.html#a45a33b6560ced2f920f72d12759467b0">wasmtime_func_async_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>finalizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a new async function in this linker. </p>
<p >This function behaves similar to <a class="el" href="linker_8h.html#ae52312227094b300be9991051192d75b" title="Defines a new function in this linker.">wasmtime_linker_define_func</a>, except it supports async callbacks.</p>
<p >The callback <code>cb</code> will be invoked on another stack (fiber for Windows). </p>

</div>
</div>
<a id="a2c5c0a5283c37e581b5bbe33c7437b09" name="a2c5c0a5283c37e581b5bbe33c7437b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5c0a5283c37e581b5bbe33c7437b09">&#9670;&nbsp;</a></span>wasmtime_linker_instantiate_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b">wasmtime_call_future_t</a> * wasmtime_linker_instantiate_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="linker_8h.html#adcd278d48fae4abd464e95b98889104b">wasmtime_linker_t</a> *&#160;</td>
          <td class="paramname"><em>linker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="store_8h.html#a98d503c153853bb098689a122109de81">wasmtime_context_t</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="module_8h.html#a3eb01c0fedee86fea2a4244a702eb107">wasmtime_module_t</a> *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="instance_8h.html#ac0398434f88148fd429f3f0185199875">wasmtime_instance_t</a> *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwasm__trap__t.html">wasm_trap_t</a> **&#160;</td>
          <td class="paramname"><em>trap_ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="error_8h.html#a6df4cddb88cff2bfdeecf8bba560af2c">wasmtime_error_t</a> **&#160;</td>
          <td class="paramname"><em>error_ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates a <a class="el" href="structwasm__module__t.html" title="Opaque struct representing a compiled wasm module.">wasm_module_t</a> with the items defined in this linker for an async store. </p>
<p >This is the same as <a class="el" href="linker_8h.html#aea4e0acfac43a22f93b93652fe205c24" title="Instantiates a wasm_module_t with the items defined in this linker.">wasmtime_linker_instantiate</a> but used for async stores (which requires functions are called asynchronously). The returning <a class="el" href="async_8h.html#a54b55a7a8c4c5ac50ad0cbd56f82a77b" title="The structure representing a asynchronously running function.">wasmtime_call_future_t</a> must be polled using <a class="el" href="async_8h.html#adc5d36c0b5e480483b436ab66b6edfaf" title="Executes WebAssembly in the function.">wasmtime_call_future_poll</a>, and is owned and must be deleted using <a class="el" href="async_8h.html#ac66ef3248ec0e470ba3fd0e33d0c61cd">wasmtime_call_future_delete</a>.</p>
<p >The <code>trap_ret</code> and <code>error_ret</code> pointers may <em>not</em> be <code>NULL</code> and the returned memory is owned by the caller.</p>
<p >All arguments to this function must outlive the returned future and be unmodified until the future is deleted. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_b0e440e2d445bbd46353ed1b6699c971.html">wasmtime</a></li><li class="navelem"><a class="el" href="async_8h.html">async.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
