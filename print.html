<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Wasmtime</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">2.</strong> Using the Wasmtime CLI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli-install.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="cli-options.html"><strong aria-hidden="true">2.2.</strong> CLI Options</a></li><li class="chapter-item expanded "><a href="cli-logging.html"><strong aria-hidden="true">2.3.</strong> CLI Logging</a></li><li class="chapter-item expanded "><a href="cli-cache.html"><strong aria-hidden="true">2.4.</strong> Cache Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="lang.html"><strong aria-hidden="true">3.</strong> Using the Wasmtime API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lang-rust.html"><strong aria-hidden="true">3.1.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples-rust-hello-world.html"><strong aria-hidden="true">3.1.1.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="examples-rust-gcd.html"><strong aria-hidden="true">3.1.2.</strong> Calculating the GCD</a></li><li class="chapter-item expanded "><a href="examples-rust-memory.html"><strong aria-hidden="true">3.1.3.</strong> Using Linear Memory</a></li><li class="chapter-item expanded "><a href="examples-rust-wasi.html"><strong aria-hidden="true">3.1.4.</strong> WASI</a></li><li class="chapter-item expanded "><a href="examples-rust-linking.html"><strong aria-hidden="true">3.1.5.</strong> Linking Modules</a></li><li class="chapter-item expanded "><a href="examples-rust-debugging.html"><strong aria-hidden="true">3.1.6.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="examples-rust-core-dumps.html"><strong aria-hidden="true">3.1.7.</strong> Core Dumps</a></li><li class="chapter-item expanded "><a href="examples-rust-multi-value.html"><strong aria-hidden="true">3.1.8.</strong> Using Multi-Value</a></li></ol></li><li class="chapter-item expanded "><a href="lang-c.html"><strong aria-hidden="true">3.2.</strong> C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples-c-hello-world.html"><strong aria-hidden="true">3.2.1.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="examples-c-gcd.html"><strong aria-hidden="true">3.2.2.</strong> Calculating the GCD</a></li><li class="chapter-item expanded "><a href="examples-c-memory.html"><strong aria-hidden="true">3.2.3.</strong> Using Linear Memory</a></li><li class="chapter-item expanded "><a href="examples-c-wasi.html"><strong aria-hidden="true">3.2.4.</strong> WASI</a></li><li class="chapter-item expanded "><a href="examples-c-linking.html"><strong aria-hidden="true">3.2.5.</strong> Linking Modules</a></li><li class="chapter-item expanded "><a href="examples-c-debugging.html"><strong aria-hidden="true">3.2.6.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="examples-c-multi-value.html"><strong aria-hidden="true">3.2.7.</strong> Using Multi-Value</a></li></ol></li><li class="chapter-item expanded "><a href="lang-python.html"><strong aria-hidden="true">3.3.</strong> Python</a></li><li class="chapter-item expanded "><a href="lang-dotnet.html"><strong aria-hidden="true">3.4.</strong> .NET</a></li><li class="chapter-item expanded "><a href="lang-go.html"><strong aria-hidden="true">3.5.</strong> Go</a></li><li class="chapter-item expanded "><a href="lang-bash.html"><strong aria-hidden="true">3.6.</strong> Bash</a></li><li class="chapter-item expanded "><a href="lang-ruby.html"><strong aria-hidden="true">3.7.</strong> Ruby</a></li><li class="chapter-item expanded "><a href="lang-elixir.html"><strong aria-hidden="true">3.8.</strong> Elixir</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">4.</strong> Further Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples-debugging.html"><strong aria-hidden="true">4.1.</strong> Debugging WebAssembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples-debugging-native-debugger.html"><strong aria-hidden="true">4.1.1.</strong> Debugging with gdb and lldb</a></li><li class="chapter-item expanded "><a href="examples-debugging-core-dumps.html"><strong aria-hidden="true">4.1.2.</strong> Debugging with Core Dumps</a></li></ol></li><li class="chapter-item expanded "><a href="examples-profiling.html"><strong aria-hidden="true">4.2.</strong> Profiling WebAssembly</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples-profiling-perf.html"><strong aria-hidden="true">4.2.1.</strong> Profiling with Perf</a></li><li class="chapter-item expanded "><a href="examples-profiling-vtune.html"><strong aria-hidden="true">4.2.2.</strong> Profiling with VTune</a></li><li class="chapter-item expanded "><a href="examples-profiling-samply.html"><strong aria-hidden="true">4.2.3.</strong> Profiling with samply</a></li><li class="chapter-item expanded "><a href="examples-profiling-guest.html"><strong aria-hidden="true">4.2.4.</strong> Cross-platform Profiling</a></li></ol></li><li class="chapter-item expanded "><a href="wmemcheck.html"><strong aria-hidden="true">4.3.</strong> Checking Guests' Memory Accesses</a></li><li class="chapter-item expanded "><a href="examples-minimal.html"><strong aria-hidden="true">4.4.</strong> Building a minimal embedding</a></li></ol></li><li class="chapter-item expanded "><a href="stability.html"><strong aria-hidden="true">5.</strong> Stability</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="stability-release.html"><strong aria-hidden="true">5.1.</strong> Release Process</a></li><li class="chapter-item expanded "><a href="stability-tiers.html"><strong aria-hidden="true">5.2.</strong> Tiers of support</a></li><li class="chapter-item expanded "><a href="stability-platform-support.html"><strong aria-hidden="true">5.3.</strong> Platform Support</a></li></ol></li><li class="chapter-item expanded "><a href="security.html"><strong aria-hidden="true">6.</strong> Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="security-disclosure.html"><strong aria-hidden="true">6.1.</strong> Disclosure Policy</a></li><li class="chapter-item expanded "><a href="security-what-is-considered-a-security-vulnerability.html"><strong aria-hidden="true">6.2.</strong> What is considered a security bug?</a></li></ol></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">7.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing-architecture.html"><strong aria-hidden="true">7.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="contributing-building.html"><strong aria-hidden="true">7.2.</strong> Building</a></li><li class="chapter-item expanded "><a href="contributing-testing.html"><strong aria-hidden="true">7.3.</strong> Testing</a></li><li class="chapter-item expanded "><a href="contributing-fuzzing.html"><strong aria-hidden="true">7.4.</strong> Fuzzing</a></li><li class="chapter-item expanded "><a href="contributing-ci.html"><strong aria-hidden="true">7.5.</strong> CI</a></li><li class="chapter-item expanded "><a href="contributing-reducing-test-cases.html"><strong aria-hidden="true">7.6.</strong> Reducing Test Cases</a></li><li class="chapter-item expanded "><a href="contributing-cross-compiling.html"><strong aria-hidden="true">7.7.</strong> Cross Compiling</a></li><li class="chapter-item expanded "><a href="contributing-coding-guidelines.html"><strong aria-hidden="true">7.8.</strong> Coding Guidelines</a></li><li class="chapter-item expanded "><a href="contributing-development-process.html"><strong aria-hidden="true">7.9.</strong> Development Process</a></li><li class="chapter-item expanded "><a href="contributing-implementing-wasm-proposals.html"><strong aria-hidden="true">7.10.</strong> Implementing Wasm Proposals</a></li><li class="chapter-item expanded "><a href="contributing-maintainer-guidelines.html"><strong aria-hidden="true">7.11.</strong> Maintainer Guidelines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing-code-review.html"><strong aria-hidden="true">7.11.1.</strong> Code Review</a></li><li class="chapter-item expanded "><a href="contributing-release-process.html"><strong aria-hidden="true">7.11.2.</strong> Release Process</a></li></ol></li><li class="chapter-item expanded "><a href="contributing-governance.html"><strong aria-hidden="true">7.12.</strong> Governance</a></li><li class="chapter-item expanded "><a href="contributing-coc.html"><strong aria-hidden="true">7.13.</strong> Code of Conduct</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Wasmtime</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/bytecodealliance/wasmtime">Wasmtime</a> is a standalone runtime for WebAssembly, WASI, and the
Component Model by the <a href="https://bytecodealliance.org/">Bytecode Alliance</a>.</p>
<p><a href="https://webassembly.org/">WebAssembly</a> (abbreviated Wasm) is a binary instruction format that is designed
to be a portable compilation target for programming languages. Wasm binaries
typically have a <code>.wasm</code> file extension. In this documentation, we'll also use
the textual representation of the binary files, which have a <code>.wat</code> file
extension.</p>
<p><a href="https://wasi.dev">WASI</a> (the WebAssembly System Interface) defines interfaces that provide a
secure and portable way to access several operating-system-like features such as
filesystems, networking, clocks, and random numbers.</p>
<p><a href="https://github.com/WebAssembly/component-model">The Component Model</a> is a Wasm architecture that provides a binary format for
portable, cross-language composition. More specifically, it supports the use of
interfaces via which components can communicate with each other. WASI
is defined in terms of component model interfaces.</p>
<p>Wasmtime runs WebAssembly code <a href="https://webassembly.org/docs/non-web/">outside of the Web</a>, and can be used both as a
command-line utility or as a library embedded in a larger application. It
strives to be</p>
<ul>
<li><strong>Fast</strong>: Wasmtime is built on the optimizing <a href="https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/README.md">Cranelift</a> code generator.</li>
<li><strong>Secure</strong>: Wasmtime's development is strongly focused on correctness and
security.</li>
<li><strong>Configurable</strong>: Wasmtime uses sensible defaults, but can also be configured
to provide more fine-grained control over things like CPU and memory
consumption.</li>
<li><strong>Standards Compliant</strong>: Wasmtime passes the official WebAssembly test suite
and the Wasmtime developers are intimately engaged with the WebAssembly
standards process.</li>
</ul>
<p>This documentation is intended to serve a number of purposes and within you'll
find:</p>
<ul>
<li><a href="lang.html">How to use Wasmtime from a number of languages</a></li>
<li><a href="cli.html">How to install and use the <code>wasmtime</code> CLI</a></li>
<li>Information about <a href="stability.html">stability</a> and <a href="security.html">security</a> in
Wasmtime.</li>
<li>Documentation about <a href="contributing.html">contributing</a> to Wasmtime.</li>
</ul>
<p>... and more! The source for this guide <a href="https://github.com/bytecodealliance/wasmtime/tree/main/docs">lives on
GitHub</a> and
contributions are welcome!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-wasmtime-cli"><a class="header" href="#using-the-wasmtime-cli">Using the <code>wasmtime</code> CLI</a></h1>
<p>In addition to the embedding API which allows you to use Wasmtime as a
library, the Wasmtime project also provides a <code>wasmtime</code> CLI tool to conveniently
execute WebAssembly modules from the command line.</p>
<p>This section will provide a guide to the <code>wasmtime</code> CLI and major functionality
that it contains. In short, however, you can execute a WebAssembly file
(actually doing work as part of the <code>start</code> function) like so:</p>
<pre><code class="language-sh">$ wasmtime foo.wasm
</code></pre>
<p>Or similarly if you want to invoke a "start" function, such as with WASI
modules, you can execute</p>
<pre><code class="language-sh">$ wasmtime --invoke _start foo.wasm
</code></pre>
<p>For more information be sure to check out <a href="cli-install.html">how to install the
CLI</a>, <a href="cli-options.html">the list of options you can
pass</a>, and <a href="cli-logging.html">how to enable logging</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-wasmtime"><a class="header" href="#installing-wasmtime">Installing <code>wasmtime</code></a></h1>
<p>Here we'll show you how to install the <code>wasmtime</code> command line tool. Note that
this is distinct from embedding the Wasmtime project into another, for that
you'll want to consult the <a href="lang.html">embedding documentation</a>.</p>
<p>The easiest way to install the <code>wasmtime</code> CLI tool is through our installation
script. Linux and macOS users can execute the following:</p>
<pre><code class="language-sh">$ curl https://wasmtime.dev/install.sh -sSf | bash
</code></pre>
<p>This will download a precompiled version of <code>wasmtime</code>, place it in
<code>$HOME/.wasmtime</code>, and update your shell configuration to place the right
directory in <code>PATH</code>.</p>
<p>Windows users will want to visit our <a href="https://github.com/bytecodealliance/wasmtime/releases">releases page</a> and can download
the MSI installer (<code>wasmtime-dev-x86_64-windows.msi</code> for example) and use that
to install.</p>
<p>You can confirm your installation works by executing:</p>
<pre><code class="language-sh">$ wasmtime -V
wasmtime 0.12.0
</code></pre>
<p>And now you're off to the races! Be sure to check out the <a href="cli-options.html">various CLI
options</a> as well.</p>
<h2 id="download-precompiled-binaries"><a class="header" href="#download-precompiled-binaries">Download Precompiled Binaries</a></h2>
<p>If you'd prefer to not use an installation script, or you're perhaps
orchestrating something in CI, you can also download one of our precompiled
binaries of <code>wasmtime</code>. We have two channels of releases right now for
precompiled binaries:</p>
<ol>
<li>Each tagged release will have a full set of release artifacts on the <a href="https://github.com/bytecodealliance/wasmtime/releases">GitHub
releases page</a>.</li>
<li>The <a href="https://github.com/bytecodealliance/wasmtime/releases/tag/dev"><code>dev</code> release</a> is also continuously updated with the latest build of the
<code>main</code> branch. If you want the latest-and-greatest and don't mind a bit of
instability, this is the release for you.</li>
</ol>
<p>When downloading binaries you'll likely want one of the following archives (for
the <code>dev</code> release)</p>
<ul>
<li>Linux users - [<code>wasmtime-dev-x86_64-linux.tar.xz</code>]</li>
<li>macOS users - [<code>wasmtime-dev-x86_64-macos.tar.xz</code>]</li>
<li>Windows users - [<code>wasmtime-dev-x86_64-windows.zip</code>]</li>
</ul>
<p>Each of these archives has a <code>wasmtime</code> binary placed inside which can be
executed normally as the CLI would.</p>
<h2 id="compiling-from-source"><a class="header" href="#compiling-from-source">Compiling from Source</a></h2>
<p>If you'd prefer to compile the <code>wasmtime</code> CLI from source, you'll want to
consult the <a href="contributing-building.html">contributing documentation for building</a>.
Be sure to use a <code>--release</code> build if you're curious to do benchmarking!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-options-for-wasmtime"><a class="header" href="#cli-options-for-wasmtime">CLI Options for <code>wasmtime</code></a></h1>
<p>The <code>wasmtime</code> CLI is organized into a few subcommands. If no subcommand is
provided it'll assume <code>run</code>, which is to execute a wasm file. The subcommands
supported by <code>wasmtime</code> are:</p>
<h2 id="help"><a class="header" href="#help"><code>help</code></a></h2>
<p>This is a general subcommand used to print help information to the terminal. You
can execute any number of the following:</p>
<pre><code class="language-sh">$ wasmtime help
$ wasmtime --help
$ wasmtime -h
$ wasmtime help run
$ wasmtime run -h
</code></pre>
<p>When in doubt, try running the <code>help</code> command to learn more about functionality!</p>
<h2 id="run"><a class="header" href="#run"><code>run</code></a></h2>
<p>This is the <code>wasmtime</code> CLI's main subcommand, and it's also the default if no
other subcommand is provided. The <code>run</code> command will execute a WebAssembly
module. This means that the module will be compiled to native code,
instantiated, and then optionally have an export executed.</p>
<p>The <code>wasmtime</code> CLI will automatically hook up any WASI-related imported
functionality, but at this time if your module imports anything else it will
fail instantiation.</p>
<p>The <code>run</code> command takes one positional argument which is the name of the module
to run:</p>
<pre><code class="language-sh">$ wasmtime run foo.wasm
$ wasmtime foo.wasm
</code></pre>
<p>Note that the <code>wasmtime</code> CLI can take both a binary WebAssembly file (<code>*.wasm</code>)
as well as the text format for WebAssembly (<code>*.wat</code>):</p>
<pre><code class="language-sh">$ wasmtime foo.wat
</code></pre>
<p>The <code>run</code> command accepts an optional <code>invoke</code> argument which is the name of
an exported function of the module to run.</p>
<pre><code class="language-sh">$ wasmtime run foo.wasm --invoke initialize
</code></pre>
<h2 id="serve"><a class="header" href="#serve"><code>serve</code></a></h2>
<p>The <code>serve</code> subcommand runs a WebAssembly component in the <code>wasi:http/proxy</code>
world via the WASI HTTP API, which is available since Wasmtime 18.0.0. The goal
of this world is to support sending and receiving HTTP requests.</p>
<p>The <code>serve</code> command takes one positional argument which is the name of the
component to run:</p>
<pre><code class="language-sh">$ wasmtime serve foo.wasm
</code></pre>
<p>Furthermore, an address can be specified via:</p>
<pre><code class="language-sh">$ wasmtime serve --addr=0.0.0.0:8081 foo.wasm
</code></pre>
<p>At the time of writing, the <code>wasi:http/proxy</code> world is still experimental and
requires setup of some <code>wit</code> dependencies. For more information, see
the <a href="https://github.com/sunfishcode/hello-wasi-http/">hello-wasi-http</a> example.</p>
<h2 id="wast"><a class="header" href="#wast"><code>wast</code></a></h2>
<p>The <code>wast</code> command executes a <code>*.wast</code> file which is the test format for the
official WebAssembly spec test suite. This subcommand will execute the script
file which has a number of directives supported to instantiate modules, link
tests, etc.</p>
<p>Executing this looks like:</p>
<pre><code class="language-sh">$ wasmtime wast foo.wast
</code></pre>
<h2 id="config"><a class="header" href="#config"><code>config</code></a></h2>
<p>This subcommand is used to control and edit local Wasmtime configuration
settings. The primary purpose of this currently is to configure <a href="./cli-cache.html">how Wasmtime's
code caching works</a>. You can create a new configuration file for
you to edit with:</p>
<pre><code class="language-sh">$ wasmtime config new
</code></pre>
<p>And that'll print out the path to the file you can edit.</p>
<h2 id="compile"><a class="header" href="#compile"><code>compile</code></a></h2>
<p>This subcommand is used to Ahead-Of-Time (AOT) compile a WebAssembly module to produce
a "compiled wasm" (.cwasm) file.</p>
<p>The <code>wasmtime run</code> subcommand can then be used to run a AOT-compiled WebAssembly module:</p>
<pre><code class="language-sh">$ wasmtime compile foo.wasm
$ wasmtime foo.cwasm
</code></pre>
<p>AOT-compiled modules can be run from hosts that are compatible with the target
environment of the AOT-completed module.</p>
<h2 id="settings"><a class="header" href="#settings"><code>settings</code></a></h2>
<p>This subcommand is used to print the available Cranelift settings for a given target.</p>
<p>When run without options, it will print the settings for the host target and also
display what Cranelift settings are inferred for the host:</p>
<pre><code class="language-sh">$ wasmtime settings
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging-in-the-wasmtime-cli"><a class="header" href="#logging-in-the-wasmtime-cli">Logging in the <code>wasmtime</code> CLI</a></h1>
<p>Wasmtime's libraries use Rust's <a href="https://crates.io/crates/log"><code>log</code></a> crate to log diagnostic
information, and the <code>wasmtime</code> CLI executable uses <a href="https://crates.io/crates/pretty_env_logger"><code>pretty_env_logger</code></a>
by default for logging this information to the console.</p>
<p>Basic logging is controlled by the <code>RUST_LOG</code> environment variable. For example,
To enable logging of WASI system calls, similar to the <code>strace</code> command on Linux,
set <code>RUST_LOG=wasi_common=trace</code>.</p>
<pre><code class="language-sh">$ RUST_LOG=wasi_common=trace wasmtime hello.wasm
[...]
 TRACE wasi_common::hostcalls_impl::fs                       &gt; fd_write(fd=1, iovs_ptr=0x10408, iovs_len=1, nwritten=0x10404)
Hello, world!
 TRACE wasi_common::hostcalls_impl::fs                       &gt;      | *nwritten=14
 TRACE wasi_common::hostcalls                                &gt;      | errno=ESUCCESS (No error occurred. System call completed successfully.)
 TRACE wasi_common::hostcalls_impl::misc                     &gt; proc_exit(rval=1)
</code></pre>
<p>Wasmtime can also redirect the log messages into log files, with the
<code>-D log-to-files</code> option. It creates one file per thread within Wasmtime, with
the files named <code>wasmtime.dbg.*</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cache-configuration-of-wasmtime"><a class="header" href="#cache-configuration-of-wasmtime">Cache Configuration of <code>wasmtime</code></a></h1>
<p>The configuration file uses the <a href="https://github.com/toml-lang/toml">toml</a> format.
You can create a configuration file at the default location with:</p>
<pre><code class="language-sh">$ wasmtime config new
</code></pre>
<p>It will print the location regardless of the success.
Please refer to the  <code>--help</code> message for using a custom location.</p>
<p>All settings, except <code>enabled</code>, are <strong>optional</strong>.
If the setting is not specified, the <strong>default</strong> value is used.
<em><strong>Thus, if you don't know what values to use, don't specify them.</strong></em>
The default values might be tuned in the future.</p>
<p>Wasmtime assumes all the options are in the <code>cache</code> section.</p>
<p>Example config:</p>
<pre><code class="language-toml">[cache]
enabled = true
directory = "/nfs-share/wasmtime-cache/"
cleanup-interval = "30m"
files-total-size-soft-limit = "1Gi"
</code></pre>
<p>Please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section to learn how it works.</p>
<p>If you think some default value should be tuned, some new settings
should be introduced or some behavior should be changed, you are
welcome to discuss it and contribute to <a href="https://github.com/bytecodealliance/wasmtime">the Wasmtime repository</a>.</p>
<h2 id="setting-enabled"><a class="header" href="#setting-enabled">Setting <code>enabled</code></a></h2>
<ul>
<li><strong>type</strong>: boolean</li>
<li><strong>format</strong>: <code>true | false</code></li>
<li><strong>default</strong>: <code>true</code></li>
</ul>
<p>Specifies whether the cache system is used or not.</p>
<p>This field is <em>mandatory</em>.
The default value is used when configuration file is not specified
and none exists at the default location.</p>
<h2 id="setting-directory"><a class="header" href="#setting-directory">Setting <code>directory</code></a></h2>
<ul>
<li><strong>type</strong>: string (path)</li>
<li><strong>default</strong>: look up <code>cache_dir</code> in <a href="https://crates.io/crates/directories">directories</a> crate</li>
</ul>
<p>Specifies where the cache directory is. Must be an absolute path.</p>
<h2 id="setting-worker-event-queue-size"><a class="header" href="#setting-worker-event-queue-size">Setting <code>worker-event-queue-size</code></a></h2>
<ul>
<li><strong>type</strong>: string (SI prefix)</li>
<li><strong>format</strong>: <code>"{integer}(K | M | G | T | P)?"</code></li>
<li><strong>default</strong>: <code>"16"</code></li>
</ul>
<p>Size of <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> event queue.
If the queue is full, incoming cache usage events will be dropped.</p>
<h2 id="setting-baseline-compression-level"><a class="header" href="#setting-baseline-compression-level">Setting <code>baseline-compression-level</code></a></h2>
<ul>
<li><strong>type</strong>: integer</li>
<li><strong>default</strong>: <code>3</code>, the default zstd compression level</li>
</ul>
<p>Compression level used when a new cache file is being written by the <a href="cli-cache.html#how-does-the-cache-work">cache system</a>.
Wasmtime uses <a href="https://facebook.github.io/zstd/">zstd</a> compression.</p>
<h2 id="setting-optimized-compression-level"><a class="header" href="#setting-optimized-compression-level">Setting <code>optimized-compression-level</code></a></h2>
<ul>
<li><strong>type</strong>: integer</li>
<li><strong>default</strong>: <code>20</code></li>
</ul>
<p>Compression level used when the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> decides to recompress a cache file.
Wasmtime uses <a href="https://facebook.github.io/zstd/">zstd</a> compression.</p>
<h2 id="setting-optimized-compression-usage-counter-threshold"><a class="header" href="#setting-optimized-compression-usage-counter-threshold">Setting <code>optimized-compression-usage-counter-threshold</code></a></h2>
<ul>
<li><strong>type</strong>: string (SI prefix)</li>
<li><strong>format</strong>: <code>"{integer}(K | M | G | T | P)?"</code></li>
<li><strong>default</strong>: <code>"256"</code></li>
</ul>
<p>One of the conditions for the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> to recompress a cache file
is to have usage count of the file exceeding this threshold.</p>
<h2 id="setting-cleanup-interval"><a class="header" href="#setting-cleanup-interval">Setting <code>cleanup-interval</code></a></h2>
<ul>
<li><strong>type</strong>: string (duration)</li>
<li><strong>format</strong>: <code>"{integer}(s | m | h | d)"</code></li>
<li><strong>default</strong>: <code>"1h"</code></li>
</ul>
<p>When the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> is notified about a cache file being updated by the <a href="cli-cache.html#how-does-the-cache-work">cache system</a>
and this interval has already passed since last cleaning up,
the worker will attempt a new cleanup.</p>
<p>Please also refer to <a href="cli-cache.html#setting-allowed-clock-drift-for-files-from-future"><code>allowed-clock-drift-for-files-from-future</code></a>.</p>
<h2 id="setting-optimizing-compression-task-timeout"><a class="header" href="#setting-optimizing-compression-task-timeout">Setting <code>optimizing-compression-task-timeout</code></a></h2>
<ul>
<li><strong>type</strong>: string (duration)</li>
<li><strong>format</strong>: <code>"{integer}(s | m | h | d)"</code></li>
<li><strong>default</strong>: <code>"30m"</code></li>
</ul>
<p>When the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> decides to recompress a cache file, it makes sure that
no other worker has started the task for this file within the last
<a href="cli-cache.html#setting-optimizing-compression-task-timeout"><code>optimizing-compression-task-timeout</code></a> interval.
If some worker has started working on it, other workers are skipping this task.</p>
<p>Please also refer to the <a href="cli-cache.html#setting-allowed-clock-drift-for-files-from-future"><code>allowed-clock-drift-for-files-from-future</code></a> section.</p>
<h2 id="setting-allowed-clock-drift-for-files-from-future"><a class="header" href="#setting-allowed-clock-drift-for-files-from-future">Setting <code>allowed-clock-drift-for-files-from-future</code></a></h2>
<ul>
<li><strong>type</strong>: string (duration)</li>
<li><strong>format</strong>: <code>"{integer}(s | m | h | d)"</code></li>
<li><strong>default</strong>: <code>"1d"</code></li>
</ul>
<h3 id="locks"><a class="header" href="#locks">Locks</a></h3>
<p>When the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> attempts acquiring a lock for some task,
it checks if some other worker has already acquired such a lock.
To be fault tolerant and eventually execute every task,
the locks expire after some interval.
However, because of clock drifts and different timezones,
it would happen that some lock was created in the future.
This setting defines a tolerance limit for these locks.
If the time has been changed in the system (i.e. two years backwards),
the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> should still work properly.
Thus, these locks will be treated as expired
(assuming the tolerance is not too big).</p>
<h3 id="cache-files"><a class="header" href="#cache-files">Cache files</a></h3>
<p>Similarly to the locks, the cache files or their metadata might
have modification time in distant future.
The cache system tries to keep these files as long as possible.
If the limits are not reached, the cache files will not be deleted.
Otherwise, they will be treated as the oldest files, so they might survive.
If the user actually uses the cache file, the modification time will be updated.</p>
<h2 id="setting-file-count-soft-limit"><a class="header" href="#setting-file-count-soft-limit">Setting <code>file-count-soft-limit</code></a></h2>
<ul>
<li><strong>type</strong>: string (SI prefix)</li>
<li><strong>format</strong>: <code>"{integer}(K | M | G | T | P)?"</code></li>
<li><strong>default</strong>: <code>"65536"</code></li>
</ul>
<p>Soft limit for the file count in the cache directory.</p>
<p>This doesn't include files with metadata.
To learn more, please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section.</p>
<h2 id="setting-files-total-size-soft-limit"><a class="header" href="#setting-files-total-size-soft-limit">Setting <code>files-total-size-soft-limit</code></a></h2>
<ul>
<li><strong>type</strong>: string (disk space)</li>
<li><strong>format</strong>: <code>"{integer}(K | Ki | M | Mi | G | Gi | T | Ti | P | Pi)?"</code></li>
<li><strong>default</strong>: <code>"512Mi"</code></li>
</ul>
<p>Soft limit for the total size* of files in the cache directory.</p>
<p>This doesn't include files with metadata.
To learn more, please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section.</p>
<p>*this is the file size, not the space physically occupied on the disk.</p>
<h2 id="setting-file-count-limit-percent-if-deleting"><a class="header" href="#setting-file-count-limit-percent-if-deleting">Setting <code>file-count-limit-percent-if-deleting</code></a></h2>
<ul>
<li><strong>type</strong>: string (percent)</li>
<li><strong>format</strong>: <code>"{integer}%"</code></li>
<li><strong>default</strong>: <code>"70%"</code></li>
</ul>
<p>If <a href="cli-cache.html#setting-file-count-soft-limit"><code>file-count-soft-limit</code></a> is exceeded and the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> performs the cleanup task,
then the worker will delete some cache files, so after the task,
the file count should not exceed
<a href="cli-cache.html#setting-file-count-soft-limit"><code>file-count-soft-limit</code></a> * <a href="cli-cache.html#setting-file-count-limit-percent-if-deleting"><code>file-count-limit-percent-if-deleting</code></a>.</p>
<p>This doesn't include files with metadata.
To learn more, please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section.</p>
<h2 id="setting-files-total-size-limit-percent-if-deleting"><a class="header" href="#setting-files-total-size-limit-percent-if-deleting">Setting <code>files-total-size-limit-percent-if-deleting</code></a></h2>
<ul>
<li><strong>type</strong>: string (percent)</li>
<li><strong>format</strong>: <code>"{integer}%"</code></li>
<li><strong>default</strong>: <code>"70%"</code></li>
</ul>
<p>If <a href="cli-cache.html#setting-files-total-size-soft-limit"><code>files-total-size-soft-limit</code></a> is exceeded and <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> performs the cleanup task,
then the worker will delete some cache files, so after the task,
the files total size should not exceed
<a href="cli-cache.html#setting-files-total-size-soft-limit"><code>files-total-size-soft-limit</code></a> * <a href="cli-cache.html#setting-files-total-size-limit-percent-if-deleting"><code>files-total-size-limit-percent-if-deleting</code></a>.</p>
<p>This doesn't include files with metadata.
To learn more, please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section.</p>
<h1 id="how-does-the-cache-work"><a class="header" href="#how-does-the-cache-work">How does the cache work?</a></h1>
<p><strong>This is an implementation detail and might change in the future.</strong>
Information provided here is meant to help understanding the big picture
and configuring the cache.</p>
<p>There are two main components - the <em>cache system</em> and the <em>cache worker</em>.</p>
<h2 id="cache-system"><a class="header" href="#cache-system">Cache system</a></h2>
<p>Handles GET and UPDATE cache requests.</p>
<ul>
<li><strong>GET request</strong> - simply loads the cache from disk if it is there.</li>
<li><strong>UPDATE request</strong> - compresses received data with <a href="https://facebook.github.io/zstd/">zstd</a> and <a href="cli-cache.html#setting-baseline-compression-level"><code>baseline-compression-level</code></a>, then writes the data to the disk.</li>
</ul>
<p>In case of successful handling of a request, it notifies the <em>cache worker</em> about this
event using the queue.
The queue has a limited size of <a href="cli-cache.html#setting-worker-event-queue-size"><code>worker-event-queue-size</code></a>. If it is full, it will drop
new events until the <em>cache worker</em> pops some event from the queue.</p>
<h2 id="cache-worker"><a class="header" href="#cache-worker">Cache worker</a></h2>
<p>The cache worker runs in a single thread with lower priority and pops events from the queue
in a loop handling them one by one.</p>
<h3 id="on-get-request"><a class="header" href="#on-get-request">On GET request</a></h3>
<ol>
<li>
<p>Read the statistics file for the cache file,
increase the usage counter and write it back to the disk.</p>
</li>
<li>
<p>Attempt recompressing the cache file if all of the following conditions are met:</p>
<ul>
<li>usage counter exceeds <a href="cli-cache.html#setting-optimized-compression-usage-counter-threshold"><code>optimized-compression-usage-counter-threshold</code></a>,</li>
<li>the file is compressed with compression level lower than <a href="cli-cache.html#setting-optimized-compression-level"><code>optimized-compression-level</code></a>,</li>
<li>no other worker has started working on this particular task within the last
<a href="cli-cache.html#setting-optimizing-compression-task-timeout"><code>optimizing-compression-task-timeout</code></a> interval.</li>
</ul>
<p>When recompressing, <a href="cli-cache.html#setting-optimized-compression-level"><code>optimized-compression-level</code></a> is used as a compression level.</p>
</li>
</ol>
<h3 id="on-update-request"><a class="header" href="#on-update-request">On UPDATE request</a></h3>
<ol>
<li>Write a fresh statistics file for the cache file.</li>
<li>Clean up the cache if no worker has attempted to do this within the last <a href="cli-cache.html#setting-cleanup-interval"><code>cleanup-interval</code></a>.
During this task:
<ul>
<li>all unrecognized files and expired task locks in cache directory will be deleted</li>
<li>if <a href="cli-cache.html#setting-file-count-soft-limit"><code>file-count-soft-limit</code></a> or <a href="cli-cache.html#setting-files-total-size-soft-limit"><code>files-total-size-soft-limit</code></a> is exceeded,
then recognized files will be deleted according to
<a href="cli-cache.html#setting-file-count-limit-percent-if-deleting"><code>file-count-limit-percent-if-deleting</code></a> and <a href="cli-cache.html#setting-files-total-size-limit-percent-if-deleting"><code>files-total-size-limit-percent-if-deleting</code></a>.
Wasmtime uses <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">Least Recently Used (LRU)</a> cache replacement policy and requires that
the filesystem maintains proper mtime (modification time) of the files.
Files with future mtimes are treated specially - more details
in <a href="cli-cache.html#setting-allowed-clock-drift-for-files-from-future"><code>allowed-clock-drift-for-files-from-future</code></a>.</li>
</ul>
</li>
</ol>
<h3 id="metadata-files"><a class="header" href="#metadata-files">Metadata files</a></h3>
<ul>
<li>every cached WebAssembly module has its own statistics file</li>
<li>every lock is a file</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-wasmtime-api"><a class="header" href="#using-the-wasmtime-api">Using the Wasmtime API</a></h1>
<p>Wasmtime can be used as a library to embed WebAssembly execution support
within applications. Wasmtime is written in Rust, but bindings are available
through a C API for a number of other languages too:</p>
<ul>
<li><a href="lang-rust.html">Rust</a></li>
<li><a href="lang-c.html">C</a></li>
<li><a href="lang-python.html">Python</a></li>
<li><a href="lang-dotnet.html">.NET</a></li>
<li><a href="lang-go.html">Go</a></li>
<li><a href="lang-bash.html">Bash</a></li>
<li><a href="lang-ruby.html">Ruby</a></li>
<li><a href="lang-elixir.html">Elixir</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-webassembly-from-rust"><a class="header" href="#using-webassembly-from-rust">Using WebAssembly from Rust</a></h1>
<p>This document shows an example of how to embed Wasmtime using the <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/">Rust
API</a> to execute a simple wasm program. Be sure to also check out the
<a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/">full API documentation</a> for a full listing of what the <a href="https://crates.io/crates/wasmtime"><code>wasmtime</code>
crate</a> has to offer.</p>
<h2 id="creating-the-webassembly-to-execute"><a class="header" href="#creating-the-webassembly-to-execute">Creating the WebAssembly to execute</a></h2>
<p>We'll just assume that you've already got a wasm file on hand for the rest of
this tutorial. To make things simple we'll also just assume you've got a
<code>hello.wat</code> file which looks like this:</p>
<pre><code class="language-wat">(module
  (func (export "answer") (result i32)
     i32.const 42
  )
)
</code></pre>
<p>Here we're just exporting one function which returns an integer that we'll read
from Rust.</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>First up let's create a rust project</p>
<pre><code class="language-sh">$ cargo new --bin wasmtime_hello
$ cd wasmtime_hello
</code></pre>
<p>Next you'll want to add <code>hello.wat</code> to the root of your project.</p>
<p>We will be using the <code>wasmtime</code> crate to run the wasm file. Please execute the command <code>cargo add wasmtime</code> to use the latest version of the crate. The <code>dependencies</code> block in the <code>Cargo.toml</code> file will appear as follows:</p>
<pre><code class="language-toml">[dependencies]
wasmtime = "19.0.0"
</code></pre>
<p>Next up let's write the code that we need to execute this wasm file. The
simplest version of this looks like so:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate wasmtime;
</span>use std::error::Error;
use wasmtime::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // An engine stores and configures global compilation settings like
    // optimization level, enabled wasm features, etc.
    let engine = Engine::default();

<span class="boring">if false {
</span>    // We start off by creating a `Module` which represents a compiled form
    // of our input wasm module. In this case it'll be JIT-compiled after
    // we parse the text format.
    let module = Module::from_file(&amp;engine, "hello.wat")?;
<span class="boring">}
</span><span class="boring">let module = Module::new(&amp;engine, r#"(module (func (export "answer") (result i32) i32.const 42))"#)?;
</span>
    // A `Store` is what will own instances, functions, globals, etc. All wasm
    // items are stored within a `Store`, and it's what we'll always be using to
    // interact with the wasm world. Custom data can be stored in stores but for
    // now we just use `()`.
    let mut store = Store::new(&amp;engine, ());

    // With a compiled `Module` we can then instantiate it, creating
    // an `Instance` which we can actually poke at functions on.
    let instance = Instance::new(&amp;mut store, &amp;module, &amp;[])?;

    // The `Instance` gives us access to various exported functions and items,
    // which we access here to pull out our `answer` exported function and
    // run it.
    let answer = instance.get_func(&amp;mut store, "answer")
        .expect("`answer` was not an exported function");

    // There's a few ways we can call the `answer` `Func` value. The easiest
    // is to statically assert its signature with `typed` (in this case
    // asserting it takes no arguments and returns one i32) and then call it.
    let answer = answer.typed::&lt;(), i32&gt;(&amp;store)?;

    // And finally we can call our function! Note that the error propagation
    // with `?` is done to handle the case where the wasm function traps.
    let result = answer.call(&amp;mut store, ())?;
    println!("Answer: {:?}", result);
    Ok(())
}</code></pre></pre>
<p>We can build and execute our example with <code>cargo run</code>. Note that by depending on
<code>wasmtime</code> you're depending on a JIT compiler, so it may take a moment to build
all of its dependencies:</p>
<pre><code class="language-sh">$ cargo run
  Compiling ...
  ...
   Finished dev [unoptimized + debuginfo] target(s) in 42.32s
    Running `wasmtime_hello/target/debug/wasmtime_hello`
Answer: 42
</code></pre>
<p>and there we go! We've now executed our first WebAssembly in <code>wasmtime</code> and
gotten the result back.</p>
<h2 id="importing-host-functionality"><a class="header" href="#importing-host-functionality">Importing Host Functionality</a></h2>
<p>What we've just seen is a pretty small example of how to call a wasm function
and take a look at the result. Most interesting wasm modules, however, are going
to import some functions to do something a bit more interesting. For that you'll
need to provide imported functions from Rust for wasm to call!</p>
<p>Let's take a look at a wasm module which imports a logging function as well as
some simple arithmetic from the environment.</p>
<pre><code class="language-wat">(module
  (import "" "log" (func $log (param i32)))
  (import "" "double" (func $double (param i32) (result i32)))
  (func (export "run")
    i32.const 0
    call $log
    i32.const 1
    call $log
    i32.const 2
    call $double
    call $log
  )
)
</code></pre>
<p>This wasm module will call our <code>"log"</code> import a few times and then also call the
<code>"double"</code> import. We can compile and instantiate this module with code that
looks like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">extern crate wasmtime;
</span>use std::error::Error;
use wasmtime::*;

struct Log {
    integers_logged: Vec&lt;u32&gt;,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let engine = Engine::default();
<span class="boring">if false {
</span>    let module = Module::from_file(&amp;engine, "hello.wat")?;
<span class="boring">}
</span><span class="boring">let module = Module::new(&amp;engine, r#"(module (import "" "log" (func $log (param i32))) (import "" "double" (func $double (param i32) (result i32))) (func (export "run") i32.const 0 call $log i32.const 1 call $log i32.const 2 call $double call $log))"#)?;
</span>
    // For host-provided functions it's recommended to use a `Linker` which does
    // name-based resolution of functions.
    let mut linker = Linker::new(&amp;engine);

    // First we create our simple "double" function which will only multiply its
    // input by two and return it.
    linker.func_wrap("", "double", |param: i32| param * 2)?;

    // Next we define a `log` function. Note that we're using a
    // Wasmtime-provided `Caller` argument to access the state on the `Store`,
    // which allows us to record the logged information.
    linker.func_wrap("", "log", |mut caller: Caller&lt;'_, Log&gt;, param: u32| {
        println!("log: {}", param);
        caller.data_mut().integers_logged.push(param);
    })?;

    // As above, instantiation always happens within a `Store`. This means to
    // actually instantiate with our `Linker` we'll need to create a store. Note
    // that we're also initializing the store with our custom data here too.
    //
    // Afterwards we use the `linker` to create the instance.
    let data = Log { integers_logged: Vec::new() };
    let mut store = Store::new(&amp;engine, data);
    let instance = linker.instantiate(&amp;mut store, &amp;module)?;

    // Like before, we can get the run function and execute it.
    let run = instance.get_typed_func::&lt;(), ()&gt;(&amp;mut store, "run")?;
    run.call(&amp;mut store, ())?;

    // We can also inspect what integers were logged:
    println!("logged integers: {:?}", store.data().integers_logged);

    Ok(())
}</code></pre></pre>
<p>Note that there's a number of ways to define a <code>Func</code>, be sure to <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Func.html">consult its
documentation</a> for other ways to create a host-defined function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-1"><a class="header" href="#hello-world-1">Hello, world!</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/hello.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to instantiate a simple wasm module and interact with
it. For more information about the types used here be sure to review the <a href="https://docs.rs/wasmtime/*/wasmtime/#core-concepts">core
concepts of the <code>wasmtime</code>
API</a> as well as the general
<a href="https://docs.rs/wasmtime">API documentation</a>.</p>
<h2 id="hellowat"><a class="header" href="#hellowat"><code>hello.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $hello (import "" "hello"))
  (func (export "run") (call $hello))
)
</code></pre>
<h2 id="hellors"><a class="header" href="#hellors"><code>hello.rs</code></a></h2>
<pre><code class="language-rust ignore">//! Small example of how to instantiate a wasm module that imports one function,
//! showing how you can fill in host functionality for a wasm module.

// You can execute this example with `cargo run --example hello`

use wasmtime::*;

struct MyState {
    name: String,
    count: usize,
}

fn main() -&gt; Result&lt;()&gt; {
    // First the wasm module needs to be compiled. This is done with a global
    // "compilation environment" within an `Engine`. Note that engines can be
    // further configured through `Config` if desired instead of using the
    // default like this is here.
    println!("Compiling module...");
    let engine = Engine::default();
    let module = Module::from_file(&amp;engine, "examples/hello.wat")?;

    // After a module is compiled we create a `Store` which will contain
    // instantiated modules and other items like host functions. A Store
    // contains an arbitrary piece of host information, and we use `MyState`
    // here.
    println!("Initializing...");
    let mut store = Store::new(
        &amp;engine,
        MyState {
            name: "hello, world!".to_string(),
            count: 0,
        },
    );

    // Our wasm module we'll be instantiating requires one imported function.
    // the function takes no parameters and returns no results. We create a host
    // implementation of that function here, and the `caller` parameter here is
    // used to get access to our original `MyState` value.
    println!("Creating callback...");
    let hello_func = Func::wrap(&amp;mut store, |mut caller: Caller&lt;'_, MyState&gt;| {
        println!("Calling back...");
        println!("&gt; {}", caller.data().name);
        caller.data_mut().count += 1;
    });

    // Once we've got that all set up we can then move to the instantiation
    // phase, pairing together a compiled module as well as a set of imports.
    // Note that this is where the wasm `start` function, if any, would run.
    println!("Instantiating module...");
    let imports = [hello_func.into()];
    let instance = Instance::new(&amp;mut store, &amp;module, &amp;imports)?;

    // Next we poke around a bit to extract the `run` function from the module.
    println!("Extracting export...");
    let run = instance.get_typed_func::&lt;(), ()&gt;(&amp;mut store, "run")?;

    // And last but not least we can call it!
    println!("Calling export...");
    run.call(&amp;mut store, ())?;

    println!("Done.");
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calculating-the-gcd"><a class="header" href="#calculating-the-gcd">Calculating the GCD</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/gcd.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how run a wasm program which calculates the GCD of two
numbers.</p>
<h2 id="gcdwat"><a class="header" href="#gcdwat"><code>gcd.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export "gcd" (func $gcd))
)

</code></pre>
<h2 id="gcdrs"><a class="header" href="#gcdrs"><code>gcd.rs</code></a></h2>
<pre><code class="language-rust ignore">//! Example of instantiating of the WebAssembly module and invoking its exported
//! function.

// You can execute this example with `cargo run --example gcd`

use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    // Load our WebAssembly (parsed WAT in our case), and then load it into a
    // `Module` which is attached to a `Store` cache. After we've got that we
    // can instantiate it.
    let mut store = Store::&lt;()&gt;::default();
    let module = Module::from_file(store.engine(), "examples/gcd.wat")?;
    let instance = Instance::new(&amp;mut store, &amp;module, &amp;[])?;

    // Invoke `gcd` export
    let gcd = instance.get_typed_func::&lt;(i32, i32), i32&gt;(&amp;mut store, "gcd")?;

    println!("gcd(6, 27) = {}", gcd.call(&amp;mut store, (6, 27))?);
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-linear-memory"><a class="header" href="#using-linear-memory">Using linear memory</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/memory.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to interact with wasm memory in a module. Be sure to
read the documentation for <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Memory.html"><code>Memory</code></a> as well.</p>
<h2 id="memorywat"><a class="header" href="#memorywat"><code>memory.wat</code></a></h2>
<pre><code class="language-wat">(module
  (memory (export "memory") 2 3)

  (func (export "size") (result i32) (memory.size))
  (func (export "load") (param i32) (result i32)
    (i32.load8_s (local.get 0))
  )
  (func (export "store") (param i32 i32)
    (i32.store8 (local.get 0) (local.get 1))
  )

  (data (i32.const 0x1000) "\01\02\03\04")
)
</code></pre>
<h2 id="memoryrs"><a class="header" href="#memoryrs"><code>memory.rs</code></a></h2>
<pre><code class="language-rust ignore">//! An example of how to interact with wasm memory.
//!
//! Here a small wasm module is used to show how memory is initialized, how to
//! read and write memory through the `Memory` object, and how wasm functions
//! can trap when dealing with out-of-bounds addresses.

// You can execute this example with `cargo run --example memory`

use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    // Create our `store_fn` context and then compile a module and create an
    // instance from the compiled module all in one go.
    let mut store: Store&lt;()&gt; = Store::default();
    let module = Module::from_file(store.engine(), "examples/memory.wat")?;
    let instance = Instance::new(&amp;mut store, &amp;module, &amp;[])?;

    // load_fn up our exports from the instance
    let memory = instance
        .get_memory(&amp;mut store, "memory")
        .ok_or(anyhow::format_err!("failed to find `memory` export"))?;
    let size = instance.get_typed_func::&lt;(), i32&gt;(&amp;mut store, "size")?;
    let load_fn = instance.get_typed_func::&lt;i32, i32&gt;(&amp;mut store, "load")?;
    let store_fn = instance.get_typed_func::&lt;(i32, i32), ()&gt;(&amp;mut store, "store")?;

    println!("Checking memory...");
    assert_eq!(memory.size(&amp;store), 2);
    assert_eq!(memory.data_size(&amp;store), 0x20000);
    assert_eq!(memory.data_mut(&amp;mut store)[0], 0);
    assert_eq!(memory.data_mut(&amp;mut store)[0x1000], 1);
    assert_eq!(memory.data_mut(&amp;mut store)[0x1003], 4);

    assert_eq!(size.call(&amp;mut store, ())?, 2);
    assert_eq!(load_fn.call(&amp;mut store, 0)?, 0);
    assert_eq!(load_fn.call(&amp;mut store, 0x1000)?, 1);
    assert_eq!(load_fn.call(&amp;mut store, 0x1003)?, 4);
    assert_eq!(load_fn.call(&amp;mut store, 0x1ffff)?, 0);
    assert!(load_fn.call(&amp;mut store, 0x20000).is_err()); // out of bounds trap

    println!("Mutating memory...");
    memory.data_mut(&amp;mut store)[0x1003] = 5;

    store_fn.call(&amp;mut store, (0x1002, 6))?;
    assert!(store_fn.call(&amp;mut store, (0x20000, 0)).is_err()); // out of bounds trap

    assert_eq!(memory.data(&amp;store)[0x1002], 6);
    assert_eq!(memory.data(&amp;store)[0x1003], 5);
    assert_eq!(load_fn.call(&amp;mut store, 0x1002)?, 6);
    assert_eq!(load_fn.call(&amp;mut store, 0x1003)?, 5);

    // Grow memory.
    println!("Growing memory...");
    memory.grow(&amp;mut store, 1)?;
    assert_eq!(memory.size(&amp;store), 3);
    assert_eq!(memory.data_size(&amp;store), 0x30000);

    assert_eq!(load_fn.call(&amp;mut store, 0x20000)?, 0);
    store_fn.call(&amp;mut store, (0x20000, 0))?;
    assert!(load_fn.call(&amp;mut store, 0x30000).is_err());
    assert!(store_fn.call(&amp;mut store, (0x30000, 0)).is_err());

    assert!(memory.grow(&amp;mut store, 1).is_err());
    assert!(memory.grow(&amp;mut store, 0).is_ok());

    println!("Creating stand-alone memory...");
    let memorytype = MemoryType::new(5, Some(5));
    let memory2 = Memory::new(&amp;mut store, memorytype)?;
    assert_eq!(memory2.size(&amp;store), 5);
    assert!(memory2.grow(&amp;mut store, 1).is_err());
    assert!(memory2.grow(&amp;mut store, 0).is_ok());

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasi"><a class="header" href="#wasi">WASI</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/wasi/main.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows how to use the <a href="https://crates.io/crates/wasi-common"><code>wasi-common</code></a> crate to define WASI
functions within a <a href="https://docs.rs/wasmtime/*/wasmtime/struct.Linker.html"><code>Linker</code></a> which can then be used to instantiate a
WebAssembly module.</p>
<h3 id="webassembly-module-source-code"><a class="header" href="#webassembly-module-source-code">WebAssembly module source code</a></h3>
<p>For this WASI example, this Hello World program is compiled to a WebAssembly module using the WASI Preview 1 API.</p>
<p><code>wasi.rs</code></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Building this program generates <code>target/wasm32-wasi/debug/wasi.wasm</code>, used below.</p>
<h3 id="invoke-the-wasm-module"><a class="header" href="#invoke-the-wasm-module">Invoke the WASM module</a></h3>
<p>This example shows adding and configuring the WASI imports to invoke the above WASM module.</p>
<p><code>main.rs</code></p>
<pre><code class="language-rust ignore">//! Example of instantiating a wasm module which uses WASI imports.

/*
You can execute this example with:
    cmake examples/
    cargo run --example wasi
*/

use wasi_common::sync::WasiCtxBuilder;
use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    // Define the WASI functions globally on the `Config`.
    let engine = Engine::default();
    let mut linker = Linker::new(&amp;engine);
    wasi_common::sync::add_to_linker(&amp;mut linker, |s| s)?;

    // Create a WASI context and put it in a Store; all instances in the store
    // share this context. `WasiCtxBuilder` provides a number of ways to
    // configure what the target program will have access to.
    let wasi = WasiCtxBuilder::new()
        .inherit_stdio()
        .inherit_args()?
        .build();
    let mut store = Store::new(&amp;engine, wasi);

    // Instantiate our module with the imports we've created, and run it.
    let module = Module::from_file(&amp;engine, "target/wasm32-wasi/debug/wasi.wasm")?;
    linker.module(&amp;mut store, "", &amp;module)?;
    linker
        .get_default(&amp;mut store, "")?
        .typed::&lt;(), ()&gt;(&amp;store)?
        .call(&amp;mut store, ())?;

    Ok(())
}</code></pre>
<h2 id="wasi-state-with-other-custom-host-state"><a class="header" href="#wasi-state-with-other-custom-host-state">WASI state with other custom host state</a></h2>
<p>The <a href="https://docs.rs/wasi-common/*/wasi_common/sync/fn.add_to_linker.html"><code>add_to_linker</code></a> takes a second argument which is a closure to access <code>&amp;mut WasiCtx</code> from within the <code>T</code> stored in the <code>Store&lt;T&gt;</code> itself. In the above
example this is trivial because the <code>T</code> in <code>Store&lt;T&gt;</code> is <code>WasiCtx</code> itself, but
you can also store other state in <code>Store</code> like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">extern crate wasmtime;
</span><span class="boring">extern crate wasi_common;
</span><span class="boring">extern crate anyhow;
</span>use anyhow::Result;
use std::borrow::{Borrow, BorrowMut};
use wasmtime::*;
use wasi_common::{WasiCtx, sync::WasiCtxBuilder};

struct MyState {
    message: String,
    wasi: WasiCtx,
}

fn main() -&gt; Result&lt;()&gt; {
    let engine = Engine::default();
    let mut linker = Linker::new(&amp;engine);
    wasi_common::sync::add_to_linker(&amp;mut linker, |state: &amp;mut MyState| &amp;mut state.wasi)?;

    let wasi = WasiCtxBuilder::new()
        .inherit_stdio()
        .inherit_args()?
        .build();
    let mut store = Store::new(&amp;engine, MyState {
        message: format!("hello!"),
        wasi,
    });

    // ...

<span class="boring">let _linker: Linker&lt;MyState&gt; = linker;
</span>    Ok(())
}</code></pre></pre>
<h2 id="wasi-preview-2"><a class="header" href="#wasi-preview-2">WASI Preview 2</a></h2>
<p>An experimental implementation of the WASI Preview 2 API is also available, along with an adapter layer for  WASI Preview 1 WebAssembly modules. In future this <code>preview2</code> API will become the default. There are some features which are currently only accessible through the <code>preview2</code> API such as async support and overriding the clock and random implementations.</p>
<h3 id="async-example"><a class="header" href="#async-example">Async example</a></h3>
<p>This <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/wasi-async/main.rs">async example code</a> shows how to use the <a href="https://docs.rs/wasmtime-wasi/*/wasmtime_wasi/preview2/index.html">wasmtime-wasi::preview2</a> module to
execute the same WASI Preview 1 WebAssembly module from the example above. This example requires the <code>wasmtime</code> crate <code>async</code> feature to be enabled.</p>
<p>This does not require any change to the WebAssembly module, it's just the WASI API host functions which are implemented to be async. See <a href="https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.async_support">wasmtime async support</a>.</p>
<pre><code class="language-rust ignore">//! Example of instantiating a wasm module which uses WASI preview1 imports
//! implemented through the async preview2 WASI implementation.

/*
You can execute this example with:
    cmake examples/
    cargo run --example wasi-async
*/

use anyhow::Result;
use wasmtime::{Config, Engine, Linker, Module, Store};
use wasmtime_wasi::preview1::{self, WasiP1Ctx};
use wasmtime_wasi::WasiCtxBuilder;

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    // Construct the wasm engine with async support enabled.
    let mut config = Config::new();
    config.async_support(true);
    let engine = Engine::new(&amp;config)?;

    // Add the WASI preview1 API to the linker (will be implemented in terms of
    // the preview2 API)
    let mut linker: Linker&lt;WasiP1Ctx&gt; = Linker::new(&amp;engine);
    preview1::add_to_linker_async(&amp;mut linker, |t| t)?;

    // Add capabilities (e.g. filesystem access) to the WASI preview2 context
    // here. Here only stdio is inherited, but see docs of `WasiCtxBuilder` for
    // more.
    let wasi_ctx = WasiCtxBuilder::new().inherit_stdio().build_p1();

    let mut store = Store::new(&amp;engine, wasi_ctx);

    // Instantiate our 'Hello World' wasm module.
    // Note: This is a module built against the preview1 WASI API.
    let module = Module::from_file(&amp;engine, "target/wasm32-wasi/debug/wasi.wasm")?;
    let func = linker
        .module_async(&amp;mut store, "", &amp;module)
        .await?
        .get_default(&amp;mut store, "")?
        .typed::&lt;(), ()&gt;(&amp;store)?;

    // Invoke the WASI program default function.
    func.call_async(&amp;mut store, ()).await?;

    Ok(())
}</code></pre>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/wasi-async/main.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linking-modules"><a class="header" href="#linking-modules">Linking modules</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/linking.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to compile and instantiate modules which link
together. Be sure to read the API documentation for <a href="https://docs.rs/wasmtime/0.26.0/wasmtime/struct.Linker.html"><code>Linker</code></a> as well.</p>
<h2 id="linking1wat"><a class="header" href="#linking1wat"><code>linking1.wat</code></a></h2>
<pre><code class="language-wat">(module
  (import "linking2" "double" (func $double (param i32) (result i32)))
  (import "linking2" "log" (func $log (param i32 i32)))
  (import "linking2" "memory" (memory 1))
  (import "linking2" "memory_offset" (global $offset i32))

  (func (export "run")
    ;; Call into the other module to double our number, and we could print it
    ;; here but for now we just drop it
    i32.const 2
    call $double
    drop

    ;; Our `data` segment initialized our imported memory, so let's print the
    ;; string there now.
    global.get $offset
    i32.const 14
    call $log
  )

  (data (global.get $offset) "Hello, world!\n")
)

</code></pre>
<h2 id="linking2wat"><a class="header" href="#linking2wat"><code>linking2.wat</code></a></h2>
<pre><code class="language-wat">(module
  (type $fd_write_ty (func (param i32 i32 i32 i32) (result i32)))
  (import "wasi_snapshot_preview1" "fd_write" (func $fd_write (type $fd_write_ty)))

  (func (export "double") (param i32) (result i32)
    local.get 0
    i32.const 2
    i32.mul
  )

  (func (export "log") (param i32 i32)
    ;; store the pointer in the first iovec field
    i32.const 4
    local.get 0
    i32.store

    ;; store the length in the first iovec field
    i32.const 4
    local.get 1
    i32.store offset=4

    ;; call the `fd_write` import
    i32.const 1     ;; stdout fd
    i32.const 4     ;; iovs start
    i32.const 1     ;; number of iovs
    i32.const 0     ;; where to write nwritten bytes
    call $fd_write
    drop
  )

  (memory (export "memory") 2)
  (global (export "memory_offset") i32 (i32.const 65536))
)
</code></pre>
<h2 id="linkingrs"><a class="header" href="#linkingrs"><code>linking.rs</code></a></h2>
<pre><code class="language-rust ignore">//! Example of instantiating two modules which link to each other.

// You can execute this example with `cargo run --example linking`

use wasi_common::sync::WasiCtxBuilder;
use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    let engine = Engine::default();

    // First set up our linker which is going to be linking modules together. We
    // want our linker to have wasi available, so we set that up here as well.
    let mut linker = Linker::new(&amp;engine);
    wasi_common::sync::add_to_linker(&amp;mut linker, |s| s)?;

    // Load and compile our two modules
    let linking1 = Module::from_file(&amp;engine, "examples/linking1.wat")?;
    let linking2 = Module::from_file(&amp;engine, "examples/linking2.wat")?;

    // Configure WASI and insert it into a `Store`
    let wasi = WasiCtxBuilder::new()
        .inherit_stdio()
        .inherit_args()?
        .build();
    let mut store = Store::new(&amp;engine, wasi);

    // Instantiate our first module which only uses WASI, then register that
    // instance with the linker since the next linking will use it.
    let linking2 = linker.instantiate(&amp;mut store, &amp;linking2)?;
    linker.instance(&amp;mut store, "linking2", linking2)?;

    // And with that we can perform the final link and the execute the module.
    let linking1 = linker.instantiate(&amp;mut store, &amp;linking1)?;
    let run = linking1.get_typed_func::&lt;(), ()&gt;(&amp;mut store, "run")?;
    run.call(&amp;mut store, ())?;
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/fib-debug/main.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to set up a module for dynamic runtime debugging via
a native debugger like GDB or LLDB.</p>
<h2 id="mainrs"><a class="header" href="#mainrs"><code>main.rs</code></a></h2>
<pre><code class="language-rust ignore">//! Example of enabling debuginfo for wasm code which allows interactive
//! debugging of the wasm code. When using recent versions of LLDB
//! you can debug this executable and set breakpoints in wasm code and look at
//! the rust source code as input.

// To execute this example you'll need to run two commands:
//
//      cargo build -p example-fib-debug-wasm --target wasm32-unknown-unknown
//      cargo run --example fib-debug

use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    // Load our previously compiled wasm file (built previously with Cargo) and
    // also ensure that we generate debuginfo so this executable can be
    // debugged in GDB.
    let engine = Engine::new(Config::new().debug_info(true))?;
    let mut store = Store::new(&amp;engine, ());
    let module = Module::from_file(&amp;engine, "target/wasm32-unknown-unknown/debug/fib.wasm")?;
    let instance = Instance::new(&amp;mut store, &amp;module, &amp;[])?;

    // Invoke `fib` export
    let fib = instance.get_typed_func::&lt;i32, i32&gt;(&amp;mut store, "fib")?;
    println!("fib(6) = {}", fib.call(&amp;mut store, 6)?);
    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-dumps"><a class="header" href="#core-dumps">Core Dumps</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/fib-debug/main.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This examples shows how to configure capturing <a href="https://github.com/WebAssembly/tool-conventions/blob/main/Coredump.md">core dumps</a> when a Wasm guest
traps that can then be passed to external tools (like <a href="https://github.com/xtuc/wasm-coredump/blob/main/bin/wasmgdb/README.md"><code>wasmgdb</code></a>) for
post-mortem analysis.</p>
<h2 id="mainrs-1"><a class="header" href="#mainrs-1"><code>main.rs</code></a></h2>
<pre><code class="language-rust ignore">//! An example of how to configure capturing core dumps when the guest Wasm
//! traps that can then be passed to external tools for post-mortem analysis.

// You can execute this example with `cargo run --example coredump`.

use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    println!("Configure core dumps to be captured on trap.");
    let mut config = Config::new();
    config.coredump_on_trap(true);
    let engine = Engine::new(&amp;config)?;
    let mut store = Store::new(&amp;engine, ());

    println!("Define a Wasm module that will mutate local state and then trap.");
    let module = Module::new(
        store.engine(),
        r#"
            (module $trapper
                (memory 10)
                (global $g (mut i32) (i32.const 0))

                (func (export "run")
                    call $a
                )

                (func $a
                    i32.const 0x1234
                    i64.const 42
                    i64.store
                    call $b
                )

                (func $b
                    i32.const 36
                    global.set $g
                    call $c
                )

                (func $c
                    unreachable
                )
            )
        "#,
    )?;

    println!("Instantiate the module.");
    let instance = Instance::new(&amp;mut store, &amp;module, &amp;[])?;

    println!("Invoke its 'run' function.");
    let run = instance
        .get_func(&amp;mut store, "run")
        .expect("should have 'run' export");
    let args = &amp;[];
    let results = &amp;mut [];
    let ok = run.call(&amp;mut store, args, results);

    println!("Calling that function trapped.");
    assert!(ok.is_err());
    let err = ok.unwrap_err();
    assert!(err.is::&lt;Trap&gt;());

    println!("Extract the captured core dump.");
    let dump = err
        .downcast_ref::&lt;WasmCoreDump&gt;()
        .expect("should have an attached core dump, since we configured core dumps on");

    println!(
        "Number of memories in the core dump: {}",
        dump.memories().len()
    );
    for (i, mem) in dump.memories().iter().enumerate() {
        if let Some(addr) = mem.data(&amp;store).iter().position(|byte| *byte != 0) {
            let val = mem.data(&amp;store)[addr];
            println!("  First nonzero byte for memory {i}: {val} @ {addr:#x}");
        } else {
            println!("  Memory {i} is all zeroes.");
        }
    }

    println!(
        "Number of globals in the core dump: {}",
        dump.globals().len()
    );
    for (i, global) in dump.globals().iter().enumerate() {
        let val = global.get(&amp;mut store);
        println!("  Global {i} = {val:?}");
    }

    println!("Serialize the core dump and write it to ./example.coredump");
    let serialized = dump.serialize(&amp;mut store, "trapper.wasm");
    std::fs::write("./example.coredump", serialized)?;

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-multi-value"><a class="header" href="#using-multi-value">Using multi-value</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/multi.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to interact with a wasm module that uses multi-value
exports and imports.</p>
<h2 id="multiwat"><a class="header" href="#multiwat"><code>multi.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $f (import "" "f") (param i32 i64) (result i64 i32))

  (func $g (export "g") (param i32 i64) (result i64 i32)
    (call $f (local.get 0) (local.get 1))
  )

  (func $round_trip_many
    (export "round_trip_many")
    (param i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)
    (result i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)

    local.get 0
    local.get 1
    local.get 2
    local.get 3
    local.get 4
    local.get 5
    local.get 6
    local.get 7
    local.get 8
    local.get 9)
)
</code></pre>
<h2 id="multirs"><a class="header" href="#multirs"><code>multi.rs</code></a></h2>
<pre><code class="language-rust ignore">//! This is an example of working with multi-value modules and dealing with
//! multi-value functions.
//!
//! Note that the `Func::wrap*` interfaces cannot be used to return multiple
//! values just yet, so we need to use the more dynamic `Func::new` and
//! `Func::call` methods.

// You can execute this example with `cargo run --example multi`

use anyhow::Result;

fn main() -&gt; Result&lt;()&gt; {
    use wasmtime::*;

    println!("Initializing...");
    let engine = Engine::default();
    let mut store = Store::new(&amp;engine, ());

    // Compile.
    println!("Compiling module...");
    let module = Module::from_file(&amp;engine, "examples/multi.wat")?;

    // Create a host function which takes multiple parameters and returns
    // multiple results.
    println!("Creating callback...");
    let callback_func = Func::wrap(&amp;mut store, |a: i32, b: i64| -&gt; (i64, i32) {
        (b + 1, a + 1)
    });

    // Instantiate.
    println!("Instantiating module...");
    let instance = Instance::new(&amp;mut store, &amp;module, &amp;[callback_func.into()])?;

    // Extract exports.
    println!("Extracting export...");
    let g = instance.get_typed_func::&lt;(i32, i64), (i64, i32)&gt;(&amp;mut store, "g")?;

    // Call `$g`.
    println!("Calling export \"g\"...");
    let (a, b) = g.call(&amp;mut store, (1, 3))?;

    println!("Printing result...");
    println!("&gt; {} {}", a, b);

    assert_eq!(a, 4);
    assert_eq!(b, 2);

    // Call `$round_trip_many`.
    println!("Calling export \"round_trip_many\"...");
    let round_trip_many = instance
        .get_typed_func::&lt;
        (i64, i64, i64, i64, i64, i64, i64, i64, i64, i64),
        (i64, i64, i64, i64, i64, i64, i64, i64, i64, i64),
        &gt;
        (&amp;mut store, "round_trip_many")?;
    let results = round_trip_many.call(&amp;mut store, (0, 1, 2, 3, 4, 5, 6, 7, 8, 9))?;

    println!("Printing result...");
    println!("&gt; {:?}", results);
    assert_eq!(results, (0, 1, 2, 3, 4, 5, 6, 7, 8, 9));

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedding-in-c"><a class="header" href="#embedding-in-c">Embedding in C</a></h1>
<p>This section is intended to showcase the C embedding API for Wasmtime. Full
reference documentation for the C API <a href="https://bytecodealliance.github.io/wasmtime/c-api/">can be found online</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world-2"><a class="header" href="#hello-world-2">Hello, world!</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/hello.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to instantiate a simple wasm module and interact with
it.</p>
<h2 id="hellowat-1"><a class="header" href="#hellowat-1"><code>hello.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $hello (import "" "hello"))
  (func (export "run") (call $hello))
)
</code></pre>
<h2 id="helloc"><a class="header" href="#helloc"><code>hello.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating of the WebAssembly module and invoking its exported
function.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/hello.c \
       -I crates/c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o hello
   ./hello

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations as well as the name of the
`libwasmtime.a` file on Windows.

You can also build using cmake:

mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; cmake --build . --target wasmtime-hello
*/

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap);

static wasm_trap_t *hello_callback(void *env, wasmtime_caller_t *caller,
                                   const wasmtime_val_t *args, size_t nargs,
                                   wasmtime_val_t *results, size_t nresults) {
  printf("Calling back...\n");
  printf("&gt; Hello World!\n");
  return NULL;
}

int main() {
  int ret = 0;
  // Set up our compilation context. Note that we could also work with a
  // `wasm_config_t` here to configure what feature are enabled and various
  // compilation settings.
  printf("Initializing...\n");
  wasm_engine_t *engine = wasm_engine_new();
  assert(engine != NULL);

  // With an engine we can create a *store* which is a long-lived group of wasm
  // modules. Note that we allocate some custom data here to live in the store,
  // but here we skip that and specify NULL.
  wasmtime_store_t *store = wasmtime_store_new(engine, NULL, NULL);
  assert(store != NULL);
  wasmtime_context_t *context = wasmtime_store_context(store);

  // Read our input file, which in this case is a wasm text file.
  FILE *file = fopen("examples/hello.wat", "r");
  assert(file != NULL);
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t wat;
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf("&gt; Error loading module!\n");
    return 1;
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasm_byte_vec_t wasm;
  wasmtime_error_t *error = wasmtime_wat2wasm(wat.data, wat.size, &amp;wasm);
  if (error != NULL)
    exit_with_error("failed to parse wat", error, NULL);
  wasm_byte_vec_delete(&amp;wat);

  // Now that we've got our binary webassembly we can compile our module.
  printf("Compiling module...\n");
  wasmtime_module_t *module = NULL;
  error = wasmtime_module_new(engine, (uint8_t *)wasm.data, wasm.size, &amp;module);
  wasm_byte_vec_delete(&amp;wasm);
  if (error != NULL)
    exit_with_error("failed to compile module", error, NULL);

  // Next up we need to create the function that the wasm module imports. Here
  // we'll be hooking up a thunk function to the `hello_callback` native
  // function above. Note that we can assign custom data, but we just use NULL
  // for now).
  printf("Creating callback...\n");
  wasm_functype_t *hello_ty = wasm_functype_new_0_0();
  wasmtime_func_t hello;
  wasmtime_func_new(context, hello_ty, hello_callback, NULL, NULL, &amp;hello);

  // With our callback function we can now instantiate the compiled module,
  // giving us an instance we can then execute exports from. Note that
  // instantiation can trap due to execution of the `start` function, so we need
  // to handle that here too.
  printf("Instantiating module...\n");
  wasm_trap_t *trap = NULL;
  wasmtime_instance_t instance;
  wasmtime_extern_t import;
  import.kind = WASMTIME_EXTERN_FUNC;
  import.of.func = hello;
  error = wasmtime_instance_new(context, module, &amp;import, 1, &amp;instance, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to instantiate", error, trap);

  // Lookup our `run` export function
  printf("Extracting export...\n");
  wasmtime_extern_t run;
  bool ok = wasmtime_instance_export_get(context, &amp;instance, "run", 3, &amp;run);
  assert(ok);
  assert(run.kind == WASMTIME_EXTERN_FUNC);

  // And call it!
  printf("Calling export...\n");
  error = wasmtime_func_call(context, &amp;run.of.func, NULL, 0, NULL, 0, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to call function", error, trap);

  // Clean up after ourselves at this point
  printf("All finished!\n");
  ret = 0;

  wasmtime_module_delete(module);
  wasmtime_store_delete(store);
  wasm_engine_delete(engine);
  return ret;
}

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap) {
  fprintf(stderr, "error: %s\n", message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, "%.*s\n", (int)error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calculating-the-gcd-1"><a class="header" href="#calculating-the-gcd-1">Calculating the GCD</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/gcd.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how run a wasm program which calculates the GCD of two
numbers.</p>
<h2 id="gcdwat-1"><a class="header" href="#gcdwat-1"><code>gcd.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export "gcd" (func $gcd))
)

</code></pre>
<h2 id="gcdc"><a class="header" href="#gcdc"><code>gcd.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating of the WebAssembly module and invoking its exported
function.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/gcd.c \
       -I crates/c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o gcd
   ./gcd

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.

You can also build using cmake:

mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; cmake --build . --target wasmtime-gcd
*/

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap);

int main() {
  int ret = 0;
  // Set up our context
  wasm_engine_t *engine = wasm_engine_new();
  assert(engine != NULL);
  wasmtime_store_t *store = wasmtime_store_new(engine, NULL, NULL);
  assert(store != NULL);
  wasmtime_context_t *context = wasmtime_store_context(store);

  // Load our input file to parse it next
  FILE *file = fopen("examples/gcd.wat", "r");
  if (!file) {
    printf("&gt; Error loading file!\n");
    return 1;
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t wat;
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf("&gt; Error loading module!\n");
    return 1;
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasm_byte_vec_t wasm;
  wasmtime_error_t *error = wasmtime_wat2wasm(wat.data, wat.size, &amp;wasm);
  if (error != NULL)
    exit_with_error("failed to parse wat", error, NULL);
  wasm_byte_vec_delete(&amp;wat);

  // Compile and instantiate our module
  wasmtime_module_t *module = NULL;
  error = wasmtime_module_new(engine, (uint8_t *)wasm.data, wasm.size, &amp;module);
  if (module == NULL)
    exit_with_error("failed to compile module", error, NULL);
  wasm_byte_vec_delete(&amp;wasm);

  wasm_trap_t *trap = NULL;
  wasmtime_instance_t instance;
  error = wasmtime_instance_new(context, module, NULL, 0, &amp;instance, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to instantiate", error, trap);

  // Lookup our `gcd` export function
  wasmtime_extern_t gcd;
  bool ok = wasmtime_instance_export_get(context, &amp;instance, "gcd", 3, &amp;gcd);
  assert(ok);
  assert(gcd.kind == WASMTIME_EXTERN_FUNC);

  // And call it!
  int a = 6;
  int b = 27;
  wasmtime_val_t params[2];
  params[0].kind = WASMTIME_I32;
  params[0].of.i32 = a;
  params[1].kind = WASMTIME_I32;
  params[1].of.i32 = b;
  wasmtime_val_t results[1];
  error =
      wasmtime_func_call(context, &amp;gcd.of.func, params, 2, results, 1, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to call gcd", error, trap);
  assert(results[0].kind == WASMTIME_I32);

  printf("gcd(%d, %d) = %d\n", a, b, results[0].of.i32);

  // Clean up after ourselves at this point
  ret = 0;

  wasmtime_module_delete(module);
  wasmtime_store_delete(store);
  wasm_engine_delete(engine);
  return ret;
}

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap) {
  fprintf(stderr, "error: %s\n", message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
  } else {
    wasm_trap_message(trap, &amp;error_message);
  }
  fprintf(stderr, "%.*s\n", (int)error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-linear-memory-1"><a class="header" href="#using-linear-memory-1">Using linear memory</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/memory.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to interact with wasm memory in a module. Be sure to
read the documentation for <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Memory.html"><code>Memory</code></a> as well.</p>
<h2 id="memorywat-1"><a class="header" href="#memorywat-1"><code>memory.wat</code></a></h2>
<pre><code class="language-wat">(module
  (memory (export "memory") 2 3)

  (func (export "size") (result i32) (memory.size))
  (func (export "load") (param i32) (result i32)
    (i32.load8_s (local.get 0))
  )
  (func (export "store") (param i32 i32)
    (i32.store8 (local.get 0) (local.get 1))
  )

  (data (i32.const 0x1000) "\01\02\03\04")
)
</code></pre>
<h2 id="memoryc"><a class="header" href="#memoryc"><code>memory.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating of the WebAssembly module and invoking its exported
function.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/memory.c \
       -I crates/c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o memory
   ./memory

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.

You can also build using cmake:

mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; cmake --build . --target wasmtime-memory

Also note that this example was taken from
https://github.com/WebAssembly/wasm-c-api/blob/master/example/memory.c
originally
*/

#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap);

void check(bool success) {
  if (!success) {
    printf("&gt; Error, expected success\n");
    exit(1);
  }
}

void check_call(wasmtime_context_t *store, wasmtime_func_t *func,
                const wasmtime_val_t *args, size_t nargs, int32_t expected) {
  wasmtime_val_t results[1];
  wasm_trap_t *trap = NULL;
  wasmtime_error_t *error =
      wasmtime_func_call(store, func, args, nargs, results, 1, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to call function", error, trap);
  if (results[0].of.i32 != expected) {
    printf("&gt; Error on result\n");
    exit(1);
  }
}

void check_call0(wasmtime_context_t *store, wasmtime_func_t *func,
                 int32_t expected) {
  check_call(store, func, NULL, 0, expected);
}

void check_call1(wasmtime_context_t *store, wasmtime_func_t *func, int32_t arg,
                 int32_t expected) {
  wasmtime_val_t args[1];
  args[0].kind = WASMTIME_I32;
  args[0].of.i32 = arg;
  check_call(store, func, args, 1, expected);
}

void check_call2(wasmtime_context_t *store, wasmtime_func_t *func, int32_t arg1,
                 int32_t arg2, int32_t expected) {
  wasmtime_val_t args[2];
  args[0].kind = WASMTIME_I32;
  args[0].of.i32 = arg1;
  args[1].kind = WASMTIME_I32;
  args[1].of.i32 = arg2;
  check_call(store, func, args, 2, expected);
}

void check_ok(wasmtime_context_t *store, wasmtime_func_t *func,
              const wasmtime_val_t *args, size_t nargs) {
  wasm_trap_t *trap = NULL;
  wasmtime_error_t *error =
      wasmtime_func_call(store, func, args, nargs, NULL, 0, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to call function", error, trap);
}

void check_ok2(wasmtime_context_t *store, wasmtime_func_t *func, int32_t arg1,
               int32_t arg2) {
  wasmtime_val_t args[2];
  args[0].kind = WASMTIME_I32;
  args[0].of.i32 = arg1;
  args[1].kind = WASMTIME_I32;
  args[1].of.i32 = arg2;
  check_ok(store, func, args, 2);
}

void check_trap(wasmtime_context_t *store, wasmtime_func_t *func,
                const wasmtime_val_t *args, size_t nargs, size_t num_results) {
  assert(num_results &lt;= 1);
  wasmtime_val_t results[1];
  wasm_trap_t *trap = NULL;
  wasmtime_error_t *error =
      wasmtime_func_call(store, func, args, nargs, results, num_results, &amp;trap);
  if (error != NULL)
    exit_with_error("failed to call function", error, NULL);
  if (trap == NULL) {
    printf("&gt; Error on result, expected trap\n");
    exit(1);
  }
  wasm_trap_delete(trap);
}

void check_trap1(wasmtime_context_t *store, wasmtime_func_t *func,
                 int32_t arg) {
  wasmtime_val_t args[1];
  args[0].kind = WASMTIME_I32;
  args[0].of.i32 = arg;
  check_trap(store, func, args, 1, 1);
}

void check_trap2(wasmtime_context_t *store, wasmtime_func_t *func, int32_t arg1,
                 int32_t arg2) {
  wasmtime_val_t args[2];
  args[0].kind = WASMTIME_I32;
  args[0].of.i32 = arg1;
  args[1].kind = WASMTIME_I32;
  args[1].of.i32 = arg2;
  check_trap(store, func, args, 2, 0);
}

int main(int argc, const char *argv[]) {
  // Initialize.
  printf("Initializing...\n");
  wasm_engine_t *engine = wasm_engine_new();
  wasmtime_store_t *store = wasmtime_store_new(engine, NULL, NULL);
  wasmtime_context_t *context = wasmtime_store_context(store);

  // Load our input file to parse it next
  FILE *file = fopen("examples/memory.wat", "r");
  if (!file) {
    printf("&gt; Error loading file!\n");
    return 1;
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t wat;
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf("&gt; Error loading module!\n");
    return 1;
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasm_byte_vec_t binary;
  wasmtime_error_t *error = wasmtime_wat2wasm(wat.data, wat.size, &amp;binary);
  if (error != NULL)
    exit_with_error("failed to parse wat", error, NULL);
  wasm_byte_vec_delete(&amp;wat);

  // Compile.
  printf("Compiling module...\n");
  wasmtime_module_t *module = NULL;
  error =
      wasmtime_module_new(engine, (uint8_t *)binary.data, binary.size, &amp;module);
  if (error)
    exit_with_error("failed to compile module", error, NULL);
  wasm_byte_vec_delete(&amp;binary);

  // Instantiate.
  printf("Instantiating module...\n");
  wasmtime_instance_t instance;
  wasm_trap_t *trap = NULL;
  error = wasmtime_instance_new(context, module, NULL, 0, &amp;instance, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to instantiate", error, trap);
  wasmtime_module_delete(module);

  // Extract export.
  printf("Extracting exports...\n");
  wasmtime_memory_t memory;
  wasmtime_func_t size_func, load_func, store_func;
  wasmtime_extern_t item;
  bool ok;
  ok = wasmtime_instance_export_get(context, &amp;instance, "memory",
                                    strlen("memory"), &amp;item);
  assert(ok &amp;&amp; item.kind == WASMTIME_EXTERN_MEMORY);
  memory = item.of.memory;
  ok = wasmtime_instance_export_get(context, &amp;instance, "size", strlen("size"),
                                    &amp;item);
  assert(ok &amp;&amp; item.kind == WASMTIME_EXTERN_FUNC);
  size_func = item.of.func;
  ok = wasmtime_instance_export_get(context, &amp;instance, "load", strlen("load"),
                                    &amp;item);
  assert(ok &amp;&amp; item.kind == WASMTIME_EXTERN_FUNC);
  load_func = item.of.func;
  ok = wasmtime_instance_export_get(context, &amp;instance, "store",
                                    strlen("store"), &amp;item);
  assert(ok &amp;&amp; item.kind == WASMTIME_EXTERN_FUNC);
  store_func = item.of.func;

  // Check initial memory.
  printf("Checking memory...\n");
  check(wasmtime_memory_size(context, &amp;memory) == 2);
  check(wasmtime_memory_data_size(context, &amp;memory) == 0x20000);
  check(wasmtime_memory_data(context, &amp;memory)[0] == 0);
  check(wasmtime_memory_data(context, &amp;memory)[0x1000] == 1);
  check(wasmtime_memory_data(context, &amp;memory)[0x1003] == 4);

  check_call0(context, &amp;size_func, 2);
  check_call1(context, &amp;load_func, 0, 0);
  check_call1(context, &amp;load_func, 0x1000, 1);
  check_call1(context, &amp;load_func, 0x1003, 4);
  check_call1(context, &amp;load_func, 0x1ffff, 0);
  check_trap1(context, &amp;load_func, 0x20000);

  // Mutate memory.
  printf("Mutating memory...\n");
  wasmtime_memory_data(context, &amp;memory)[0x1003] = 5;
  check_ok2(context, &amp;store_func, 0x1002, 6);
  check_trap2(context, &amp;store_func, 0x20000, 0);

  check(wasmtime_memory_data(context, &amp;memory)[0x1002] == 6);
  check(wasmtime_memory_data(context, &amp;memory)[0x1003] == 5);
  check_call1(context, &amp;load_func, 0x1002, 6);
  check_call1(context, &amp;load_func, 0x1003, 5);

  // Grow memory.
  printf("Growing memory...\n");
  uint64_t old_size;
  error = wasmtime_memory_grow(context, &amp;memory, 1, &amp;old_size);
  if (error != NULL)
    exit_with_error("failed to grow memory", error, trap);
  check(wasmtime_memory_size(context, &amp;memory) == 3);
  check(wasmtime_memory_data_size(context, &amp;memory) == 0x30000);

  check_call1(context, &amp;load_func, 0x20000, 0);
  check_ok2(context, &amp;store_func, 0x20000, 0);
  check_trap1(context, &amp;load_func, 0x30000);
  check_trap2(context, &amp;store_func, 0x30000, 0);

  error = wasmtime_memory_grow(context, &amp;memory, 1, &amp;old_size);
  assert(error != NULL);
  wasmtime_error_delete(error);
  error = wasmtime_memory_grow(context, &amp;memory, 0, &amp;old_size);
  if (error != NULL)
    exit_with_error("failed to grow memory", error, trap);

  // Create stand-alone memory.
  printf("Creating stand-alone memory...\n");
  wasm_limits_t limits = {5, 5};
  wasm_memorytype_t *memorytype = wasm_memorytype_new(&amp;limits);
  wasmtime_memory_t memory2;
  error = wasmtime_memory_new(context, memorytype, &amp;memory2);
  if (error != NULL)
    exit_with_error("failed to create memory", error, trap);
  wasm_memorytype_delete(memorytype);
  check(wasmtime_memory_size(context, &amp;memory2) == 5);

  // Shut down.
  printf("Shutting down...\n");
  wasmtime_store_delete(store);
  wasm_engine_delete(engine);

  // All done.
  printf("Done.\n");
  return 0;
}

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap) {
  fprintf(stderr, "error: %s\n", message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, "%.*s\n", (int)error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasi-1"><a class="header" href="#wasi-1">WASI</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/wasi/main.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to instantiate a wasm module using WASI imports.</p>
<h2 id="wasm-source-code"><a class="header" href="#wasm-source-code">Wasm Source code</a></h2>
<pre><code class="language-rust ignore">fn main() {
    println!("Hello, world!");
}</code></pre>
<h2 id="wasic"><a class="header" href="#wasic"><code>wasi.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating a WebAssembly which uses WASI imports.

You can compile and run this example on Linux with:

   cmake examples/
   cargo build --release -p wasmtime-c-api
   cc examples/wasi/main.c \
       -I crates/c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o wasi
   ./wasi

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.

You can also build using cmake:

mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; cmake --build . --target wasmtime-wasi
*/

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wasi.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap);

int main() {
  // Set up our context
  wasm_engine_t *engine = wasm_engine_new();
  assert(engine != NULL);
  wasmtime_store_t *store = wasmtime_store_new(engine, NULL, NULL);
  assert(store != NULL);
  wasmtime_context_t *context = wasmtime_store_context(store);

  // Create a linker with WASI functions defined
  wasmtime_linker_t *linker = wasmtime_linker_new(engine);
  wasmtime_error_t *error = wasmtime_linker_define_wasi(linker);
  if (error != NULL)
    exit_with_error("failed to link wasi", error, NULL);

  wasm_byte_vec_t wasm;
  // Load our input file to parse it next
  FILE *file = fopen("target/wasm32-wasi/debug/wasi.wasm", "rb");
  if (!file) {
    printf("&gt; Error loading file!\n");
    exit(1);
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  wasm_byte_vec_new_uninitialized(&amp;wasm, file_size);
  fseek(file, 0L, SEEK_SET);
  if (fread(wasm.data, file_size, 1, file) != 1) {
    printf("&gt; Error loading module!\n");
    exit(1);
  }
  fclose(file);

  // Compile our modules
  wasmtime_module_t *module = NULL;
  error = wasmtime_module_new(engine, (uint8_t *)wasm.data, wasm.size, &amp;module);
  if (!module)
    exit_with_error("failed to compile module", error, NULL);
  wasm_byte_vec_delete(&amp;wasm);

  // Instantiate wasi
  wasi_config_t *wasi_config = wasi_config_new();
  assert(wasi_config);
  wasi_config_inherit_argv(wasi_config);
  wasi_config_inherit_env(wasi_config);
  wasi_config_inherit_stdin(wasi_config);
  wasi_config_inherit_stdout(wasi_config);
  wasi_config_inherit_stderr(wasi_config);
  wasm_trap_t *trap = NULL;
  error = wasmtime_context_set_wasi(context, wasi_config);
  if (error != NULL)
    exit_with_error("failed to instantiate WASI", error, NULL);

  // Instantiate the module
  error = wasmtime_linker_module(linker, context, "", 0, module);
  if (error != NULL)
    exit_with_error("failed to instantiate module", error, NULL);

  // Run it.
  wasmtime_func_t func;
  error = wasmtime_linker_get_default(linker, context, "", 0, &amp;func);
  if (error != NULL)
    exit_with_error("failed to locate default export for module", error, NULL);

  error = wasmtime_func_call(context, &amp;func, NULL, 0, NULL, 0, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("error calling default export", error, trap);

  // Clean up after ourselves at this point
  wasmtime_module_delete(module);
  wasmtime_store_delete(store);
  wasm_engine_delete(engine);
  return 0;
}

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap) {
  fprintf(stderr, "error: %s\n", message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, "%.*s\n", (int)error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linking-modules-1"><a class="header" href="#linking-modules-1">Linking modules</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/linking.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to compile and instantiate modules which link
together.</p>
<h2 id="linking1wat-1"><a class="header" href="#linking1wat-1"><code>linking1.wat</code></a></h2>
<pre><code class="language-wat">(module
  (import "linking2" "double" (func $double (param i32) (result i32)))
  (import "linking2" "log" (func $log (param i32 i32)))
  (import "linking2" "memory" (memory 1))
  (import "linking2" "memory_offset" (global $offset i32))

  (func (export "run")
    ;; Call into the other module to double our number, and we could print it
    ;; here but for now we just drop it
    i32.const 2
    call $double
    drop

    ;; Our `data` segment initialized our imported memory, so let's print the
    ;; string there now.
    global.get $offset
    i32.const 14
    call $log
  )

  (data (global.get $offset) "Hello, world!\n")
)

</code></pre>
<h2 id="linking2wat-1"><a class="header" href="#linking2wat-1"><code>linking2.wat</code></a></h2>
<pre><code class="language-wat">(module
  (type $fd_write_ty (func (param i32 i32 i32 i32) (result i32)))
  (import "wasi_snapshot_preview1" "fd_write" (func $fd_write (type $fd_write_ty)))

  (func (export "double") (param i32) (result i32)
    local.get 0
    i32.const 2
    i32.mul
  )

  (func (export "log") (param i32 i32)
    ;; store the pointer in the first iovec field
    i32.const 4
    local.get 0
    i32.store

    ;; store the length in the first iovec field
    i32.const 4
    local.get 1
    i32.store offset=4

    ;; call the `fd_write` import
    i32.const 1     ;; stdout fd
    i32.const 4     ;; iovs start
    i32.const 1     ;; number of iovs
    i32.const 0     ;; where to write nwritten bytes
    call $fd_write
    drop
  )

  (memory (export "memory") 2)
  (global (export "memory_offset") i32 (i32.const 65536))
)
</code></pre>
<h2 id="linkingc"><a class="header" href="#linkingc"><code>linking.c</code></a></h2>
<pre><code class="language-c">/*
Example of compiling, instantiating, and linking two WebAssembly modules
together.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/linking.c \
       -I crates/c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o linking
   ./linking

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.

You can also build using cmake:

mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; cmake --build . --target wasmtime-linking
*/

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wasi.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap);
static void read_wat_file(wasm_engine_t *engine, wasm_byte_vec_t *bytes,
                          const char *file);

int main() {
  // Set up our context
  wasm_engine_t *engine = wasm_engine_new();
  assert(engine != NULL);
  wasmtime_store_t *store = wasmtime_store_new(engine, NULL, NULL);
  assert(store != NULL);
  wasmtime_context_t *context = wasmtime_store_context(store);

  wasm_byte_vec_t linking1_wasm, linking2_wasm;
  read_wat_file(engine, &amp;linking1_wasm, "examples/linking1.wat");
  read_wat_file(engine, &amp;linking2_wasm, "examples/linking2.wat");

  // Compile our two modules
  wasmtime_error_t *error;
  wasmtime_module_t *linking1_module = NULL;
  wasmtime_module_t *linking2_module = NULL;
  error = wasmtime_module_new(engine, (uint8_t *)linking1_wasm.data,
                              linking1_wasm.size, &amp;linking1_module);
  if (error != NULL)
    exit_with_error("failed to compile linking1", error, NULL);
  error = wasmtime_module_new(engine, (uint8_t *)linking2_wasm.data,
                              linking2_wasm.size, &amp;linking2_module);
  if (error != NULL)
    exit_with_error("failed to compile linking2", error, NULL);
  wasm_byte_vec_delete(&amp;linking1_wasm);
  wasm_byte_vec_delete(&amp;linking2_wasm);

  // Configure WASI and store it within our `wasmtime_store_t`
  wasi_config_t *wasi_config = wasi_config_new();
  assert(wasi_config);
  wasi_config_inherit_argv(wasi_config);
  wasi_config_inherit_env(wasi_config);
  wasi_config_inherit_stdin(wasi_config);
  wasi_config_inherit_stdout(wasi_config);
  wasi_config_inherit_stderr(wasi_config);
  wasm_trap_t *trap = NULL;
  error = wasmtime_context_set_wasi(context, wasi_config);
  if (error != NULL)
    exit_with_error("failed to instantiate wasi", NULL, trap);

  // Create our linker which will be linking our modules together, and then add
  // our WASI instance to it.
  wasmtime_linker_t *linker = wasmtime_linker_new(engine);
  error = wasmtime_linker_define_wasi(linker);
  if (error != NULL)
    exit_with_error("failed to link wasi", error, NULL);

  // Instantiate `linking2` with our linker.
  wasmtime_instance_t linking2;
  error = wasmtime_linker_instantiate(linker, context, linking2_module,
                                      &amp;linking2, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to instantiate linking2", error, trap);

  // Register our new `linking2` instance with the linker
  error = wasmtime_linker_define_instance(linker, context, "linking2",
                                          strlen("linking2"), &amp;linking2);
  if (error != NULL)
    exit_with_error("failed to link linking2", error, NULL);

  // Instantiate `linking1` with the linker now that `linking2` is defined
  wasmtime_instance_t linking1;
  error = wasmtime_linker_instantiate(linker, context, linking1_module,
                                      &amp;linking1, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to instantiate linking1", error, trap);

  // Lookup our `run` export function
  wasmtime_extern_t run;
  bool ok = wasmtime_instance_export_get(context, &amp;linking1, "run", 3, &amp;run);
  assert(ok);
  assert(run.kind == WASMTIME_EXTERN_FUNC);
  error = wasmtime_func_call(context, &amp;run.of.func, NULL, 0, NULL, 0, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to call run", error, trap);

  // Clean up after ourselves at this point
  wasmtime_linker_delete(linker);
  wasmtime_module_delete(linking1_module);
  wasmtime_module_delete(linking2_module);
  wasmtime_store_delete(store);
  wasm_engine_delete(engine);
  return 0;
}

static void read_wat_file(wasm_engine_t *engine, wasm_byte_vec_t *bytes,
                          const char *filename) {
  wasm_byte_vec_t wat;
  // Load our input file to parse it next
  FILE *file = fopen(filename, "r");
  if (!file) {
    printf("&gt; Error loading file!\n");
    exit(1);
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  fseek(file, 0L, SEEK_SET);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf("&gt; Error loading module!\n");
    exit(1);
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasmtime_error_t *error = wasmtime_wat2wasm(wat.data, wat.size, bytes);
  if (error != NULL)
    exit_with_error("failed to parse wat", error, NULL);
  wasm_byte_vec_delete(&amp;wat);
}

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap) {
  fprintf(stderr, "error: %s\n", message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, "%.*s\n", (int)error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-1"><a class="header" href="#debugging-1">Debugging</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/fib-debug/main.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to set up a module for dynamic runtime debugging via
a native debugger like GDB or LLDB.</p>
<h2 id="mainc"><a class="header" href="#mainc"><code>main.c</code></a></h2>
<pre><code class="language-c">#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

#define own

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap);

int main(int argc, const char *argv[]) {
  // Configuring engine to support generating of DWARF info.
  // lldb can be used to attach to the program and observe
  // original fib-wasm.c source code and variables.
  wasm_config_t *config = wasm_config_new();
  wasmtime_config_debug_info_set(config, true);

  // Initialize.
  printf("Initializing...\n");
  wasm_engine_t *engine = wasm_engine_new_with_config(config);
  wasmtime_store_t *store = wasmtime_store_new(engine, NULL, NULL);
  wasmtime_context_t *context = wasmtime_store_context(store);

  // Load binary.
  printf("Loading binary...\n");
  FILE *file = fopen("target/wasm32-unknown-unknown/debug/fib.wasm", "rb");
  if (!file) {
    printf("&gt; Error opening module!\n");
    return 1;
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t binary;
  wasm_byte_vec_new_uninitialized(&amp;binary, file_size);
  if (fread(binary.data, file_size, 1, file) != 1) {
    printf("&gt; Error reading module!\n");
    return 1;
  }
  fclose(file);

  // Compile.
  printf("Compiling module...\n");
  wasmtime_module_t *module = NULL;
  wasmtime_error_t *error =
      wasmtime_module_new(engine, (uint8_t *)binary.data, binary.size, &amp;module);
  if (!module)
    exit_with_error("failed to compile module", error, NULL);
  wasm_byte_vec_delete(&amp;binary);

  // Instantiate.
  printf("Instantiating module...\n");
  wasmtime_instance_t instance;
  wasm_trap_t *trap = NULL;
  error = wasmtime_instance_new(context, module, NULL, 0, &amp;instance, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to instantiate", error, trap);
  wasmtime_module_delete(module);

  // Extract export.
  wasmtime_extern_t fib;
  bool ok = wasmtime_instance_export_get(context, &amp;instance, "fib", 3, &amp;fib);
  assert(ok);

  // Call.
  printf("Calling fib...\n");
  wasmtime_val_t params[1];
  params[0].kind = WASMTIME_I32;
  params[0].of.i32 = 6;
  wasmtime_val_t results[1];
  error =
      wasmtime_func_call(context, &amp;fib.of.func, params, 1, results, 1, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to call function", error, trap);

  assert(results[0].kind == WASMTIME_I32);
  printf("&gt; fib(6) = %d\n", results[0].of.i32);

  // Shut down.
  printf("Shutting down...\n");
  wasmtime_store_delete(store);
  wasm_engine_delete(engine);

  // All done.
  printf("Done.\n");
  return 0;
}

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap) {
  fprintf(stderr, "error: %s\n", message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
  } else {
    wasm_trap_message(trap, &amp;error_message);
  }
  fprintf(stderr, "%.*s\n", (int)error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-multi-value-1"><a class="header" href="#using-multi-value-1">Using multi-value</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/multi.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to interact with a wasm module that uses multi-value
exports and imports.</p>
<h2 id="multiwat-1"><a class="header" href="#multiwat-1"><code>multi.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $f (import "" "f") (param i32 i64) (result i64 i32))

  (func $g (export "g") (param i32 i64) (result i64 i32)
    (call $f (local.get 0) (local.get 1))
  )

  (func $round_trip_many
    (export "round_trip_many")
    (param i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)
    (result i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)

    local.get 0
    local.get 1
    local.get 2
    local.get 3
    local.get 4
    local.get 5
    local.get 6
    local.get 7
    local.get 8
    local.get 9)
)
</code></pre>
<h2 id="multic"><a class="header" href="#multic"><code>multi.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating of the WebAssembly module and invoking its exported
function.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/multi.c \
       -I crates/c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o multi
   ./multi

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.

You can also build using cmake:

mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; cmake --build . --target wasmtime-multi

Also note that this example was taken from
https://github.com/WebAssembly/wasm-c-api/blob/master/example/multi.c
originally
*/

#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap);

// A function to be called from Wasm code.
wasm_trap_t *callback(void *env, wasmtime_caller_t *caller,
                      const wasmtime_val_t *args, size_t nargs,
                      wasmtime_val_t *results, size_t nresults) {
  printf("Calling back...\n");
  printf("&gt; %" PRIu32 " %" PRIu64 "\n", args[0].of.i32, args[1].of.i64);
  printf("\n");

  results[0] = args[1];
  results[1] = args[0];
  return NULL;
}

// A function closure.
wasm_trap_t *closure_callback(void *env, wasmtime_caller_t *caller,
                              const wasmtime_val_t *args, size_t nargs,
                              wasmtime_val_t *results, size_t nresults) {
  int i = *(int *)env;
  printf("Calling back closure...\n");
  printf("&gt; %d\n", i);

  results[0].kind = WASMTIME_I32;
  results[0].of.i32 = (int32_t)i;
  return NULL;
}

int main(int argc, const char *argv[]) {
  // Initialize.
  printf("Initializing...\n");
  wasm_engine_t *engine = wasm_engine_new();
  wasmtime_store_t *store = wasmtime_store_new(engine, NULL, NULL);
  wasmtime_context_t *context = wasmtime_store_context(store);

  // Load our input file to parse it next
  FILE *file = fopen("examples/multi.wat", "r");
  if (!file) {
    printf("&gt; Error loading file!\n");
    return 1;
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t wat;
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf("&gt; Error loading module!\n");
    return 1;
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasm_byte_vec_t binary;
  wasmtime_error_t *error = wasmtime_wat2wasm(wat.data, wat.size, &amp;binary);
  if (error != NULL)
    exit_with_error("failed to parse wat", error, NULL);
  wasm_byte_vec_delete(&amp;wat);

  // Compile.
  printf("Compiling module...\n");
  wasmtime_module_t *module = NULL;
  error =
      wasmtime_module_new(engine, (uint8_t *)binary.data, binary.size, &amp;module);
  if (error)
    exit_with_error("failed to compile module", error, NULL);
  wasm_byte_vec_delete(&amp;binary);

  // Create external print functions.
  printf("Creating callback...\n");
  wasm_functype_t *callback_type =
      wasm_functype_new_2_2(wasm_valtype_new_i32(), wasm_valtype_new_i64(),
                            wasm_valtype_new_i64(), wasm_valtype_new_i32());
  wasmtime_func_t callback_func;
  wasmtime_func_new(context, callback_type, callback, NULL, NULL,
                    &amp;callback_func);
  wasm_functype_delete(callback_type);

  // Instantiate.
  printf("Instantiating module...\n");
  wasmtime_extern_t imports[1];
  imports[0].kind = WASMTIME_EXTERN_FUNC;
  imports[0].of.func = callback_func;
  wasmtime_instance_t instance;
  wasm_trap_t *trap = NULL;
  error = wasmtime_instance_new(context, module, imports, 1, &amp;instance, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to instantiate", error, trap);
  wasmtime_module_delete(module);

  // Extract export.
  printf("Extracting export...\n");
  wasmtime_extern_t run;
  bool ok = wasmtime_instance_export_get(context, &amp;instance, "g", 1, &amp;run);
  assert(ok);
  assert(run.kind == WASMTIME_EXTERN_FUNC);

  // Call.
  printf("Calling export...\n");
  wasmtime_val_t args[2];
  args[0].kind = WASMTIME_I32;
  args[0].of.i32 = 1;
  args[1].kind = WASMTIME_I64;
  args[1].of.i64 = 2;
  wasmtime_val_t results[2];
  error = wasmtime_func_call(context, &amp;run.of.func, args, 2, results, 2, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error("failed to call run", error, trap);

  // Print result.
  printf("Printing result...\n");
  printf("&gt; %" PRIu64 " %" PRIu32 "\n", results[0].of.i64, results[1].of.i32);

  assert(results[0].kind == WASMTIME_I64);
  assert(results[0].of.i64 == 2);
  assert(results[1].kind == WASMTIME_I32);
  assert(results[1].of.i32 == 1);

  // Shut down.
  printf("Shutting down...\n");
  wasmtime_store_delete(store);
  wasm_engine_delete(engine);

  // All done.
  printf("Done.\n");
  return 0;
}

static void exit_with_error(const char *message, wasmtime_error_t *error,
                            wasm_trap_t *trap) {
  fprintf(stderr, "error: %s\n", message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, "%.*s\n", (int)error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-webassembly-from-python"><a class="header" href="#using-webassembly-from-python">Using WebAssembly from Python</a></h1>
<p>Wasmtime <a href="https://pypi.org/project/wasmtime/">is available on PyPI</a> and can be
used programmatically or as a python module loader, which allows almost any
WebAssembly module to be used as a python module. This guide will go over adding
Wasmtime to your project, and some provided examples of what can be done with
WebAssembly modules.</p>
<p>Make sure you've got Python 3.5 or newer installed locally, and we can get
started!</p>
<h2 id="getting-started-and-simple-example"><a class="header" href="#getting-started-and-simple-example">Getting started and simple example</a></h2>
<p>First, copy this example WebAssembly text module into your project with the filename <code>gcd.wat</code>. It exports a
function for calculating the greatest common denominator of two numbers.</p>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export "gcd" (func $gcd))
)

</code></pre>
<p>Next, install the <a href="https://pypi.org/project/wasmtime/">Wasmtime package</a> from
PyPi. It can be installed as a dependency through Pip or related tools such as
Pipenv.</p>
<pre><code class="language-bash">pip install wasmtime
</code></pre>
<p>Or</p>
<pre><code class="language-bash">pipenv install wasmtime
</code></pre>
<p>After you have Wasmtime installed and you've imported <code>wasmtime</code>, you can import
WebAssembly modules in your project like any other python module.</p>
<pre><code class="language-python">import wasmtime.loader
import gcd

print("gcd(27, 6) =", gcd.gcd(27, 6))
</code></pre>
<p>This script should output</p>
<pre><code class="language-bash">gcd(27, 6) = 3
</code></pre>
<p>If this is the output you see, congrats! You've successfully ran your first
WebAssembly code in python!</p>
<p>You can also alternatively use the <a href="https://bytecodealliance.github.io/wasmtime-py/"><code>wasmtime</code> package's
API</a>:</p>
<pre><code class="language-python">from wasmtime import Store, Module, Instance

store = Store()
module = Module.from_file(store.engine, 'gcd.wat')
instance = Instance(store, module, [])
gcd = instance.exports(store)['gcd']
print("gcd(27, 6) = %d" % gcd(store, 27, 6))
</code></pre>
<h2 id="more-examples-and-contributing"><a class="header" href="#more-examples-and-contributing">More examples and contributing</a></h2>
<p>The <code>wasmtime</code> Python package currently <a href="https://github.com/bytecodealliance/wasmtime-py">lives in its own repository outside of
<code>wasmtime</code></a> and has a <a href="https://github.com/bytecodealliance/wasmtime-py/tree/main/examples">number
of other more advanced
examples</a>
as well. Feel free to browse those, but if you find anything missing don't
hesitate to <a href="https://github.com/bytecodealliance/wasmtime-py/issues/new">open an
issue</a> and let us
know if you have any questions!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-webassembly-from-net"><a class="header" href="#using-webassembly-from-net">Using WebAssembly from .NET</a></h1>
<p>The <a href="https://www.nuget.org/packages/Wasmtime">Wasmtime</a> NuGet package can be used to
programmatically interact with WebAssembly modules.</p>
<p>This guide will go over adding Wasmtime to your project and demonstrate a simple
example of using a WebAssembly module from C#.</p>
<p>Make sure you have a <a href="https://dotnet.microsoft.com/download">.NET Core SDK 3.0 SDK or later</a>
installed before we get started!</p>
<h2 id="getting-started-and-simple-example-1"><a class="header" href="#getting-started-and-simple-example-1">Getting started and simple example</a></h2>
<p>Start by creating a new .NET Core console project:</p>
<pre><code class="language-text">$ mkdir gcd
$ cd gcd
$ dotnet new console
</code></pre>
<p>Next, add a reference to the Wasmtime NuGet package to your project:</p>
<pre><code class="language-text">$ dotnet add package --version 0.19.0-preview1 wasmtime
</code></pre>
<p>Copy this example WebAssembly text module into your project directory as <code>gcd.wat</code>.</p>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export "gcd" (func $gcd))
)

</code></pre>
<p>This module exports a function for calculating the greatest common denominator of two numbers.</p>
<p>Replace the code in <code>Program.cs</code> with the following:</p>
<pre><code class="language-c#">using System;
using Wasmtime;

namespace Tutorial
{
    class Program
    {
        static void Main(string[] args)
        {
            using var engine = new Engine();
            using var module = Module.FromTextFile(engine, "gcd.wat");

            using var host = new Host(engine);
            using dynamic instance = host.Instantiate(module);

            Console.WriteLine($"gcd(27, 6) = {instance.gcd(27, 6)}");
        }
    }
}
</code></pre>
<p>Run the .NET core program:</p>
<pre><code class="language-text">$ dotnet run
</code></pre>
<p>The program should output:</p>
<pre><code class="language-text">gcd(27, 6) = 3
</code></pre>
<p>If this is the output you see, congrats! You've successfully ran your first
WebAssembly code in .NET!</p>
<h2 id="more-examples-and-contributing-1"><a class="header" href="#more-examples-and-contributing-1">More examples and contributing</a></h2>
<p>The <a href="https://github.com/bytecodealliance/wasmtime-dotnet">.NET embedding of Wasmtime repository</a>
contains the source code for the Wasmtime NuGet package.</p>
<p>The repository also has more <a href="https://github.com/bytecodealliance/wasmtime-dotnet/tree/main/examples">examples</a>
as well.</p>
<p>Feel free to browse those, but if you find anything missing don't
hesitate to <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/new">open an issue</a> and let us
know if you have any questions!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-webassembly-from-go"><a class="header" href="#using-webassembly-from-go">Using WebAssembly from Go</a></h1>
<p>Wasmtime <a href="https://pkg.go.dev/github.com/bytecodealliance/wasmtime-go">is available as a Go
Module</a>. This guide
will go over adding Wasmtime to your project, and some provided examples of what
can be done with WebAssembly modules.</p>
<p>Make sure you're using Go 1.12 or later with modules support.</p>
<h2 id="getting-started-and-simple-example-2"><a class="header" href="#getting-started-and-simple-example-2">Getting started and simple example</a></h2>
<p>First up you'll want to start a new module:</p>
<pre><code class="language-sh">$ mkdir hello-wasm
$ cd hello-wasm
$ go mod init hello-wasm
$ go get github.com/bytecodealliance/wasmtime-go
</code></pre>
<p>Next, copy this example WebAssembly text module into your project. It exports a
function for calculating the greatest common denominator of two numbers.</p>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export "gcd" (func $gcd))
)

</code></pre>
<p>Next, we can write our code in <code>main.go</code> which reads this file and runs it:</p>
<pre><code class="language-go">package main

import (
    "fmt"
    "github.com/bytecodealliance/wasmtime-go"
)

func main() {
    engine := wasmtime.NewEngine()
    store := wasmtime.NewStore(engine)
    module, err := wasmtime.NewModuleFromFile(engine, "gcd.wat")
    check(err)
    instance, err := wasmtime.NewInstance(store, module, []wasmtime.AsExtern{})
    check(err)

    gcd := instance.GetExport(store, "gcd").Func()
    val, err := gcd.Call(store, 6, 27)
    check(err)
    fmt.Printf("gcd(6, 27) = %d\n", val.(int32))
}

func check(err error) {
    if err != nil {
        panic(err)
    }
}
</code></pre>
<p>And finally we can build and run it:</p>
<pre><code class="language-sh">$ go run main.go
gcd(6, 27) = 3
</code></pre>
<p>If this is the output you see, congrats! You've successfully ran your first
WebAssembly code in Go!</p>
<h2 id="more-examples-and-contributing-2"><a class="header" href="#more-examples-and-contributing-2">More examples and contributing</a></h2>
<p>The <code>wasmtime</code> Go package <a href="https://github.com/bytecodealliance/wasmtime-go">lives in its own
repository</a> and has a <a href="https://pkg.go.dev/github.com/bytecodealliance/wasmtime-go?tab=doc#pkg-examples">number
of other more advanced
examples</a>
as well. Feel free to browse those, but if you find anything missing don't
hesitate to <a href="https://github.com/bytecodealliance/wasmtime-go/issues/new">open an
issue</a> and let us
know if you have any questions!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-webassembly-from-bash"><a class="header" href="#using-webassembly-from-bash">Using WebAssembly from Bash</a></h1>
<h2 id="getting-started-and-simple-example-3"><a class="header" href="#getting-started-and-simple-example-3">Getting started and simple example</a></h2>
<p>First up you'll want to start a new module:</p>
<pre><code class="language-text">$ mkdir -p gcd-bash
$ cd gcd-bash
$ touch gcd.wat gcd.sh
</code></pre>
<p>Next, copy this example WebAssembly text module into your project. It exports a function for calculating the greatest common denominator of two numbers.</p>
<h2 id="gcdwat-2"><a class="header" href="#gcdwat-2"><code>gcd.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export "gcd" (func $gcd))
)

</code></pre>
<p>Create a bash script that will invoke GCD three times.</p>
<h2 id="gcdsh"><a class="header" href="#gcdsh"><code>gcd.sh</code></a></h2>
<pre><code class="language-bash">#!/bin/bash

function gcd() {
  # Cast to number; default = 0
  local x=$(($1))
  local y=$(($2))
  # Invoke GCD from module; suppress stderr
  local result=$(wasmtime --invoke gcd examples/gcd.wat $x $y 2&gt;/dev/null)
  echo "$result"
}

# main
for num in "27 6" "6 27" "42 12"; do
  set -- $num
  echo "gcd($1, $2) = $(gcd "$1" "$2")"
done
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-webassembly-from-ruby"><a class="header" href="#using-webassembly-from-ruby">Using WebAssembly from Ruby</a></h1>
<p>Wasmtime <a href="https://rubygems.org/gems/wasmtime">is available on RubyGems</a> and can
be used programmatically to interact with Wasm modules. This guide will go over
installing the Wasmtime gem and running a simple Wasm module from Ruby.</p>
<p>Make sure you've got Ruby 3.0 or newer installed locally, and we can get
started!</p>
<h2 id="getting-started-and-simple-example-4"><a class="header" href="#getting-started-and-simple-example-4">Getting started and simple example</a></h2>
<p>First, copy this example WebAssembly text module into your project. It exports
a function for calculating the greatest common denominator of two numbers.</p>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export "gcd" (func $gcd))
)

</code></pre>
<p>Next, install the Wasmtime Ruby gems by either adding it your project's
<code>Gemfile</code>:</p>
<pre><code class="language-bash">bundle add wasmtime
</code></pre>
<p>Or by using the <code>gem</code> command directly:</p>
<pre><code class="language-bash">gem install wasmtime
</code></pre>
<p>The gem has a Rust-based native extension, but thanks to precompiled gems, you
should not have to compile anything. It'll just work!</p>
<p>Now that you have the Wasmtime gem installed, let's create a Ruby script to
execute the <code>gcd</code> module from before.</p>
<pre><code class="language-ruby">require "wasmtime"

engine = Wasmtime::Engine.new
mod = Wasmtime::Module.from_file(engine, "gcd.wat")
store = Wasmtime::Store.new(engine)
instance = Wasmtime::Instance.new(store, mod)

puts "gcd(27, 6) = #{instance.invoke("gcd", 27, 6)}"
</code></pre>
<p>This script should output</p>
<pre><code class="language-bash">gcd(27, 6) = 3
</code></pre>
<p>If this is the output you see, congrats! You've successfully ran your first
WebAssembly code in Ruby!</p>
<h2 id="more-examples-and-contributing-3"><a class="header" href="#more-examples-and-contributing-3">More examples and contributing</a></h2>
<p>To learn more, check out the <a href="https://github.com/bytecodealliance/wasmtime-rb/tree/main/examples">more advanced examples</a>
and the <a href="https://bytecodealliance.github.io/wasmtime-rb/latest/">API documentation</a>.
If you have any questions, do not hesitate to open an issue on the
<a href="https://github.com/bytecodealliance/wasmtime-rb">GitHub repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-webassembly-from-elixir"><a class="header" href="#using-webassembly-from-elixir">Using WebAssembly from Elixir</a></h1>
<p>Wasmtime <a href="https://hex.pm/packages/wasmex">is available on Hex</a> and can
be used programmatically to interact with Wasm modules. This guide will go over
installing the wasmex package and running a simple Wasm module from Elixir.</p>
<h2 id="getting-started-and-simple-example-5"><a class="header" href="#getting-started-and-simple-example-5">Getting started and simple example</a></h2>
<p>First, copy this example WebAssembly text module into the current directory. It exports
a function for calculating the greatest common denominator of two numbers.</p>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export "gcd" (func $gcd))
)

</code></pre>
<p>The library has a Rust-based native extension, but thanks to <code>rustler_precompiled</code>, you
should not have to compile anything. It'll just work!</p>
<p>This WAT file can be executed in <code>iex</code>:</p>
<pre><code class="language-elixir">Mix.install([:wasmex])
bytes = File.read!("gcd.wat")
{:ok, pid} = Wasmex.start_link(%{bytes: bytes}) # starts a GenServer running a WASM instance
Wasmex.call_function(pid, "gcd", [27, 6])
</code></pre>
<p>The last command should output:</p>
<pre><code class="language-elixir">iex(5)&gt; Wasmex.call_function(pid, "gcd", [27, 6])
{:ok, [3]}
</code></pre>
<p>If this is the output you see, congrats! You've successfully ran your first
WebAssembly code in Elixir!</p>
<h2 id="more-examples-and-contributing-4"><a class="header" href="#more-examples-and-contributing-4">More examples and contributing</a></h2>
<p>To learn more, check out an <a href="https://github.com/tessi/wasmex#example">another example</a>
and the <a href="https://hexdocs.pm/wasmex/Wasmex.html">API documentation</a>.
If you have any questions, do not hesitate to open an issue on the
<a href="https://github.com/tessi/wasmex">GitHub repository</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="further-examples"><a class="header" href="#further-examples">Further Examples</a></h1>
<p>The examples contained in this section explain how to use Wasmtime in several
common scenarios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-webassembly"><a class="header" href="#debugging-webassembly">Debugging WebAssembly</a></h1>
<p>Wasmtime currently provides the following support for debugging misbehaving
WebAssembly:</p>
<ul>
<li>
<p>We can <a href="./examples-debugging-native-debugger.html">live debug and step through the guest Wasm and the host at the same
time with <code>gdb</code> or <code>lldb</code>.</a></p>
</li>
<li>
<p>When a Wasm guest traps, we can <a href="./examples-debugging-core-dumps.html">generate Wasm core
dumps</a>, that can be consumed by other
tools for post-mortem analysis.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-with-gdb-and-lldb"><a class="header" href="#debugging-with-gdb-and-lldb">Debugging with <code>gdb</code> and <code>lldb</code></a></h1>
<p>The following steps describe how to use <code>gdb</code> or <code>lldb</code> to debug both the Wasm
guest and the host (i.e. the Wasmtime CLI or your Wasmtime-embedding program) at
the same time:</p>
<ol>
<li>
<p>Compile your WebAssembly with debug info enabled, usually <code>-g</code>; for
example:</p>
<pre><code class="language-sh">clang foo.c -g -o foo.wasm
</code></pre>
</li>
<li>
<p>Run Wasmtime with the debug info enabled; this is <code>-D debug-info</code> from the
CLI and <code>Config::debug_info(true)</code> in an embedding (e.g. see <a href="./examples-rust-debugging.html">debugging in a
Rust embedding</a>)</p>
</li>
<li>
<p>Use a supported debugger:</p>
<pre><code class="language-sh">lldb -- wasmtime run -D debug-info foo.wasm
</code></pre>
<pre><code class="language-sh">gdb --args wasmtime run -D debug-info foo.wasm
</code></pre>
</li>
</ol>
<p>If you run into trouble, the following discussions might help:</p>
<ul>
<li>
<p>On MacOS with LLDB you may need to run: <code>settings set plugin.jit-loader.gdb.enable on</code>
(<a href="https://github.com/bytecodealliance/wasmtime/issues/1953">#1953</a>)</p>
</li>
<li>
<p>With LLDB, call <code>__vmctx.set()</code> to set the current context before calling any
dereference operators
(<a href="https://github.com/bytecodealliance/wasmtime/issues/1482">#1482</a>):</p>
<pre><code class="language-sh">(lldb) p __vmctx-&gt;set()
(lldb) p *foo
</code></pre>
</li>
<li>
<p>The address of the start of instance memory can be found in <code>__vmctx-&gt;memory</code></p>
</li>
<li>
<p>On Windows you may experience degraded WASM compilation throughput due to the
enablement of additional native heap checks when under the debugger by default.
You can set the environment variable <code>_NO_DEBUG_HEAP</code> to <code>1</code> to disable them.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-webassembly-with-core-dumps"><a class="header" href="#debugging-webassembly-with-core-dumps">Debugging WebAssembly with Core Dumps</a></h1>
<p>Wasmtime can be configured to generate <a href="https://github.com/WebAssembly/tool-conventions/blob/main/Coredump.md">the standard Wasm core dump
format</a> whenever guest Wasm programs trap. These core dumps can then be
consumed by external tooling (such as <a href="https://github.com/xtuc/wasm-coredump/blob/main/bin/wasmgdb/README.md"><code>wasmgdb</code></a>) for post-mortem analysis.</p>
<p>This page focuses on generating and inspecting core dumps via the Wasmtime
command-line interface. For details on how to generate core dumps via the
<code>wasmtime</code> embedding API, see <a href="./examples-rust-core-dumps.html">Core Dumps in a Rust
Embedding</a>.</p>
<p>First, we need to compile some code to Wasm that can trap. Consider the
following Rust code:</p>
<pre><pre class="playground"><code class="language-rust no_run">// trap.rs

fn main() {
    foo(42);
}

fn foo(x: u32) {
    bar(x);
}

fn bar(x: u32) {
    baz(x);
}

fn baz(x: u32) {
    assert!(x != 42);
}</code></pre></pre>
<p>We can compile it to Wasm with the following command:</p>
<pre><code class="language-shell-session">$ rustc --target wasm32-wasi -o ./trap.wasm ./trap.rs
</code></pre>
<p>Next, we can run it in Wasmtime and capture a core dump when it traps:</p>
<pre><code class="language-shell-session">$ wasmtime -D coredump=./trap.coredump ./trap.wasm
thread 'main' panicked at /home/nick/scratch/trap.rs:14:5:
assertion failed: x != 42
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Error: failed to run main module `/home/nick/scratch/trap.wasm`

Caused by:
    0: core dumped at /home/nick/scratch/trap.coredump
    1: failed to invoke command default
    2: wasm coredump generated while executing store_name:
       modules:
         &lt;module&gt;
       instances:
         Instance(store=1, index=1)
       memories:
         Memory(store=1, index=1)
       globals:
         Global(store=1, index=0)
       backtrace:
       error while executing at wasm backtrace:
           0: 0x5961 - &lt;unknown&gt;!__rust_start_panic
           1: 0x562a - &lt;unknown&gt;!rust_panic
           2: 0x555d - &lt;unknown&gt;!std::panicking::rust_panic_with_hook::h58e7d0b3d70e95b6
           3: 0x485d - &lt;unknown&gt;!std::panicking::begin_panic_handler::{{closure}}::h1853004619879cfd
           4: 0x47bd - &lt;unknown&gt;!std::sys_common::backtrace::__rust_end_short_backtrace::hed32bc5557405634
           5: 0x4f02 - &lt;unknown&gt;!rust_begin_unwind
           6: 0xac01 - &lt;unknown&gt;!core::panicking::panic_fmt::h53ca5bf48b428895
           7: 0xb1c5 - &lt;unknown&gt;!core::panicking::panic::h62c2c2bb054da7e1
           8:  0x661 - &lt;unknown&gt;!trap::baz::h859f39b65389c077
           9:  0x616 - &lt;unknown&gt;!trap::bar::h7ad12f9c5b730d17
          10:  0x60a - &lt;unknown&gt;!trap::foo::ha69c95723611c1a0
          11:  0x5fe - &lt;unknown&gt;!trap::main::hdfcd9f2d150fc3dc
          12:  0x434 - &lt;unknown&gt;!core::ops::function::FnOnce::call_once::h24336e950fb97d1e
          13:  0x40b - &lt;unknown&gt;!std::sys_common::backtrace::__rust_begin_short_backtrace::h2b37384d2b1a57ff
          14:  0x4ec - &lt;unknown&gt;!std::rt::lang_start::{{closure}}::he86eb1b6ac6d7501
          15: 0x24f7 - &lt;unknown&gt;!std::rt::lang_start_internal::h21f6a1d8f3633b54
          16:  0x497 - &lt;unknown&gt;!std::rt::lang_start::h7d256f21902ff32b
          17:  0x687 - &lt;unknown&gt;!__main_void
          18:  0x3e6 - &lt;unknown&gt;!_start
       note: using the `WASMTIME_BACKTRACE_DETAILS=1` environment variable may show more debugging information
</code></pre>
<p>You now have a core dump at <code>./trap.coredump</code> that can be consumed by external
tooling to do post-mortem analysis of the failure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiling-webassembly"><a class="header" href="#profiling-webassembly">Profiling WebAssembly</a></h1>
<p>One of WebAssembly's major goals is to be quite close to native code in terms of
performance, so typically when executing Wasm you'll be quite interested in how
well your Wasm module is performing! From time to time you might want to dive a
bit deeper into the performance of your Wasm, and this is where profiling comes
into the picture.</p>
<p>For best results, ideally you'd use hardware performance counters for your
timing measurements. However, that requires special support from your CPU and
operating system. Because Wasmtime is a JIT, that also requires hooks from
Wasmtime to your platform's native profiling tools.</p>
<p>As a result, Wasmtime support for native profiling is limited to certain
platforms. See the following sections of this book if you're using these
platforms:</p>
<ul>
<li>
<p>On Linux, we support <a href="./examples-profiling-perf.html">perf</a>.</p>
</li>
<li>
<p>For Intel's x86 CPUs on Linux or Windows, we support
<a href="./examples-profiling-vtune.html">VTune</a>.</p>
</li>
<li>
<p>For Linux and macOS, we support <a href="./examples-profiling-samply.html">samply</a>.</p>
</li>
<li>
<p>For everything else, see the <a href="./examples-profiling-guest.html">cross-platform
profiler</a>.</p>
</li>
</ul>
<p>The native profilers can measure time spent in WebAssembly guest code as well as
time spent in the Wasmtime host and potentially even time spent in the kernel.
This provides a comprehensive view of performance.</p>
<p>The cross-platform-profiler can only measure time spent in WebAssembly guest
code, and its timing measurements are not as precise as the native profilers.
However, it works on every platform that Wasmtime supports.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-perf-on-linux"><a class="header" href="#using-perf-on-linux">Using <code>perf</code> on Linux</a></h1>
<p>One profiler supported by Wasmtime is the <a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code>
profiler</a> for Linux. This is
an extremely powerful profiler with lots of documentation on the web, but for
the rest of this section we'll assume you're running on Linux and already have
<code>perf</code> installed.</p>
<p>There are two profiling agents for <code>perf</code>:</p>
<ul>
<li>a very simple one that will map code regions to symbol names: <code>perfmap</code>.</li>
<li>a more detailed one that can provide additional information and mappings between the source
language statements and generated JIT code: <code>jitdump</code>.</li>
</ul>
<h2 id="profiling-with-perfmap"><a class="header" href="#profiling-with-perfmap">Profiling with <code>perfmap</code></a></h2>
<p>Simple profiling support with <code>perf</code> generates a "perf map" file that the <code>perf</code> CLI will
automatically look for, when running into unresolved symbols. This requires runtime support from
Wasmtime itself, so you will need to manually change a few things to enable profiling support in
your application. Enabling runtime support depends on how you're using Wasmtime:</p>
<ul>
<li>
<p><strong>Rust API</strong> - you'll want to call the [<code>Config::profiler</code>] method with
<code>ProfilingStrategy::PerfMap</code> to enable profiling of your wasm modules.</p>
</li>
<li>
<p><strong>C API</strong> - you'll want to call the <code>wasmtime_config_profiler_set</code> API with a
<code>WASMTIME_PROFILING_STRATEGY_PERFMAP</code> value.</p>
</li>
<li>
<p><strong>Command Line</strong> - you'll want to pass the <code>--profile=perfmap</code> flag on the command
line.</p>
</li>
</ul>
<p>Once perfmap support is enabled, you'll use <code>perf record</code> like usual to record
your application's performance.</p>
<p>For example if you're using the CLI, you'll execute:</p>
<pre><code class="language-sh">$ perf record -k mono wasmtime --profile=perfmap foo.wasm
</code></pre>
<p>This will create a <code>perf.data</code> file as per usual, but it will <em>also</em> create a
<code>/tmp/perf-XXXX.map</code> file. This extra <code>.map</code> file is the perf map file which is
specified by <code>perf</code> and Wasmtime generates at runtime.</p>
<p>After that you can explore the <code>perf.data</code> profile as you usually would, for example with:</p>
<pre><code class="language-sh">$ perf report --input perf.data
</code></pre>
<p>You should be able to see time spent in wasm functions, generate flamegraphs based on that, etc..
You should also see entries for wasm functions show up as one function and the name of each
function matches the debug name section in the wasm file.</p>
<p>Note that support for perfmap is still relatively new in Wasmtime, so if you
have any problems, please don't hesitate to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">file an issue</a>!</p>
<h2 id="profiling-with-jitdump"><a class="header" href="#profiling-with-jitdump">Profiling with <code>jitdump</code></a></h2>
<p>Profiling support with <code>perf</code> uses the "jitdump" support in the <code>perf</code> CLI. This
requires runtime support from Wasmtime itself, so you will need to manually
change a few things to enable profiling support in your application. First
you'll want to make sure that Wasmtime is compiled with the <code>jitdump</code> Cargo
feature (which is enabled by default). Otherwise enabling runtime support
depends on how you're using Wasmtime:</p>
<ul>
<li>
<p><strong>Rust API</strong> - you'll want to call the [<code>Config::profiler</code>] method with
<code>ProfilingStrategy::JitDump</code> to enable profiling of your wasm modules.</p>
</li>
<li>
<p><strong>C API</strong> - you'll want to call the <code>wasmtime_config_profiler_set</code> API with a
<code>WASMTIME_PROFILING_STRATEGY_JITDUMP</code> value.</p>
</li>
<li>
<p><strong>Command Line</strong> - you'll want to pass the <code>--profile=jitdump</code> flag on the command
line.</p>
</li>
</ul>
<p>Once jitdump support is enabled, you'll use <code>perf record</code> like usual to record
your application's performance. You'll need to also be sure to pass the
<code>--clockid mono</code> or <code>-k mono</code> flag to <code>perf record</code>.</p>
<p>For example if you're using the CLI, you'll execute:</p>
<pre><code class="language-sh">$ perf record -k mono wasmtime --profile=jitdump foo.wasm
</code></pre>
<p>This will create a <code>perf.data</code> file as per usual, but it will <em>also</em> create a
<code>jit-XXXX.dump</code> file. This extra <code>*.dump</code> file is the jitdump file which is
specified by <code>perf</code> and Wasmtime generates at runtime.</p>
<p>The next thing you need to do is to merge the <code>*.dump</code> file into the
<code>perf.data</code> file, which you can do with the <code>perf inject</code> command:</p>
<pre><code class="language-sh">$ perf inject --jit --input perf.data --output perf.jit.data
</code></pre>
<p>This will read <code>perf.data</code>, automatically pick up the <code>*.dump</code> file that's
correct, and then create <code>perf.jit.data</code> which merges all the JIT information
together. This should also create a lot of <code>jitted-XXXX-N.so</code> files in the
current directory which are ELF images for all the JIT functions that were
created by Wasmtime.</p>
<p>After that you can explore the <code>perf.jit.data</code> profile as you usually would,
for example with:</p>
<pre><code class="language-sh">$ perf report --input perf.jit.data
</code></pre>
<p>You should be able to annotate wasm functions and see their raw assembly. You
should also see entries for wasm functions show up as one function and the
name of each function matches the debug name section in the wasm file.</p>
<p>Note that support for jitdump is still relatively new in Wasmtime, so if you
have any problems, please don't hesitate to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">file an issue</a>!</p>
<h3 id="perf-and-dwarf-information"><a class="header" href="#perf-and-dwarf-information"><code>perf</code> and DWARF information</a></h3>
<p>If the jitdump profile doesn't give you enough information by default, you can
also enable dwarf debug information to be generated for JIT code which should
give the <code>perf</code> profiler more information about what's being profiled. This can
include information like more descriptive function names, filenames, and line
numbers.</p>
<p>Enabling dwarf debug information for JIT code depends on how you're using
Wasmtime:</p>
<ul>
<li>
<p><strong>Rust API</strong> - you'll want to call the <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.debug_info"><code>Config::debug_info</code></a> method.</p>
</li>
<li>
<p><strong>C API</strong> - you'll want to call the <code>wasmtime_config_debug_info_set</code> API.</p>
</li>
<li>
<p><strong>Command Line</strong> - you'll want to pass the <code>-g</code> flag on the command line.</p>
</li>
</ul>
<p>You shouldn't need to do anything else to get this information into <code>perf</code>. The
perf collection data should automatically pick up all this dwarf debug
information.</p>
<h3 id="perf-example"><a class="header" href="#perf-example"><code>perf</code> example</a></h3>
<p>Let's run through a quick example with <code>perf</code> to get the feel for things. First
let's take a look at some wasm:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let n = 42;
    println!("fib({}) = {}", n, fib(n));
}

fn fib(n: u32) -&gt; u32 {
    if n &lt;= 2 {
        1
    } else {
        fib(n - 1) + fib(n - 2)
    }
}</code></pre></pre>
<p>To collect perf information for this wasm module we'll execute:</p>
<pre><code class="language-sh">$ rustc --target wasm32-wasi fib.rs -O
$ perf record -k mono wasmtime --profile=jitdump fib.wasm
fib(42) = 267914296
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.147 MB perf.data (3435 samples) ]
$ perf inject --jit --input perf.data --output perf.jit.data
</code></pre>
<p>And we should have all our information now! We can execute <code>perf report</code> for
example to see that 99% of our runtime (as expected) is spent in our <code>fib</code>
function. Note that the symbol has been demangled to <code>fib::fib</code> which is what
the Rust symbol is:</p>
<pre><code class="language-sh">$ perf report --input perf.jit.data
</code></pre>
<p><img src="assets/perf-report-fib.png" alt="perf report output" /></p>
<p>Alternatively we could also use <code>perf annotate</code> to take a look at the
disassembly of the <code>fib</code> function, seeing what the JIT generated:</p>
<pre><code class="language-sh">$ perf annotate --input perf.jit.data
</code></pre>
<p><img src="assets/perf-annotate-fib.png" alt="perf annotate output" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-vtune"><a class="header" href="#using-vtune">Using <code>VTune</code></a></h1>
<p><a href="https://software.intel.com/en-us/vtune-help">VTune</a> is a popular performance profiling tool that targets both 32-bit
and 64-bit x86 architectures. The tool collects profiling data during runtime
and then, either through the command line or GUI, provides a variety of options
for viewing and analyzing that data. VTune Profiler is available in both
commercial and free options. The free, downloadable version is available
<a href="https://software.intel.com/en-us/vtune/choose-download#standalone">here</a> and is backed by a community forum for support. This version is
appropriate for detailed analysis of your Wasm program.</p>
<p>VTune support in Wasmtime is provided through the JIT profiling APIs from the
<a href="https://github.com/intel/ittapi"><code>ittapi</code></a> library. This library provides code generators (or the runtimes that
use them) a way to report JIT activities. The APIs are implemented in a static
library (see <a href="https://github.com/intel/ittapi"><code>ittapi</code></a> source) which Wasmtime links to when VTune support is
specified through the <code>vtune</code> Cargo feature flag; this feature is not enabled by
default. When the VTune collector is run, the <code>ittapi</code> library collects
Wasmtime's reported JIT activities. This connection to <code>ittapi</code> is provided by
the <a href="https://crates.io/crates/ittapi-rs"><code>ittapi-rs</code></a> crate.</p>
<p>For more information on VTune and the analysis tools it provides see its
<a href="https://software.intel.com/en-us/vtune-help">documentation</a>.</p>
<h3 id="turn-on-vtune-support"><a class="header" href="#turn-on-vtune-support">Turn on VTune support</a></h3>
<p>For JIT profiling with VTune, Wasmtime currently builds with the <code>vtune</code> feature
enabled by default. This ensures the compiled binary understands how to inform
the <code>ittapi</code> library of JIT events. But it must still be enabled at
runtime--enable runtime support based on how you use Wasmtime:</p>
<ul>
<li>
<p><strong>Rust API</strong> - call the [<code>Config::profiler</code>] method with
<code>ProfilingStrategy::VTune</code> to enable profiling of your wasm modules.</p>
</li>
<li>
<p><strong>C API</strong> - call the <code>wasmtime_config_profiler_set</code> API with a
<code>WASMTIME_PROFILING_STRATEGY_VTUNE</code> value.</p>
</li>
<li>
<p><strong>Command Line</strong> - pass the <code>--profile=vtune</code> flag on the command line.</p>
</li>
</ul>
<h3 id="profiling-wasmtime-itself"><a class="header" href="#profiling-wasmtime-itself">Profiling Wasmtime itself</a></h3>
<p>Note that VTune is capable of profiling a single process or all system
processes. Like <code>perf</code>, VTune is capable of profiling the Wasmtime runtime
itself without any added support. However, the <a href="https://github.com/intel/ittapi"><code>ittapi</code></a> APIs also provide an
interface for marking the start and stop of code regions for easy isolation in
the VTune Profiler. Support for these APIs is expected to be added in the
future.</p>
<h3 id="example-getting-started"><a class="header" href="#example-getting-started">Example: Getting Started</a></h3>
<p>With VTune <a href="https://software.intel.com/en-us/vtune/choose-download#standalone">properly installed</a>, if you are using the CLI execute:</p>
<pre><code class="language-sh">$ cargo build
$ vtune -run-pass-thru=--no-altstack -collect hotspots target/debug/wasmtime --profile=vtune foo.wasm
</code></pre>
<p>This command tells the VTune collector (<code>vtune</code>) to collect hot spot
profiling data as Wasmtime is executing <code>foo.wasm</code>. The <code>--profile=vtune</code> flag enables
VTune support in Wasmtime so that the collector is also alerted to JIT events
that take place during runtime. The first time this is run, the result of the
command is a results directory <code>r000hs/</code> which contains profiling data for
Wasmtime and the execution of <code>foo.wasm</code>. This data can then be read and
displayed via the command line or via the VTune GUI by importing the result.</p>
<h3 id="example-cli-collection"><a class="header" href="#example-cli-collection">Example: CLI Collection</a></h3>
<p>Using a familiar algorithm, we'll start with the following Rust code:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let n = 45;
    println!("fib({}) = {}", n, fib(n));
}

fn fib(n: u32) -&gt; u32 {
    if n &lt;= 2 {
        1
    } else {
        fib(n - 1) + fib(n - 2)
    }
}</code></pre></pre>
<p>We compile the example to Wasm:</p>
<pre><code class="language-sh">$ rustc --target wasm32-wasi fib.rs -C opt-level=z -C lto=yes
</code></pre>
<p>Then we execute the Wasmtime runtime (built with the <code>vtune</code> feature and
executed with the <code>--profile=vtune</code> flag to enable reporting) inside the VTune CLI
application, <code>vtune</code>, which must already be installed and available on the
path. To collect hot spot profiling information, we execute:</p>
<pre><code class="language-sh">$ rustc --target wasm32-wasi fib.rs -C opt-level=z -C lto=yes
$ vtune -run-pass-thru=--no-altstack -v -collect hotspots target/debug/wasmtime --profile=vtune fib.wasm
fib(45) = 1134903170
amplxe: Collection stopped.
amplxe: Using result path /home/jlb6740/wasmtime/r000hs
amplxe: Executing actions  7 % Clearing the database
amplxe: The database has been cleared, elapsed time is 0.239 seconds.
amplxe: Executing actions 14 % Updating precomputed scalar metrics
amplxe: Raw data has been loaded to the database, elapsed time is 0.792 seconds.
amplxe: Executing actions 19 % Processing profile metrics and debug information
...
Top Hotspots
Function                                                                                      Module          CPU Time
--------------------------------------------------------------------------------------------  --------------  --------
h2bacf53cb3845acf                                                                             [Dynamic code]    3.480s
__memmove_avx_unaligned_erms                                                                  libc.so.6         0.222s
cranelift_codegen::ir::instructions::InstructionData::opcode::hee6f5b6a72fc684e               wasmtime          0.122s
core::ptr::slice_from_raw_parts::hc5cb6f1b39a0e7a1                                            wasmtime          0.066s
_$LT$usize$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$::get::h70c7f142eeeee8bd  wasmtime          0.066s
</code></pre>
<h3 id="example-importing-results-into-gui"><a class="header" href="#example-importing-results-into-gui">Example: Importing Results into GUI</a></h3>
<p>Results directories created by the <code>vtune</code> CLI can be imported in the VTune GUI
by clicking "Open &gt; Result". Below is a visualization of the collected data as
seen in VTune's GUI:</p>
<p><img src="assets/vtune-gui-fib.png" alt="vtune report output" /></p>
<h3 id="example-gui-collection"><a class="header" href="#example-gui-collection">Example: GUI Collection</a></h3>
<p>VTune can collect data in multiple ways (see <code>vtune</code> CLI discussion above);
another way is to use the VTune GUI directly. A standard work flow might look
like:</p>
<ul>
<li>Open VTune Profiler</li>
<li>"Configure Analysis" with
<ul>
<li>"Application" set to <code>/path/to/wasmtime</code> (e.g., <code>target/debug/wasmtime</code>)</li>
<li>"Application parameters" set to <code>--profile=vtune /path/to/module.wasm</code></li>
<li>"Working directory" set as appropriate</li>
<li>Enable "Hardware Event-Based Sampling," which may require some system
configuration, e.g. <code>sysctl -w kernel.perf_event_paranoid=0</code></li>
</ul>
</li>
<li>Start the analysis</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-samply-on-linuxmacos"><a class="header" href="#using-samply-on-linuxmacos">Using <code>samply</code> on Linux/macOS</a></h1>
<p>One profiler supported by Wasmtime is <a href="https://github.com/mstange/samply"><code>samply</code></a> for Linux and macOS. As of 17th July 2023, the
latest version of samply (on crates.io) is 0.11.0 which does not seem to support perfmaps. To use this, you either need a
newer version of samply, if by the time you read this, a newer version has been released, or you can build samply from source.</p>
<h2 id="profiling-with-perfmap-1"><a class="header" href="#profiling-with-perfmap-1">Profiling with <code>perfmap</code></a></h2>
<p>Simple profiling support with <code>samply</code> generates a "perfmap" file that the <code>samply</code> CLI will
automatically look for, when running into unresolved symbols. This requires runtime support from
Wasmtime itself, so you will need to manually change a few things to enable profiling support in
your application. Enabling runtime support depends on how you're using Wasmtime:</p>
<ul>
<li>
<p><strong>Rust API</strong> - you'll want to call the [<code>Config::profiler</code>] method with
<code>ProfilingStrategy::PerfMap</code> to enable profiling of your wasm modules.</p>
</li>
<li>
<p><strong>C API</strong> - you'll want to call the <code>wasmtime_config_profiler_set</code> API with a
<code>WASMTIME_PROFILING_STRATEGY_PERFMAP</code> value.</p>
</li>
<li>
<p><strong>Command Line</strong> - you'll want to pass the <code>--profile=perfmap</code> flag on the command
line.</p>
</li>
</ul>
<p>Once perfmap support is enabled, you'll use <code>samply record</code> like usual to record
your application's performance.</p>
<p>For example if you're using the CLI, you'll execute:</p>
<pre><code class="language-sh">$ samply record wasmtime --profile=perfmap foo.wasm
</code></pre>
<p>This will record your application's performance and open the Firefox profiler UI to view the
results. It will also dump its own profile data to a json file (called <code>profile.json</code>) in the current directory.</p>
<p>Note that support for perfmap is still relatively new in Wasmtime, so if you
have any problems, please don't hesitate to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">file an issue</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-wasmtimes-cross-platform-profiler"><a class="header" href="#using-wasmtimes-cross-platform-profiler">Using Wasmtime's cross-platform profiler</a></h1>
<p>The guest profiling strategy enables in-process sampling and will write the
captured profile to a file which can be viewed at
<a href="https://profiler.firefox.com/">https://profiler.firefox.com/</a>.</p>
<p>To use this profiler with the Wasmtime CLI, pass the
<code>--profile=guest[,path[,interval]]</code> flag.</p>
<ul>
<li><code>path</code> is where to write the profile, <code>wasmtime-guest-profile.json</code> by default</li>
<li><code>interval</code> is the duration between samples, 10ms by default</li>
</ul>
<p>When used with <code>-W timeout=N</code>, the timeout will be rounded up to the nearest
multiple of the profiling interval.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-memcheck-wmemcheck"><a class="header" href="#wasm-memcheck-wmemcheck">Wasm memcheck (wmemcheck)</a></h1>
<p>wmemcheck provides the ability to check for invalid mallocs, reads, and writes
inside a Wasm module, as long as Wasmtime is able to make certain assumptions
(<code>malloc</code> and <code>free</code> functions are visible and your program uses only the
default allocator). This is analogous to the Valgrind tool's memory checker
(memcheck) tool for native programs.</p>
<p>How to use:</p>
<ol>
<li>When building Wasmtime, add the CLI flag "--features wmemcheck" to compile with wmemcheck configured.
<blockquote>
<p>cargo build --features wmemcheck</p>
</blockquote>
</li>
<li>When running your wasm module, add the CLI flag "--wmemcheck".
<blockquote>
<p>wasmtime run --wmemcheck test.wasm</p>
</blockquote>
</li>
</ol>
<p>If your program executes an invalid operation (load or store to non-allocated
address, double-free, or an internal error in malloc that allocates the same
memory twice) you will see an error that looks like a Wasm trap. For example, given the program</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int main() {
    char* p = malloc(1024);
    *p = 0;
    free(p);
    *p = 0;
}
</code></pre>
<p>compiled with WASI-SDK via</p>
<pre><code class="language-plain">$ /opt/wasi-sdk/bin/clang -o test.wasm test.c
</code></pre>
<p>you can observe the memory checker working like so:</p>
<pre><code class="language-plain">$ wasmtime run --wmemcheck ./test.wasm
Error: failed to run main module `./test.wasm`

Caused by:
    0: failed to invoke command default
    1: error while executing at wasm backtrace:
           0:  0x103 - &lt;unknown&gt;!__original_main
           1:   0x87 - &lt;unknown&gt;!_start
           2: 0x2449 - &lt;unknown&gt;!_start.command_export
    2: Invalid store at addr 0x10610 of size 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-minimal-wasmtime-embedding"><a class="header" href="#building-a-minimal-wasmtime-embedding">Building a Minimal Wasmtime embedding</a></h1>
<p>Wasmtime embeddings may wish to optimize for binary size and runtime footprint
to fit on a small system. This documentation is intended to guide some features
of Wasmtime and how to best produce a minimal build of Wasmtime.</p>
<h2 id="building-a-minimal-cli"><a class="header" href="#building-a-minimal-cli">Building a minimal CLI</a></h2>
<blockquote>
<p><em>Note</em>: the exact numbers in this section were last updated on 2023-10-18 on a
macOS aarch64 host. For up-to-date numbers consult the artifacts in the <a href="https://github.com/bytecodealliance/wasmtime/releases/tag/dev"><code>dev</code>
release of Wasmtime</a> where the <code>wasmtime-min</code> executable represents the
culmination of these steps.</p>
</blockquote>
<p>Many Wasmtime embeddings go through the <code>wasmtime</code> crate as opposed to the
<code>wasmtime</code> CLI executable, but to start out let's take a look at minimizing the
command line executable. By default the wasmtime command line executable is
relatively large:</p>
<pre><code class="language-shell">$ cargo build
$ ls -l ./target/debug/wasmtime
-rwxr-xr-x@ 1 root  root    140M Oct 18 08:33 target/debug/wasmtime
</code></pre>
<p>The easiest size optimization is to compile with optimizations. This will strip
lots of dead code and additionally generate much less debug information by
default</p>
<pre><code class="language-shell">$ cargo build --release
$ ls -l ./target/release/wasmtime
-rwxr-xr-x@ 1 root  root     33M Oct 18 08:34 target/release/wasmtime
</code></pre>
<p>Much better, but still relatively large! The next thing that can be done is to
disable the default features of the <code>wasmtime-cli</code> crate. This will remove all
optional functionality from the crate and strip it down to the bare bones
functionality. Note though that <code>run</code> is included to keep the ability to run
precompiled WebAssembly files as otherwise the CLI doesn't have any
functionality which isn't too useful.</p>
<pre><code class="language-shell">$ cargo build --release --no-default-features --features run
$ ls -l ./target/release/wasmtime
-rwxr-xr-x@ 1 root  root    6.7M Oct 18 08:37 target/release/wasmtime
</code></pre>
<p>Note that this executable is stripped to the bare minimum of functionality which
notably means it does not have a compiler for WebAssembly files. This means that
<code>wasmtime compile</code> is no longer supported meaning that <code>*.cwasm</code> files must be
fed to <code>wasmtime run</code> to execute files. Additionally error messages will be
worse in this mode as less contextual information is provided.</p>
<p>The final Wasmtime-specific optimization you can apply is to disable logging
statements. Wasmtime and its dependencies make use of the <a href="https://docs.rs/log"><code>log</code>
crate</a> and <a href="https://docs.rs/tracing"><code>tracing</code> crate</a> for
debugging and diagnosing. For a minimal build this isn't needed though so this
can all be disabled through Cargo features to shave off a small amount of code.
Note that for custom embeddings you'd need to replicate the <code>disable-logging</code>
feature which sets the <code>max_level_off</code> feature for the <code>log</code> and <code>tracing</code>
crate.</p>
<pre><code class="language-shell">$ cargo build --release --no-default-features --features run,disable-logging
$ ls -l ./target/release/wasmtime
-rwxr-xr-x@ 1 root  root    6.7M Oct 18 08:37 target/release/wasmtime
</code></pre>
<p>At this point the next line of tricks to apply to minimize binary size are
<a href="https://github.com/johnthagen/min-sized-rust">general tricks-of-the-trade for Rust
programs</a> and are no longer
specific to Wasmtime. For example the first thing that can be done is to
optimize for size rather than speed via rustc's <code>s</code> optimization level.
This uses Cargo's <a href="https://doc.rust-lang.org/cargo/reference/config.html#profile">environment-variable based configuration</a>
via the <code>CARGO_PROFILE_RELEASE_OPT_LEVEL=s</code> environment variable to configure
this.</p>
<pre><code class="language-shell">$ export CARGO_PROFILE_RELEASE_OPT_LEVEL=s
$ cargo build --release --no-default-features --features run,disable-logging
$ ls -l ./target/release/wasmtime
-rwxr-xr-x@ 1 root  root    6.8M Oct 18 08:40 target/release/wasmtime
</code></pre>
<p>Note that the size has increased here slightly instead of going down. Optimizing
for speed-vs-size can affect a number of heuristics in LLVM so it's best to test
out locally what's best for your embedding. Further examples below continue to
pass this flag since by the end it will produce a smaller binary than the
default optimization level of "3" for release mode. You may wish to also try an
optimization level of "2" and see which produces a smaller build for you.</p>
<p>After optimizations levels the next compilation setting to configure is
Rust's "panic=abort" mode where panics translate to process aborts rather than
unwinding. This removes landing pads from code as well as unwind tables from the
executable.</p>
<pre><code class="language-shell">$ export CARGO_PROFILE_RELEASE_OPT_LEVEL=s
$ export CARGO_PROFILE_RELEASE_PANIC=abort
$ cargo build --release --no-default-features --features run,disable-logging
$ ls -l ./target/release/wasmtime
-rwxr-xr-x@ 1 root  root    5.0M Oct 18 08:40 target/release/wasmtime
</code></pre>
<p>Next, if the compile time hit is acceptable, LTO can be enabled to provide
deeper opportunities for compiler optimizations to remove dead code and
deduplicate. Do note that this will take a significantly longer amount of time
to compile than previously. Here LTO is configured with
<code>CARGO_PROFILE_RELEASE_LTO=true</code>.</p>
<pre><code class="language-shell">$ export CARGO_PROFILE_RELEASE_OPT_LEVEL=s
$ export CARGO_PROFILE_RELEASE_PANIC=abort
$ export CARGO_PROFILE_RELEASE_LTO=true
$ cargo build --release --no-default-features --features run,disable-logging
$ ls -l ./target/release/wasmtime
-rwxr-xr-x@ 1 root  root    3.3M Oct 18 08:42 target/release/wasmtime
</code></pre>
<p>Similar to LTO above rustc can be further instructed to place all crates into
their own single object file instead of multiple by default. This again
increases compile times. Here that's done with
<code>CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1</code>.</p>
<pre><code class="language-shell">$ export CARGO_PROFILE_RELEASE_OPT_LEVEL=s
$ export CARGO_PROFILE_RELEASE_PANIC=abort
$ export CARGO_PROFILE_RELEASE_LTO=true
$ export CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1
$ cargo build --release --no-default-features --features run,disable-logging
$ ls -l ./target/release/wasmtime
-rwxr-xr-x@ 1 root  root    3.3M Oct 18 08:43 target/release/wasmtime
</code></pre>
<p>Note that with LTO using a single codegen unit may only have marginal benefit.
If not using LTO, however, a single codegen unit will likely provide benefit
over the default 16 codegen units.</p>
<p>One final flag before getting to nightly features is to strip debug information
from the standard library. In <code>--release</code> mode Cargo by default doesn't generate
debug information for local crates, but the Rust standard library may have debug
information still included with it. This is configured via
<code>CARGO_PROFILE_RELEASE_STRIP=debuginfo</code></p>
<pre><code class="language-shell">$ export CARGO_PROFILE_RELEASE_OPT_LEVEL=s
$ export CARGO_PROFILE_RELEASE_PANIC=abort
$ export CARGO_PROFILE_RELEASE_LTO=true
$ export CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1
$ export CARGO_PROFILE_RELEASE_STRIP=debuginfo
$ cargo build --release --no-default-features --features run,disable-logging
$ ls -l ./target/release/wasmtime
-rwxr-xr-x@ 1 root  root    2.4M Oct 18 08:44 target/release/wasmtime
</code></pre>
<p>Next, if your use case allows it, the Nightly Rust toolchain provides a number
of other options to minimize the size of binaries. Note the usage of <code>+nightly</code> here
to the <code>cargo</code> command to use a Nightly toolchain (assuming your local toolchain
is installed with rustup). Also note that due to the nature of nightly the exact
flags here may not work in the future. Please open an issue with Wasmtime if
these commands don't work and we'll update the documentation.</p>
<p>The first nightly feature we can leverage is to remove filename and line number
information in panics with <code>-Zlocation-detail=none</code></p>
<pre><code class="language-shell">$ export CARGO_PROFILE_RELEASE_OPT_LEVEL=s
$ export CARGO_PROFILE_RELEASE_PANIC=abort
$ export CARGO_PROFILE_RELEASE_LTO=true
$ export CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1
$ export CARGO_PROFILE_RELEASE_STRIP=debuginfo
$ export RUSTFLAGS="-Zlocation-detail=none"
$ cargo +nightly build --release --no-default-features --features run,disable-logging
$ ls -l ./target/release/wasmtime
-rwxr-xr-x@ 1 root  root    2.4M Oct 18 08:43 target/release/wasmtime
</code></pre>
<p>Further along the line of nightly features the next optimization will recompile
the standard library without unwinding information, trimming out a bit more from
the standard library. This uses the <code>-Zbuild-std</code> flag to Cargo. Note that this
additionally requires <code>--target</code> as well which will need to be configured for
your particular platform.</p>
<pre><code class="language-shell">$ export CARGO_PROFILE_RELEASE_OPT_LEVEL=s
$ export CARGO_PROFILE_RELEASE_PANIC=abort
$ export CARGO_PROFILE_RELEASE_LTO=true
$ export CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1
$ export CARGO_PROFILE_RELEASE_STRIP=debuginfo
$ export RUSTFLAGS="-Zlocation-detail=none"
$ cargo +nightly build --release --no-default-features --features run,disable-logging \
    -Z build-std=std,panic_abort --target aarch64-apple-darwin
$ ls -l ./target/aarch64-apple-darwin/release/wasmtime
-rwxr-xr-x@ 1 root  root    2.3M Oct 18 09:39 target/aarch64-apple-darwin/release/wasmtime
</code></pre>
<p>Next the Rust standard library has some optional features in addition to
Wasmtime, such as printing of backtraces. This may not be required in minimal
environments so the features of the standard library can be disabled with the
<code>-Zbuild-std-features=</code> flag which configures the set of enabled features to be
empty.</p>
<pre><code class="language-shell">$ export CARGO_PROFILE_RELEASE_OPT_LEVEL=s
$ export CARGO_PROFILE_RELEASE_PANIC=abort
$ export CARGO_PROFILE_RELEASE_LTO=true
$ export CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1
$ export CARGO_PROFILE_RELEASE_STRIP=debuginfo
$ export RUSTFLAGS="-Zlocation-detail=none"
$ cargo +nightly build --release --no-default-features --features run,disable-logging \
    -Z build-std=std,panic_abort --target aarch64-apple-darwin \
    -Z build-std-features=
$ ls -l ./target/aarch64-apple-darwin/release/wasmtime
-rwxr-xr-x@ 1 root  root    2.1M Oct 18 09:39 target/aarch64-apple-darwin/release/wasmtime
</code></pre>
<h2 id="minimizing-further"><a class="header" href="#minimizing-further">Minimizing further</a></h2>
<p>Above shows an example of taking the default <code>cargo build</code> result of 130M down
to a 2.1M binary for the <code>wasmtime</code> executable. Similar steps can be done to
reduce the size of the C API binary artifact as well which currently produces a
~2.8M dynamic library. This is currently the smallest size with the source code
as-is, but there are more size reductions which haven't been implemented yet.</p>
<p>This is a listing of some example sources of binary size. Some sources of binary
size may not apply to custom embeddings since, for example, your custom
embedding might already not use WASI and might already not be included.</p>
<ul>
<li>
<p>WASI in the Wasmtime CLI - currently the CLI includes all of WASI. This
includes two separate implementations of WASI - one for preview2 and one for
preview1. This accounts for 1M+ of space which is a significant chunk of the
remaining 2.1M.  While removing just preview2 or preview1 would be easy enough
with a Cargo feature, the resulting executable wouldn't be able to do
anything. Something like a <a href="https://github.com/bytecodealliance/wasmtime/issues/7348">plugin feature for the
CLI</a>, however, would
enable removing WASI while still being a usable executable.</p>
</li>
<li>
<p>Argument parsing in the Wasmtime CLI - as a command line executable <code>wasmtime</code>
contains parsing of command line arguments which currently uses the <code>clap</code>
crate. This contributes ~200k of binary size to the final executable which
would likely not be present in a custom embedding of Wasmtime. While this
can't be removed from Wasmtime it's something to consider when evaluating the
size of CI artifacts.</p>
</li>
<li>
<p>Cranelift in the C API - one of the features of Wasmtime is the ability to
have a runtime without Cranelift that only supports precompiled (AOT) wasm
modules. It's <a href="https://github.com/bytecodealliance/wasmtime/issues/7349">not possible to build the C API without
Cranelift</a> though
because defining host functions requires Cranelift at this time to emit some
stubs.  This means that the C API is significantly larger than a custom Rust
embedding which doesn't suffer from the same restriction. This means that
while it's still possible to build an embedding of Wasmtime which doesn't have
Cranelift it's not easy to see what it might look like size-wise from
looking at the C API artifacts.</p>
</li>
<li>
<p>Formatting strings in Wasmtime - Wasmtime makes extensive use of formatting
strings for error messages and other purposes throughout the implementation.
Most of this is intended for debugging and understanding more when something
goes wrong, but much of this is not necessary for a truly minimal embedding.
In theory much of this could be conditionally compiled out of the Wasmtime
project to produce a smaller executable. Just how much of the final binary
size is accounted for by formatting string is unknown, but it's well known in
Rust that <code>std::fmt</code> is not the slimmest of modules.</p>
</li>
<li>
<p>Cranelift vs Winch - the "min" builds on CI try to exclude Cranelift from
their binary footprint (e.g. the CLI excludes it) but this comes at a cost of
the final executable not supporting compilation of wasm modules. If this is
required then no effort has yet been put into minimizing the code size of
Cranelift itself. One possible tradeoff that can be made though is to choose
between the Winch baseline compiler vs Cranelift. Winch should be much smaller
from a compiled footprint point of view while not sacrificing everything in
terms of performance. Note though that Winch is still under development.</p>
</li>
</ul>
<p>Above are some future avenues to take in terms of reducing the binary size of
Wasmtime and various tradeoffs that can be made. The Wasmtime project is eager
to hear embedder use cases/profiles if Wasmtime is not suitable for binary size
reasons today. Please feel free to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">open an
issue</a> and let us know
and we'd be happy to discuss more how best to handle a particular use case.</p>
<h1 id="building-wasmtime-for-a-custom-platform"><a class="header" href="#building-wasmtime-for-a-custom-platform">Building Wasmtime for a Custom Platform</a></h1>
<p>If you're not running on a built-in supported platform such as Windows, macOS,
or Linux, then Wasmtime won't work out-of-the-box for you. Wasmtime includes a
compilation mode, however, that enables you to define how to work with the
platform externally.</p>
<p>This mode is enabled when <code>--cfg wasmtime_custom_platform</code> is passed to rustc,
via <code>RUSTFLAGS</code> for example when building through Cargo, when an existing
platform is not matched. This means that with this configuration Wasmtime may be
compiled for custom or previously unknown targets.</p>
<p>Wasmtime's current "platform embedding API" which is required to operate is
defined at <code>examples/min-platform/embedding/wasmtime-platform.h</code>. That directory
additionally has an example of building a minimal <code>*.so</code> on Linux which has the
platform API implemented in C using Linux syscalls. While a bit contrived it
effectively shows a minimal Wasmtime embedding which has no dependencies other
than the platform API.</p>
<p>Building Wasmtime for a custom platform is not a turnkey process right now,
there are a number of points that need to be considered:</p>
<ul>
<li>
<p>For a truly custom platform you'll probably want to create a <a href="https://docs.rust-embedded.org/embedonomicon/custom-target.html">custom Rust
target</a>. This
means that Nightly Rust will be required.</p>
</li>
<li>
<p>Wasmtime and its dependencies require the Rust standard library <code>std</code> to be
available. The Rust standard library can be compiled for any target with
unsupported functionality being stubbed out. This mode of compiling the Rust
standard library is not stable, however. Currently this is done through the
<code>-Zbuild-std</code> argument to Cargo along with a
<code>+RUSTC_BOOTSTRAP_SYNTHETIC_TARGET=1</code> environment variable.</p>
</li>
<li>
<p>Wasmtime additionally depends on the availability of a memory allocator (e.g.
<code>malloc</code>). Wasmtime assumes that failed memory allocation aborts the process.</p>
</li>
<li>
<p>Not all features for Wasmtime can be built for custom targets. For example
WASI support does not work on custom targets. When building Wasmtime you'll
probably want <code>--no-default-features</code> and will then want to incrementally add
features back in as needed.</p>
</li>
</ul>
<p>The <code>examples/min-platform</code> directory has an example of building this minimal
embedding and some necessary steps. Combined with the above features about
producing a minimal build currently produces a 400K library on Linux.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stability"><a class="header" href="#stability">Stability</a></h1>
<p>... more coming soon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-process"><a class="header" href="#release-process">Release Process</a></h1>
<p>Wasmtime's release process was <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-one-dot-oh.md">originally designed in an RFC</a> and this
page is intended to serve as documentation for the current process as-is today.
The high-level summary of Wasmtime's release process is:</p>
<ul>
<li>A new major version of Wasmtime will be made available once a month.</li>
<li>Security bugs and correctness fixes will be backported to the latest two
releases of Wasmtime and issued as patch releases.</li>
</ul>
<p>Once a month Wasmtime will issue a new major version. This will be issued with a
semver-major version update, such as 4.0.0 to 5.0.0. The precise schedule of
Wasmtime's release is currently an automated PR is sent to bump the version on
the 5th of every month and a release is made when the PR is merged. The PR
typically gets merged within a few days.</p>
<p>Each major release of Wasmtime reserves the right to break both behavior and API
backwards-compatibility. This is not expected to happen frequently, however, and
any breaking change will follow these criteria:</p>
<ul>
<li>
<p>Minor breaking changes, either behavior or with APIs, will be documented in
the <code>RELEASES.md</code> release notes. Minor changes will require some degree of
consensus but are not required to go through the entire RFC process.</p>
</li>
<li>
<p>Major breaking changes, such as major refactorings to the API, will be
required to go through the <a href="https://github.com/bytecodealliance/rfcs">RFC process</a>. These changes are intended to be
broadly communicated to those interested and provides an opportunity to give
feedback about embeddings. Release notes will clearly indicate if any major
breaking changes through accepted RFCs are included in a release.</p>
</li>
</ul>
<p>Patch releases of Wasmtime will only be issued for security and critical
correctness issues for on-by-default behavior in the previous releases. If
Wasmtime is currently at version 5.0.0 then 5.0.1 and 4.0.1 will be issued as
patch releases if a bug is found. Patch releases are guaranteed to maintain API
and behavior backwards-compatibility and are intended to be trivial for users to
upgrade to.</p>
<p>Patch releases for Cranelift will be made for any miscompilations found by
Cranelift, even those that Wasmtime itself may not exercise. Due to the current
release process a patch release for Cranelift will issue a patch release for
Wasmtime as well.</p>
<h2 id="whats-released"><a class="header" href="#whats-released">What's released?</a></h2>
<p>At this time the release process of Wasmtime encompasses:</p>
<ul>
<li>The <code>wasmtime</code> Rust crate</li>
<li>The C API of Wasmtime</li>
<li>The <code>wasmtime</code> CLI tool through the <code>wasmtime-cli</code> Rust crate</li>
</ul>
<p>Other projects maintained by the Bytecode Alliance will also likely be released,
with the same version numbers, with the main Wasmtime project soon after a
release is made, such as:</p>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime-dotnet"><code>wasmtime-dotnet</code></a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime-py"><code>wasmtime-py</code></a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime-go"><code>wasmtime-go</code></a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime-cpp"><code>wasmtime-cpp</code></a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime-rb"><code>wasmtime-rb</code></a></li>
</ul>
<p>Note, though, that bugs and security issues in these projects do not at this
time warrant patch releases for Wasmtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tiers-of-support-in-wasmtime"><a class="header" href="#tiers-of-support-in-wasmtime">Tiers of Support in Wasmtime</a></h1>
<p>Wasmtime's support for platforms and features can be distinguished with three
different tiers of support. The description of these tiers are intended to be
inspired by the <a href="https://doc.rust-lang.org/rustc/target-tier-policy.html">Rust compiler's support tiers for
targets</a> but are
additionally tailored for Wasmtime. Wasmtime's tiered support additionally
applies not only to platforms/targets themselves but additionally features
implemented within Wasmtime itself.</p>
<p>The purpose of this document is to provide a means by which to evaluate the
inclusion of new features and support for existing features within Wasmtime.
This should not be used to "lawyer" a change into Wasmtime on a precise
technical detail or similar since this document is itself not 100% precise and
will change over time.</p>
<h2 id="current-tier-status"><a class="header" href="#current-tier-status">Current Tier Status</a></h2>
<p>For explanations of what each tier means see below.</p>
<h4 id="tier-1"><a class="header" href="#tier-1">Tier 1</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Description</th></tr></thead><tbody>
<tr><td>Target</td><td><code>x86_64-apple-darwin</code></td></tr>
<tr><td>Target</td><td><code>x86_64-pc-windows-msvc</code></td></tr>
<tr><td>Target</td><td><code>x86_64-unknown-linux-gnu</code></td></tr>
<tr><td>WASI Proposal</td><td><code>wasi_snapshot_preview1</code></td></tr>
<tr><td>WASI Proposal</td><td><code>wasi_unstable</code></td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/mutable-global/blob/master/proposals/mutable-global/Overview.md"><code>mutable-globals</code></a></td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/spec/blob/master/proposals/sign-extension-ops/Overview.md"><code>sign-extension-ops</code></a></td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/spec/blob/master/proposals/nontrapping-float-to-int-conversion/Overview.md"><code>nontrapping-float-to-int-conversion</code></a></td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/spec/blob/master/proposals/multi-value/Overview.md"><code>multi-value</code></a></td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/bulk-memory-operations/blob/master/proposals/bulk-memory-operations/Overview.md"><code>bulk-memory</code></a></td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md"><code>reference-types</code></a></td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/simd/blob/master/proposals/simd/SIMD.md"><code>simd</code></a></td></tr>
</tbody></table>
</div>
<h4 id="tier-2"><a class="header" href="#tier-2">Tier 2</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Description</th><th>Missing Tier 1 Requirements</th></tr></thead><tbody>
<tr><td>Target</td><td><code>aarch64-unknown-linux-gnu</code></td><td>Continuous fuzzing</td></tr>
<tr><td>Target</td><td><code>s390x-unknown-linux-gnu</code></td><td>Continuous fuzzing</td></tr>
<tr><td>Target</td><td><code>x86_64-pc-windows-gnu</code></td><td>Clear owner of the target</td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/memory64/blob/master/proposals/memory64/Overview.md"><code>memory64</code></a></td><td>Unstable wasm proposal</td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/multi-memory/blob/master/proposals/multi-memory/Overview.md"><code>multi-memory</code></a></td><td>Unstable wasm proposal</td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md"><code>threads</code></a></td><td>Unstable wasm proposal</td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md"><code>component-model</code></a></td><td>Unstable wasm proposal</td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/tail-call/blob/main/proposals/tail-call/Overview.md"><code>tail-call</code></a></td><td>Unstable wasm proposal, performance work</td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/relaxed-simd/blob/main/proposals/relaxed-simd/Overview.md"><code>relaxed-simd</code></a></td><td>Unstable wasm proposal</td></tr>
<tr><td>WebAssembly Proposal</td><td><a href="https://github.com/WebAssembly/function-references/blob/main/proposals/function-references/Overview.md"><code>function-references</code></a></td><td>Unstable wasm proposal</td></tr>
<tr><td>WASI Proposal</td><td><a href="https://github.com/WebAssembly/wasi-io"><code>wasi-io</code></a></td><td>Unstable WASI proposal</td></tr>
<tr><td>WASI Proposal</td><td><a href="https://github.com/WebAssembly/wasi-clocks"><code>wasi-clocks</code></a></td><td>Unstable WASI proposal</td></tr>
<tr><td>WASI Proposal</td><td><a href="https://github.com/WebAssembly/wasi-filesystem"><code>wasi-filesystem</code></a></td><td>Unstable WASI proposal</td></tr>
<tr><td>WASI Proposal</td><td><a href="https://github.com/WebAssembly/wasi-random"><code>wasi-random</code></a></td><td>Unstable WASI proposal</td></tr>
<tr><td>WASI Proposal</td><td><a href="https://github.com/WebAssembly/wasi-poll"><code>wasi-poll</code></a></td><td>Unstable WASI proposal</td></tr>
</tbody></table>
</div>
<h4 id="tier-3"><a class="header" href="#tier-3">Tier 3</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Category</th><th>Description</th><th>Missing Tier 2 Requirements</th></tr></thead><tbody>
<tr><td>Target</td><td><code>aarch64-apple-darwin</code></td><td>CI testing</td></tr>
<tr><td>Target</td><td><code>aarch64-pc-windows-msvc</code></td><td>CI testing, unwinding, full-time maintainer</td></tr>
<tr><td>Target</td><td><code>riscv64gc-unknown-linux-gnu</code></td><td>full-time maintainer</td></tr>
<tr><td>WASI Proposal</td><td><a href="https://github.com/WebAssembly/wasi-nn"><code>wasi-nn</code></a></td><td>More expansive CI testing</td></tr>
<tr><td>WASI Proposal</td><td><a href="https://github.com/WebAssembly/wasi-threads"><code>wasi-threads</code></a></td><td>More CI, unstable proposal</td></tr>
<tr><td>WASI Proposal</td><td><a href="https://github.com/WebAssembly/wasi-sockets"><code>wasi-sockets</code></a></td><td>Complete implementation</td></tr>
<tr><td>WASI Proposal</td><td><a href="https://github.com/WebAssembly/wasi-http"><code>wasi-http</code></a></td><td>Complete implementation</td></tr>
<tr><td><em>misc</em></td><td>Non-Wasmtime Cranelift usage <sup class="footnote-reference"><a href="#1">1</a></sup></td><td>CI testing, full-time maintainer</td></tr>
<tr><td><em>misc</em></td><td>DWARF debugging <sup class="footnote-reference"><a href="#2">2</a></sup></td><td>CI testing, full-time maintainer, improved quality</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This is intended to encompass features that Cranelift supports as a
general-purpose code generator such as integer value types other than <code>i32</code> and
<code>i64</code>, non-Wasmtime calling conventions, code model settings, relocation
restrictions, etc. These features aren't covered by Wasmtime's usage of
Cranelift because the WebAssembly instruction set doesn't leverage them. This
means that they receive far less testing and fuzzing than the parts of Cranelift
exercised by Wasmtime.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Currently there is no active maintainer of DWARF debugging support and
support is currently best-effort. Additionally there are known shortcomings
and bugs. At this time there's no developer time to improve the situation here
as well.</p>
</div>
<h4 id="unsupported-features-and-platforms"><a class="header" href="#unsupported-features-and-platforms">Unsupported features and platforms</a></h4>
<p>While this is not an exhaustive list, Wasmtime does not currently have support
for the following features. Note that this is intended to document Wasmtime's
current state and does not mean Wasmtime does not want to ever support these
features; rather design discussion and PRs are welcome for many of the below
features to figure out how best to implement them and at least move them to Tier
3 above.</p>
<ul>
<li>Target: ARM 32-bit</li>
<li>Target: WebAssembly (compiling Wasmtime to WebAssembly itself)</li>
<li>Target: <a href="https://github.com/bytecodealliance/wasmtime/issues/5499">FreeBSD</a></li>
<li>Target: <a href="https://github.com/bytecodealliance/wasmtime/issues/6962">NetBSD/OpenBSD</a></li>
<li>Target: <a href="https://github.com/bytecodealliance/wasmtime/issues/1980">i686 (32-bit Intel targets)</a></li>
<li>Target: Android</li>
<li>Target: MIPS</li>
<li>Target: SPARC</li>
<li>Target: PowerPC</li>
<li>Target: RISC-V 32-bit</li>
<li><a href="https://github.com/WebAssembly/branch-hinting">WebAssembly proposal: <code>branch-hinting</code></a></li>
<li><a href="https://github.com/WebAssembly/exception-handling">WebAssembly proposal: <code>exception-handling</code></a></li>
<li><a href="https://github.com/WebAssembly/extended-const">WebAssembly proposal: <code>extended-const</code></a></li>
<li><a href="https://github.com/WebAssembly/flexible-vectors">WebAssembly proposal: <code>flexible-vectors</code></a></li>
<li><a href="https://github.com/WebAssembly/gc">WebAssembly proposal: <code>gc</code></a></li>
<li><a href="https://github.com/WebAssembly/memory-control">WebAssembly proposal: <code>memory-control</code></a></li>
<li><a href="https://github.com/WebAssembly/stack-switching">WebAssembly proposal: <code>stack-switching</code></a></li>
<li><a href="https://github.com/proxy-wasm/spec">WASI proposal: <code>proxy-wasm</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-blob-store">WASI proposal: <code>wasi-blob-store</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-crypto">WASI proposal: <code>wasi-crypto</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-data">WASI proposal: <code>wasi-data</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-distributed-lock-service">WASI proposal: <code>wasi-distributed-lock-service</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-grpc">WASI proposal: <code>wasi-grpc</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-kv-store">WASI proposal: <code>wasi-kv-store</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-message-queue">WASI proposal: <code>wasi-message-queue</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-parallel">WASI proposal: <code>wasi-parallel</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-pubsub">WASI proposal: <code>wasi-pubsub</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-runtime-config">WASI proposal: <code>wasi-runtime-config</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-sql">WASI proposal: <code>wasi-sql</code></a></li>
<li><a href="https://github.com/WebAssembly/wasi-url">WASI proposal: <code>wasi-url</code></a></li>
</ul>
<h2 id="tier-details"><a class="header" href="#tier-details">Tier Details</a></h2>
<p>Wasmtime's precise definitions of tiers are not guaranteed to be constant over
time, so these descriptions are likely to change over time. Tier 1 is classified
as the highest level of support, confidence, and correctness for a component.
Each tier additionally encompasses all the guarantees of previous tiers.</p>
<p>Features classified under a particular tier may already meet the criteria for
later tiers as well. In situations like this it's not intended to use these
guidelines to justify removal of a feature at any one point in time. Guidance is
provided here for phasing out unmaintained features but it should be clear under
what circumstances work "can be avoided" for each tier.</p>
<h4 id="tier-3---not-production-ready"><a class="header" href="#tier-3---not-production-ready">Tier 3 - Not Production Ready</a></h4>
<p>The general idea behind Tier 3 is that this is the baseline for inclusion of
code into the Wasmtime project. This is not intended to be a catch-all "if a
patch is sent it will be merged" tier. Instead the goal of this tier is to
outline what is expected of contributors adding new features to Wasmtime which
might be experimental at the time of addition. This is intentionally not a
relaxed tier of restrictions but already implies a significant commitment of
effort to a feature being included within Wasmtime.</p>
<p>Tier 3 features include:</p>
<ul>
<li>
<p>Inclusion of a feature does not impose unnecessary maintenance overhead on
other components/features. Some examples of additions to Wasmtime which would
not be accepted are:</p>
<ul>
<li>An experimental feature doubles the time of CI for all PRs.</li>
<li>A change which makes it significantly more difficult to architecturally
change Wasmtime's internal implementation.</li>
<li>A change which makes building Wasmtime more difficult for unrelated
developers.</li>
</ul>
<p>In general Tier 3 features are off-by-default at compile time but still
tested-by-default on CI.</p>
</li>
<li>
<p>New features of Wasmtime cannot have major known bugs at the time of
inclusion. Landing a feature in Wasmtime requires the feature to be correct
and bug-free as best can be evaluated at the time of inclusion. Inevitably
bugs will be found and that's ok, but anything identified during review must
be addressed.</p>
</li>
<li>
<p>Code included into the Wasmtime project must be of an acceptable level of
quality relative to the rest of the code in Wasmtime.</p>
</li>
<li>
<p>There must be a path to a feature being finished at the time of inclusion.
Adding a new backend to Cranelift for example is a significant undertaking
which may not be able to be done in a single PR. Partial implementations of a
feature are acceptable so long as there's a clear path forward and schedule
for completing the feature.</p>
</li>
<li>
<p>New components in Wasmtime must have a clearly identified owner who is willing
to be "on the hook" for review, updates to the internals of Wasmtime, etc. For
example a new backend in Cranelift would need to have a maintainer who is
willing to respond to changes in Cranelift's interfaces and the needs of
Wasmtime.</p>
</li>
</ul>
<p>This baseline level of support notably does not require any degree of testing,
fuzzing, or verification. As a result components classified as Tier 3 are
generally not production-ready as they have not been battle-tested much.</p>
<p>Features classified as Tier 3 may be disabled in CI or removed from the
repository as well. If a Tier 3 feature is preventing development of other
features then the owner will be notified. If no response is heard from within a
week then the feature will be disabled in CI. If no further response happens
for a month then the feature may be removed from the repository.</p>
<h4 id="tier-2---almost-production-ready"><a class="header" href="#tier-2---almost-production-ready">Tier 2 - Almost Production Ready</a></h4>
<p>This tier is meant to encompass features and components of Wasmtime which are
well-maintained, tested well, but don't necessarily meet the stringent criteria
for Tier 1. Features in this category may already be "production ready" and safe
to use.</p>
<p>Tier 2 features include:</p>
<ul>
<li>
<p>Tests are run in CI for the Wasmtime project for this feature and everything
passes. For example a Tier 2 platform runs in CI directly or via emulation.
Features are otherwise fully tested on CI.</p>
</li>
<li>
<p>Complete implementations for anything that's part of Tier 1. For example
all Tier 2 targets must implement all of the Tier 1 WebAssembly proposals,
and all Tier 2 features must be implemented on all Tier 1 targets.</p>
</li>
<li>
<p>All existing developers are expected to handle minor changes which affect Tier
2 components. For example if Cranelift's interfaces change then the developer
changing the interface is expected to handle the changes for Tier 2
architectures so long as the affected part is relatively minor. Note that if a
more substantial change is required to a Tier 2 component then that falls
under the next bullet.</p>
</li>
<li>
<p>Maintainers of a Tier 2 feature are responsive (reply to requests within a
week) and are available to accommodate architectural changes that affect their
component. For example more expansive work beyond the previous bullet where
contributors can't easily handle changes are expected to be guided or
otherwise implemented by Tier 2 maintainers.</p>
</li>
<li>
<p>Major changes otherwise requiring an RFC that affect Tier 2 components are
required to consult Tier 2 maintainers in the course of the RFC. Major changes
to Tier 2 components themselves do not require an RFC, however.</p>
</li>
</ul>
<p>Features at this tier generally are not turned off or disabled for very long.
Maintainers are already required to be responsive to changes and will be
notified of any unrelated change which affects their component. It's recommended
that if a component breaks for one reason or another due to an unrelated change
that the maintainer either contributes to the PR-in-progress or otherwise has a
schedule for the implementation of the feature.</p>
<h4 id="tier-1---production-ready"><a class="header" href="#tier-1---production-ready">Tier 1 - Production Ready</a></h4>
<p>This tier is intended to be the highest level of support in Wasmtime for any
particular feature, indicating that it is suitable for production environments.
This conveys a high level of confidence in the Wasmtime project about the
specified features.</p>
<p>Tier 1 features include:</p>
<ul>
<li>
<p>Continuous fuzzing is required for WebAssembly proposals. This means that any
WebAssembly proposal must have support in the <code>wasm-smith</code> crate and existing
fuzz targets must be running and exercising the new code paths. Where possible
differential fuzzing should also be implemented to compare results with other
implementations.</p>
</li>
<li>
<p>Continuous fuzzing is required for the architecture of supported targets. For
example currently there are three x86_64 targets that are considered Tier 1
but only <code>x86_64-unknown-linux-gnu</code> is fuzzed.</p>
</li>
<li>
<p>CVEs and security releases will be performed as necessary for any bugs found
in features and targets.</p>
</li>
<li>
<p>Major changes affecting this component may require help from maintainers with
specialized expertise, but otherwise it should be reasonable to expect most
Wasmtime developers to be able to maintain Tier 1 features.</p>
</li>
<li>
<p>Major changes affecting Tier 1 features require an RFC and prior agreement on
the change before an implementation is committed.</p>
</li>
</ul>
<p>A major inclusion point for this tier is intended to be the continuous fuzzing
of Wasmtime. This implies a significant commitment of resources for fixing
issues, hardware to execute Wasmtime, etc. Additionally this tier comes with the
broadest expectation of "burden on everyone else" in terms of what changes
everyone is generally expected to handle.</p>
<p>Features classified as Tier 1 are rarely, if ever, turned off or removed from
Wasmtime.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h1>
<p>The <code>wasmtime</code> project is a configurable and lightweight runtime for WebAssembly
which has a number of ways it can be configured. Not all features are supported
on all platforms, but it is intended that <code>wasmtime</code> can run in some capacity on
almost all platforms! The matrix of what's being tested, what works, and what's
supported where is evolving over time, and this document hopes to capture a
snapshot of what the current state of the world looks like.</p>
<p>All features of <code>wasmtime</code> should work on the following platforms:</p>
<ul>
<li>Linux x86_64</li>
<li>Linux aarch64</li>
<li>macOS x86_64</li>
<li>Windows x86_64</li>
</ul>
<p>For more detailed information about supported platforms, please check out the
sections below!</p>
<h2 id="jit-compiler-support"><a class="header" href="#jit-compiler-support">JIT compiler support</a></h2>
<p>The JIT compiler, backed by Cranelift, supports the x86_64 and aarch64
architectures at this time. Support for at least ARM and x86 is planned as well.</p>
<p>Usage of the JIT compiler will require a host operating system which supports
creating executable memory pages on-the-fly. In Rust terms this generally means
that <code>std</code> needs to be supported on this platform.</p>
<h2 id="interpreter-support"><a class="header" href="#interpreter-support">Interpreter support</a></h2>
<p>At this time <code>wasmtime</code> does not have a mode in which it simply interprets
WebAssembly code. It is planned to add support for an interpreter, however, and
this will have minimal system dependencies. It is planned that the system will
need to support some form of dynamic memory allocation, but other than that not
much else will be needed.</p>
<h2 id="what-about-no_std"><a class="header" href="#what-about-no_std">What about <code>#[no_std]</code>?</a></h2>
<p>The <code>wasmtime</code> project does not currently use <code>#[no_std]</code> for its crates, but
this is not because it won't support it! For information on building Wasmtime
for a custom target see <a href="./examples-minimal.html">the minimal build
documentation</a>. Please <a href="https://github.com/bytecodealliance/wasmtime/issues/new">open an
issue</a> on the
<code>wasmtime</code> repository to request support for a specific platform.</p>
<p>This is a common question we are asked, however, so to provide some more context
on why Wasmtime is the way it is, here's some responses to frequent points
raised about <code>#![no_std]</code>:</p>
<ul>
<li>
<p><strong>What if my platform doesn't have <code>std</code>?</strong> - For platforms without support
for the Rust standard library the JIT compiler of Wasmtime often won't run on
the platform as well. The JIT compiler requires <code>mmap</code> (or an equivalent), and
presence of <code>mmap</code> often implies presence of a libc which means Rust's <code>std</code>
library works.</p>
<p>Cargo's <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std"><code>-Z build-std</code> feature</a> feature is also intended to help
easily build the standard library for all platforms. With this feature you can
recompile the standard library (using Nightly Rust for now) with a <a href="https://doc.rust-lang.org/rustc/targets/custom.html">custom
target specification</a> if necessary. Additionally the intention
at this time is to get <code>std</code> building for all platforms, regardless of what
the platform actually supports. This change is taking time to implement, but
<a href="https://github.com/rust-lang/rust/pull/74033">rust-lang/rust#74033</a> is an example of this support growing over time.</p>
<p>We're also interested in running Wasmtime without a JIT compiler in the
future, but that is not implemented at this time. Implementing this will
require a lot more work than tagging crates <code>#![no_std]</code>. The Wasmtime
developers are also very interested in supporting as many targets as possible,
so if Wasmtime doesn't work on your platform yet we'd love to learn why and
what we can do to support that platform, but the conversation here is
typically more nuanced than simply making <code>wasmtime</code> compile without <code>std</code>.</p>
</li>
<li>
<p><strong>Doesn't <code>#![no_std]</code> have smaller binary sizes?</strong> - There's a lot of factors
that affect binary size in Rust. Compilation options are a huge one but beyond
that idioms and libraries linked matter quite a lot as well. Code is not
inherently large when using <code>std</code> instead of <code>core</code>, it's just that often code
using <code>std</code> has more dependencies (like <code>std::thread</code>) which requires code to
bind. Code size improvements can be made to code using <code>std</code> and <code>core</code>
equally, and switching to <code>#![no_std]</code> is not a silver bullet for compile
sizes.</p>
</li>
<li>
<p><strong>The patch to switch to <code>#![no_std]</code> is small, why not accept it?</strong> - PRs to
switch to <code>#![no_std]</code> are often relatively small or don't impact too many
parts of the system. There's a lot more to developing a <code>#![no_std]</code>
WebAssembly runtime than switching a few crates, however. Maintaining a
<code>#![no_std]</code> library over time has a number of costs associated with it:</p>
<ul>
<li>
<p>Rust has no stable way to diagnose <code>no_std</code> errors in an otherwise <code>std</code>
build, which means that to support this feature it must be tested on CI with
a <code>no_std</code> target. This is costly in terms of CI time, CI maintenance, and
developers having to do extra builds to avoid CI errors. Note that this
isn't <em>more</em> costly than any other platform supported by Wasmtime, but it's
a cost nonetheless.</p>
</li>
<li>
<p>Idioms in <code>#![no_std]</code> are quite different than normal Rust code. You'll
import from different crates (<code>core</code> instead of <code>std</code>) and data structures
have to all be manually imported from <code>alloc</code>. These idioms are difficult to
learn for newcomers to the project and are not well documented in the
ecosystem. This cost of development and maintenance is not unique to
Wasmtime but in general affects the <code>#![no_std]</code> ecosystem at large,
unfortunately.</p>
</li>
<li>
<p>Currently Wasmtime does not have a target use case which requires
<code>#![no_std]</code> support, so it's hard to justify these costs of development.
We're very interested in supporting as many use cases and targets as
possible, but the decision to support a target needs to take into account
the costs associated so we can plan accordingly. Effectively we need to have
a goal in mind instead of taking on the costs of <code>#![no_std]</code> blindly.</p>
</li>
<li>
<p>At this time it's not clear whether <code>#![no_std]</code> will be needed long-term,
so eating short-term costs may not pay off in the long run. Features like
Cargo's <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std"><code>-Z build-std</code></a> may mean that <code>#![no_std]</code> is less and
less necessary over time.</p>
</li>
</ul>
</li>
<li>
<p><strong>How can Wasmtime support <code>#![no_std]</code> if it uses X?</strong> - Wasmtime as-is today
is not suitable for many <code>#![no_std]</code> contexts. For example it might use
<code>mmap</code> for allocating JIT code memory, leverage threads for caching, or use
thread locals when calling into JIT code. These features are difficult to
support in their full fidelity on all platforms, but the Wasmtime developers
are very much aware of this! Wasmtime is intended to be configurable where
many of these features are compile-time or runtime options. For example caches
can be disabled, JITs can be removed and replaced with interpreters, or users
could provide a callback to allocate memory instead of using the OS.
This is sort of a long-winded way of saying that Wasmtime on the surface may
today look like it won't support <code>#![no_std]</code>, but this is almost always
simply a matter of time and development priorities rather than a fundamental
reason why Wasmtime <em>couldn't</em> support <code>#![no_std]</code>.</p>
</li>
</ul>
<p>Note that at this time these guidelines apply not only to Wasmtime but also to
some of its dependencies developed by the Bytecode Alliance such as the
<a href="https://github.com/bytecodealliance/wasm-tools">wasm-tools repository</a>. These
projects don't have the same runtime requirements as Wasmtime (e.g. <code>wasmparser</code>
doesn't need <code>mmap</code>), but we're following the same guidelines above at this
time. Patches to add <code>#![no_std]</code>, while possibly small, incur many of the same
costs and also have an unclear longevity as features like <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std"><code>-Z build-std</code></a> evolve.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>One of WebAssembly (and Wasmtime's) main goals is to execute untrusted code in
a safe manner inside of a sandbox. WebAssembly is inherently sandboxed by design
(must import all functionality, etc). This document is intended to cover the
various sandboxing implementation strategies that Wasmtime has as they are
developed. This has also been documented in a <a href="https://bytecodealliance.org/articles/security-and-correctness-in-wasmtime">historical blog post</a> too.</p>
<p>At this time Wasmtime implements what's necessary for the WebAssembly
specification, for example memory isolation between instances. Additionally the
safe Rust API is intended to mitigate accidental bugs in hosts.</p>
<p>Different sandboxing implementation techniques will also come with different
tradeoffs in terms of performance and feature limitations, and Wasmtime plans to
offer users choices of which tradeoffs they want to make.</p>
<h2 id="webassembly-core"><a class="header" href="#webassembly-core">WebAssembly Core</a></h2>
<p>The core WebAssembly spec has several features which create a unique sandboxed
environment:</p>
<ul>
<li>
<p>The callstack is inaccessible. Unlike most native execution environments,
return addresses from calls and spilled registers are not stored in memory
accessible to applications. They are stored in memory that only the
implementation has access to, which makes traditional stack-smashing attacks
targeting return addresses impossible.</p>
</li>
<li>
<p>Pointers, in source languages which have them, are compiled to offsets
into linear memory, so implementations details such as virtual addresses
are hidden from applications. And all accesses within linear memory are
checked to ensure they stay in bounds.</p>
</li>
<li>
<p>All control transfersdirect and indirect branches, as well as direct and
indirect callsare to known and type-checked destinations, so it's not
possible to accidentally call into the middle of a function or branch
outside of a function.</p>
</li>
<li>
<p>All interaction with the outside world is done through imports and exports.
There is no raw access to system calls or other forms of I/O; the only
thing a WebAssembly instance can do is what is available through interfaces
it has been explicitly linked with.</p>
</li>
<li>
<p>There is no undefined behavior. Even where the WebAssembly spec permits
multiple possible behaviors, it doesn't permit arbitrary behavior.</p>
</li>
</ul>
<h2 id="defense-in-depth"><a class="header" href="#defense-in-depth">Defense-in-depth</a></h2>
<p>While WebAssembly is designed to be sandboxed bugs or issues inevitably arise so
Wasmtime also implements a number of mitigations which are not required for
correct execution of WebAssembly but can help mitigate issues if bugs are found:</p>
<ul>
<li>
<p>Linear memories by default are preceded with a 2GB guard region. WebAssembly
has no means of ever accessing this memory but this can protect against
accidental sign-extension bugs in Cranelift where if an offset is accidentally
interpreted as a signed 32-bit offset instead of an unsigned offset it could
access memory before the addressable memory for WebAssembly.</p>
</li>
<li>
<p>Wasmtime uses explicit checks to determine if a WebAssembly function should be
considered to stack overflow, but it still uses guard pages on all native
thread stacks. These guard pages are never intended to be hit and will abort
the program if they're hit. Hitting a guard page within WebAssembly indicates
a bug in host configuration or a bug in Cranelift itself.</p>
</li>
<li>
<p>Where it can Wasmtime will zero memory used by a WebAssembly instance after
it's finished. This is not necessary unless the memory is actually reused for
instantiation elsewhere but this is done to prevent accidental leakage of
information between instances in the face of other bugs. This applies to
linear memories, tables, and the memory used to store instance information
itself.</p>
</li>
<li>
<p>The choice of implementation language, Rust, for Wasmtime is also a
defense in protecting the authors for Wasmtime from themselves in addition to
protecting embedders from themselves. Rust helps catch mistakes when writing
Wasmtime itself at compile time. Rust additionally enables Wasmtime developers
to create an API that means that embedders can't get it wrong. For example
it's guaranteed that Wasmtime won't segfault when using its public API,
empowering embedders with confidence that even if the embedding has bugs all
of the security guarantees of WebAssembly are still upheld.</p>
</li>
<li>
<p>Wasmtime is in the <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/cfi-improvements-with-pauth-and-bti.md">process of implementing control-flow-integrity
mechanisms</a> to leverage hardware state for futher guaranteeing that
WebAssembly stays within its sandbox. In the event of a bug in Cranelift this
can help mitigate the impact of where control flow can go to.</p>
</li>
</ul>
<h2 id="filesystem-access"><a class="header" href="#filesystem-access">Filesystem Access</a></h2>
<p>Wasmtime implements the WASI APIs for filesystem access, which follow a
capability-based security model, which ensures that applications can only
access files and directories they've been given access to. WASI's security
model keeps users safe today, and also helps us prepare for shared-nothing
linking and nanoprocesses in the future.</p>
<p>Wasmtime developers are intimately engaged with the WASI standards process,
libraries, and tooling development, all along the way too.</p>
<h2 id="terminal-output"><a class="header" href="#terminal-output">Terminal Output</a></h2>
<p>If untrusted code is allowed to print text which is displayed to a terminal, it may
emit ANSI-style escape sequences and other control sequences which, depending on
the terminal the user is using and how it is configured, can have side effects
including writing to files, executing commands, injecting text into the stream
as if the user had typed it, or reading the output of previous commands. ANSI-style
escape sequences can also confuse or mislead users, making other vulnerabilities
easier to exploit.</p>
<p>Our first priority is to protect users, so Wasmtime now filters writes to output
streams when they are connected to a terminal to translate escape sequences into
inert replacement sequences.</p>
<p>Some applications need ANSI-style escape sequences, such as terminal-based
editors and programs that use colors, so we are also developing a proposal for
the WASI Subgroup for safe and portable ANSI-style escape sequence support, which
we hope to post more about soon.</p>
<h2 id="spectre"><a class="header" href="#spectre">Spectre</a></h2>
<p>Wasmtime implements a few forms of basic spectre mitigations at this time:</p>
<ul>
<li>
<p>Bounds checks when accessing entries in a function table (e.g. the
<code>call_indirect</code> instruction) are mitigated.</p>
</li>
<li>
<p>The <code>br_table</code> instruction is mitigated to ensure that speculation goes to a
deterministic location.</p>
</li>
<li>
<p>Wasmtime's default configuration for linear memory means that bounds checks
will not be present for memory accesses due to the reliance on page faults to
instead detect out-of-bounds accesses. When Wasmtime is configured with
"dynamic" memories, however, Cranelift will insert spectre mitigation for the
bounds checks performed for all memory accesses.</p>
</li>
</ul>
<p>Mitigating Spectre continues to be a subject of ongoing research, and Wasmtime
will likely grow more mitigations in the future as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disclosure-policy"><a class="header" href="#disclosure-policy">Disclosure Policy</a></h1>
<p>The disclosure policy for security issues in Wasmtime is <a href="https://bytecodealliance.org/security#disclosure-policy">documented on the Bytecode Alliance website</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-considered-a-security-vulnerability"><a class="header" href="#what-is-considered-a-security-vulnerability">What is considered a security vulnerability?</a></h1>
<p><strong>If you are still unsure whether an issue you are filing is a security
vulnerability or not after reading this page, always err on the side of caution
and report it as a security vulnerability!</strong></p>
<p>Bugs must affect <a href="./stability-tiers.html">a tier 1 platform or feature</a> to be
considered a security vulnerability.</p>
<p>The security of the host and integrity of the sandbox when executing Wasm is
paramount. Anything that undermines the Wasm execution sandbox is a security
vulnerability.</p>
<p>On the other hand, execution that diverges from Wasm semantics (such as
computing incorrect values) are not considered security vulnerabilities so long
as they remain confined within the sandbox. This has a couple repercussions that
are worth highlighting:</p>
<ul>
<li>
<p>Even though it is safe from the <em>host's</em> point of view, an incorrectly
computed value could lead to classic memory unsafety bugs from the <em>Wasm
guest's</em> point of view, such as corruption of its <code>malloc</code>'s free list or
reading past the end of a source-level array.</p>
</li>
<li>
<p>Wasmtime embedders should never blindly trust values from the guest  no
matter how trusted the guest program is, even if it was written by the
embedders themselves  and should always validate these values before
performing unsafe operations on behalf of the guest.</p>
</li>
</ul>
<p>Denials of service when <em>executing</em> Wasm (either originating inside compiled
Wasm code or Wasmtime's runtime subroutines) are considered security
vulnerabilities. For example, if you configure Wasmtime to run Wasm guests with
the async
<a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.consume_fuel">fuel</a>
mechanism, and then executing the Wasm goes into an infinite loop that never
yields, that is considered a security vulnerability.</p>
<p>Denials of service when <em>compiling</em> Wasm, however, are not considered security
vulnerabilities. For example, an infinite loop during register allocation is not
a security vulnerability.</p>
<p>Any kind of memory unsafety (e.g. use-after-free bugs, out-of-bounds memory
accesses, etc...) in the host is always a security vulnerability.</p>
<h3 id="cheat-sheet-is-this-bug-considered-a-security-vulnerability"><a class="header" href="#cheat-sheet-is-this-bug-considered-a-security-vulnerability">Cheat Sheet: Is this bug considered a security vulnerability?</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Type of bug</th><th>At Wasm Compile Time</th><th>At Wasm Execution Time</th></tr></thead><tbody>
<tr><td>Sandbox escape</td><td>-</td><td>Yes</td></tr>
<tr><td><ul>Uncaught out-of-bounds memory access</td><td>-</td><td>Yes</td></tr>
<tr><td><ul>Uncaught out-of-bounds table access</td><td>-</td><td>Yes</td></tr>
<tr><td><ul>Failure to uphold Wasm's control-flow integrity</td><td>-</td><td>Yes</td></tr>
<tr><td><ul>File system access outside of the WASI file system's mapped directories</td><td>-</td><td>Yes</td></tr>
<tr><td><ul>Use of a WASI resource without having been given the associated WASI capability</td><td>-</td><td>Yes</td></tr>
<tr><td><ul>Etc...</td><td>-</td><td>Yes</td></tr>
<tr><td>Divergence from Wasm semantics (without escaping the sandbox)</td><td>-</td><td>No</td></tr>
<tr><td><ul>Computing incorrect value</td><td>-</td><td>No</td></tr>
<tr><td><ul>Raising errant trap</td><td>-</td><td>No</td></tr>
<tr><td><ul>Etc...</td><td>-</td><td>No</td></tr>
<tr><td>Memory unsafety</td><td>Yes</td><td>Yes</td></tr>
<tr><td><ul>Use-after-free</td><td>Yes</td><td>Yes</td></tr>
<tr><td><ul>Out-of-bounds memory access</td><td>Yes</td><td>Yes</td></tr>
<tr><td><ul>Use of uninitialized memory</td><td>Yes</td><td>Yes</td></tr>
<tr><td><ul>Etc...</td><td>Yes</td><td>Yes</td></tr>
<tr><td>Denial of service</td><td>No</td><td>Yes</td></tr>
<tr><td><ul>Panic</td><td>No</td><td>Yes</td></tr>
<tr><td><ul>Process abort</td><td>No</td><td>Yes</td></tr>
<tr><td><ul>Uninterruptible infinite loops</td><td>No</td><td>Yes</td></tr>
<tr><td><ul>User-controlled memory exhaustion</td><td>No</td><td>Yes</td></tr>
<tr><td><ul>Uncontrolled recursion over user-supplied input</td><td>No</td><td>Yes</td></tr>
<tr><td><ul>Etc...</td><td>No</td><td>Yes</td></tr>
</tbody></table>
</div>
<p>Note that we still want to fix every bug mentioned above even if it is not a
security vulnerability! We appreciate when issues are filed for
non-vulnerability bugs, particularly when they come with test cases and steps to
reproduce!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>We're excited to work on Wasmtime and/or Cranelift together with you! This guide
should help you get up and running with Wasmtime and Cranelift development. But
first, make sure you've read the <a href="./contributing-coc.html">Code of Conduct</a>!</p>
<p>Wasmtime and Cranelift are very ambitious projects with many goals, and while
we're confident we can achieve some of them, we see many opportunities for
people to get involved and help us achieve even more.</p>
<h2 id="join-our-chat"><a class="header" href="#join-our-chat">Join Our Chat</a></h2>
<p>We chat about Wasmtime and Cranelift development on Zulip  <a href="https://bytecodealliance.zulipchat.com/">join
us!</a>. You can also join specific
streams:</p>
<ul>
<li><a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">#wasmtime</a></li>
<li><a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217117-cranelift">#cranelift</a></li>
</ul>
<p>If you're having trouble building Wasmtime or Cranelift, aren't sure why a test
is failing, or have any other questions, feel free to ask on Zulip. Not
everything we hope to do with these projects is reflected in the code or
documentation yet, so if you see things that seem missing or that don't make
sense, or even that just don't work the way you expect them to, we're also
interested to hear about that!</p>
<p>As always, you're more than welcome to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">open an
issue</a> too!</p>
<p>Finally, we have biweekly project meetings, hosted on Zoom, for Wasmtime and
Cranelift. For more information, see our <a href="https://github.com/bytecodealliance/meetings">meetings agendas/minutes
repository</a>. Please feel free to
contact us via Zulip if you're interested in joining!</p>
<h2 id="finding-something-to-hack-on"><a class="header" href="#finding-something-to-hack-on">Finding Something to Hack On</a></h2>
<p>If you're looking for something to do, these are great places to start:</p>
<ul>
<li>
<p><a href="https://github.com/bytecodealliance/wasmtime/labels/good%20first%20issue">Issues labeled "good first
issue"</a>
 these issues tend to be simple, what needs to be done is well known,
and are good for new contributors to tackle. The goal is to learn Wasmtime's
development workflow and make sure that you can build and test Wasmtime.</p>
</li>
<li>
<p><a href="https://github.com/bytecodealliance/wasmtime/labels/help%20wanted">Issues labeled "help
wanted"</a>
 these are issues that we need a little help with!</p>
</li>
</ul>
<p>If you're unsure if an issue is a good fit for you or not, feel free to ask in a
comment on the issue, or in chat.</p>
<h3 id="mentoring"><a class="header" href="#mentoring">Mentoring</a></h3>
<p>We're happy to mentor people, whether you're learning Rust, learning about
compiler backends, learning about machine code, learning about wasm, learning
about how Cranelift does things, or all together at once.</p>
<p>We categorize issues in the issue tracker using a tag scheme inspired by
<a href="https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#issue-triage">Rust's issue tags</a>. For example, the <a href="https://github.com/bytecodealliance/wasmtime/labels/cranelift%3AE-easy">E-easy</a> marks good beginner issues,
and <a href="https://github.com/bytecodealliance/wasmtime/labels/cranelift%3AE-rust">E-rust</a> marks issues which likely require some familiarity with Rust,
though not necessarily Cranelift-specific or even compiler-specific
experience. <a href="https://github.com/bytecodealliance/wasmtime/labels/cranelift%3AE-compiler-easy">E-compiler-easy</a> marks issues good for beginners who have
some familiarity with compilers, or are interested in gaining some :-).</p>
<p>See also the <a href="https://github.com/bytecodealliance/wasmtime/labels?q=cranelift">full list of Cranelift labels</a>.</p>
<p>Also, we encourage people to just look around and find things they're
interested in. This a good time to get involved, as there aren't a lot of
things set in stone yet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-of-wasmtime"><a class="header" href="#architecture-of-wasmtime">Architecture of Wasmtime</a></h1>
<p>This document is intended to give an overview of the implementation of Wasmtime.
This will explain the purposes of the various <code>wasmtime-*</code> crates that the main
<code>wasmtime</code> crate depends on. For even more detailed information it's recommended
to review the code itself and find the comments contained within.</p>
<h2 id="the-wasmtime-crate"><a class="header" href="#the-wasmtime-crate">The <code>wasmtime</code> crate</a></h2>
<p>The main entry point for Wasmtime is the <code>wasmtime</code> crate itself. Wasmtime is
designed such that the <code>wasmtime</code> crate is nearly a 100% safe API (safe in the
Rust sense) modulo some small and well-documented functions as to why they're
<code>unsafe</code>. The <code>wasmtime</code> crate provides features and access to WebAssembly
primitives and functionality, such as compiling modules, instantiating them,
calling functions, etc.</p>
<p>At this time the <code>wasmtime</code> crate is the first crate that is intended to be
consumed by users. First in this sense means that everything <code>wasmtime</code> depends
on is thought of as an internal dependency. We publish crates to crates.io but
put very little effort into having a "nice" API for internal crates or worrying
about breakage between versions of internal crates. This primarily means that
all the other crates discussed here are considered internal dependencies of
Wasmtime and don't show up in the public API of Wasmtime at all. To use some
Cargo terminology, all the <code>wasmtime-*</code> crates that <code>wasmtime</code> depends on are
"private" dependencies.</p>
<p>Additionally at this time the safe/unsafe boundary between Wasmtime's internal
crates is not the most well-defined. There are methods that should be marked
<code>unsafe</code> which aren't, and <code>unsafe</code> methods do not have exhaustive documentation
as to why they are <code>unsafe</code>. This is an ongoing matter of improvement, however,
where the goal is to have safe methods be actually safe in the Rust sense,
as well as having documentation for <code>unsafe</code> methods which clearly lists why
they are <code>unsafe</code>.</p>
<h2 id="important-concepts"><a class="header" href="#important-concepts">Important concepts</a></h2>
<p>To preface discussion of more nitty-gritty internals, it's important to have a
few concepts in the back of your head. These are some of the important types and
their implications in Wasmtime:</p>
<ul>
<li>
<p><code>wasmtime::Engine</code> - this is a global compilation context which is sort of the
"root context". An <code>Engine</code> is typically created once per program and is
expected to be shared across many threads (internally it's atomically
reference counted). Each <code>Engine</code> stores configuration values and other
cross-thread data such as type interning for <code>Module</code> instances. The main
thing to remember for <code>Engine</code> is that any mutation of its internals typically
involves acquiring a lock, whereas for <code>Store</code> below no locks are necessary.</p>
</li>
<li>
<p><code>wasmtime::Store</code> - this is the concept of a "store" in WebAssembly. While
there's also a formal definition to go off of, it can be thought of as a bag
of related WebAssembly objects. This includes instances, globals, memories,
tables, etc. A <code>Store</code> does not implement any form of garbage collection of
the internal items (there is a <code>gc</code> function but that's just for <code>externref</code>
values). This means that once you create an <code>Instance</code> or a <code>Table</code> the memory
is not actually released until the <code>Store</code> itself is deallocated. A <code>Store</code> is
sort of a "context" used for almost all wasm operations. <code>Store</code> also contains
instance handles which recursively refer back to the <code>Store</code>, leading to a
good bit of aliasing of pointers within the <code>Store</code>. The important thing for
now, though, is to know that <code>Store</code> is a unit of isolation. WebAssembly
objects are always entirely contained within a <code>Store</code>, and at this time
nothing can cross between stores (except scalars if you manually hook it up).
In other words, wasm objects from different stores cannot interact with each
other. A <code>Store</code> cannot be used simultaneously from multiple threads (almost
all operations require <code>&amp;mut self</code>).</p>
</li>
<li>
<p><code>wasmtime_runtime::InstanceHandle</code> - this is the low-level representation of a
WebAssembly instance. At the same time this is also used as the representation
for all host-defined objects. For example if you call <code>wasmtime::Memory::new</code>
it'll create an <code>InstanceHandle</code> under the hood. This is a very <code>unsafe</code> type
that should probably have all of its functions marked <code>unsafe</code> or otherwise
have more strict guarantees documented about it, but it's an internal type
that we don't put much thought into for public consumption at this time. An
<code>InstanceHandle</code> doesn't know how to deallocate itself and relies on the
caller to manage its memory. Currently this is either allocated on-demand
(with <code>malloc</code>) or in a pooling fashion (using the pooling allocator). The
<code>deallocate</code> method is different in these two paths (as well as the
<code>allocate</code> method).</p>
<p>An <code>InstanceHandle</code> is laid out in memory with some Rust-owned values first
capturing the dynamic state of memories/tables/etc. Most of these fields are
unused for host-defined objects that serve one purpose (e.g. a
<code>wasmtime::Table::new</code>), but for an instantiated WebAssembly module these
fields will have more information. After an <code>InstanceHandle</code> in memory is a
<code>VMContext</code>, which will be discussed next. <code>InstanceHandle</code> values are the
main internal runtime representation and what the <code>wasmtime_runtime</code> crate
works with. The <code>wasmtime::Store</code> holds onto all these <code>InstanceHandle</code> values
and deallocates them at the appropriate time. From the runtime perspective it
simplifies things so the graph of wasm modules communicating to each other is
reduced to simply <code>InstanceHandle</code> values all talking to themselves.</p>
</li>
<li>
<p><code>wasmtime_runtime::VMContext</code> - this is a raw pointer, within an allocation of
an <code>InstanceHandle</code>, that is passed around in JIT code. A <code>VMContext</code> does not
have a structure defined in Rust (it's a 0-sized structure) because its
contents are dynamically determined based on the <code>VMOffsets</code>, or the source
wasm module it came from. Each <code>InstanceHandle</code> has a "shape" of a <code>VMContext</code>
corresponding with it. For example a <code>VMContext</code> stores all values of
WebAssembly globals, but if a wasm module has no globals then the size of this
array will be 0 and it won't be allocated. The intention of a <code>VMContext</code> is
to be an efficient in-memory representation of all wasm module state that JIT
code may access. The layout of <code>VMContext</code> is dynamically determined by a
module and JIT code is specialized for this one structure. This means that the
structure is efficiently accessed by JIT code, but less efficiently accessed
by native host code. A non-exhaustive list of purposes of the <code>VMContext</code> is
to:</p>
<ul>
<li>Store WebAssembly instance state such as global values, pointers to tables,
pointers to memory, and pointers to other JIT functions.</li>
<li>Separate wasm imports and local state. Imported values have pointers stored
to their actual values, and local state has the state defined inline.</li>
<li>Hold a pointer to the stack limit at which point JIT code will trigger a
stack overflow.</li>
<li>Hold a pointer to a <code>VMExternRefActivationsTable</code> for fast-path insertion of
<code>externref</code> values into the table.</li>
<li>Hold a pointer to a <code>*mut dyn wasmtime_runtime::Store</code> so store-level
operations can be performed in libcalls.</li>
</ul>
<p>A comment about the layout of a <code>VMContext</code> can be found in the <code>vmoffsets.rs</code>
file.</p>
</li>
<li>
<p><code>wasmtime::Module</code> - this is the representation of a compiled WebAssembly
module. At this time Wasmtime always assumes that a wasm module is always
compiled to native JIT code. <code>Module</code> holds the results of said compilation,
and currently Cranelift can be used for compiling. It is a goal of
Wasmtime to support other modes of representing modules but those are not
implemented today just yet, only Cranelift is implemented and supported.</p>
</li>
<li>
<p><code>wasmtime_environ::Module</code> - this is a descriptor of a wasm module's type and
structure without holding any actual JIT code. An instance of this type is
created very early on in the compilation process, and it is not modified when
functions themselves are actually compiled. This holds the internal type
representation and state about functions, globals, etc. In a sense this can be
thought of as the result of validation or typechecking a wasm module, although
it doesn't have information such as the types of each opcode or minute
function-level details like that.</p>
</li>
</ul>
<h2 id="compiling-a-module"><a class="header" href="#compiling-a-module">Compiling a module</a></h2>
<p>With a high-level overview and some background information of types, this will
next walk through the steps taken to compile a WebAssembly module. The main
entry point for this is the <code>wasmtime::Module::from_binary</code> API. There are a
number of other entry points that deal with surface-level details like
translation from text-to-binary, loading from the filesystem, etc.</p>
<p>Compilation is roughly broken down into a few phases:</p>
<ol>
<li>
<p>First compilation walks over the WebAssembly module validating everything
except function bodies. This synchronous pass over a wasm module creates a
<code>wasmtime_environ::Module</code> instance and additionally prepares for function
compilation. Note that with the module linking proposal one input module may
end up creating a number of output modules to process. Each module is
processed independently and all further steps are parallelized on a
per-module basis. Note that parsing and validation of the WebAssembly module
happens with the <code>wasmparser</code> crate. Validation is interleaved with parsing,
validating parsed values before using them.</p>
</li>
<li>
<p>Next all functions within a module are validated and compiled in parallel.
No inter-procedural analysis is done and each function is compiled as its
own little island of code at this time. This is the point where the meat of
Cranelift is invoked on a per-function basis.</p>
</li>
<li>
<p>The compilation results at this point are all woven into a
<code>wasmtime_jit::CompilationArtifacts</code> structure. This holds module information
(<code>wasmtime_environ::Module</code>), compiled JIT code (stored as an ELF image), and
miscellaneous other information about functions such as platform-agnostic
unwinding information, per-function trap tables (indicating which JIT
instructions can trap and what the trap means), per-function address maps
(mapping from JIT addresses back to wasm offsets), and debug information
(parsed from DWARF information in the wasm module). These results are inert
and can't actually be executed, but they're appropriate at this point to
serialize to disk or begin the next phase...</p>
</li>
<li>
<p>The final step is to actually place all code into a form that's ready to get
executed. This starts from the <code>CompilationArtifacts</code> of the previous step.
Here a new memory mapping is allocated and the JIT code is copied into this
memory mapping. This memory mapping is then switched from read/write to
read/execute so it's actually executable JIT code at this point. This is
where various hooks like loading debuginfo, informing JIT profilers of new
code, etc, all happens. At this point a <code>wasmtime_jit::CompiledModule</code> is
produced and this is itself wrapped up in a <code>wasmtime::Module</code>. At this
point the module is ready to be instantiated.</p>
</li>
</ol>
<p>A <code>wasmtime::Module</code> is an atomically-reference-counted object where upon
instantiation into a <code>Store</code>, the <code>Store</code> will hold a strong reference to the
internals of the module. This means that all instances of a <code>wasmtime::Module</code>
share the same compiled code. Additionally a <code>wasmtime::Module</code> is one of the
few objects that lives outside of a <code>wasmtime::Store</code>. This means that
<code>wasmtime::Module</code>'s reference counting is its own form of memory management.</p>
<p>Note that the property of sharing a module's compiled code across all
instantiations has interesting implications on what the compiled code can
assume. For example Wasmtime implements a form of type interning, but the
interned types happen at a few different levels. Within a module we deduplicate
function types, but across modules in a <code>Store</code> types need to be represented
with the same value. This means that if the same module is instantiated into
many stores its same function type may take on many values, so the compiled
code can't assume a particular value for a function type. (more on type
information later). The general gist though is that compiled code leans
relatively heavily on the <code>VMContext</code> for contextual input because the JIT code
is intended to be so widely reusable.</p>
<h3 id="trampolines"><a class="header" href="#trampolines">Trampolines</a></h3>
<p>An important aspect to also cover for compilation is the creation of
trampolines. Trampolines in this case refer to code executed by Wasmtime to
enter WebAssembly code. The host may not always have prior knowledge about the
signature of the WebAssembly function that it wants to call. Wasmtime JIT code
is compiled with native ABIs (e.g. params/results in registers according to
System V on Unix), which means that a Wasmtime embedding doesn't have an easy
way to enter JIT code.</p>
<p>This problem is what the trampolines compiled into a module solve, which is to
provide a function with a known ABI that will call into a function with a
specific other type signature/ABI. Wasmtime collects all the exported functions
of a module and creates a set of their type signatures. Note that exported in
this context actually means "possibly exported" which includes things like
insertion into a global/function table, conversion to a <code>funcref</code>, etc. A
trampoline is generated for each of these type signatures and stored along with
the JIT code for the rest of the module.</p>
<p>These trampolines are then used with the <code>wasmtime::Func::call</code> API where in
that specific case because we don't know the ABI of the target function the
trampoline (with a known ABI) is used and has all the parameters/results passed
through the stack.</p>
<p>Another point of note is that trampolines are not deduplicated at this time.
Each compiled module contains its own set of trampolines, and if two compiled
modules have the same types then they'll have different copies of the same
trampoline.</p>
<h3 id="type-interning-and-vmsharedsignatureindex"><a class="header" href="#type-interning-and-vmsharedsignatureindex">Type Interning and <code>VMSharedSignatureIndex</code></a></h3>
<p>One important point to talk about with compilation is the
<code>VMSharedSignatureIndex</code> type and how it's used. The <code>call_indirect</code> opcode in
wasm compares an actual function's signature against the function signature of
the instruction, trapping if the signatures mismatch. This is implemented in
Wasmtime as an integer comparison, and the comparison happens on a
<code>VMSharedSignatureIndex</code> value. This index is an intern'd representation of a
function type.</p>
<p>The scope of interning for <code>VMSharedSignatureIndex</code> happens at the
<code>wasmtime::Engine</code> level. Modules are compiled into an <code>Engine</code>. Insertion of a
<code>Module</code> into an <code>Engine</code> will assign a <code>VMSharedSignatureIndex</code> to all of the
types found within the module.</p>
<p>The <code>VMSharedSignatureIndex</code> values for a module are local to that one
instantiation of a <code>Module</code> (and they may change on each insertion of a
<code>Module</code> into a different <code>Engine</code>). These are used during the instantiation
process by the runtime to assign a type ID effectively to all functions for
imports and such.</p>
<h2 id="instantiating-a-module"><a class="header" href="#instantiating-a-module">Instantiating a module</a></h2>
<p>Once a module has been compiled it's typically then instantiated to actually
get access to the exports and call wasm code. Instantiation always happens
within a <code>wasmtime::Store</code> and the created instance (plus all exports) are tied
to the <code>Store</code>.</p>
<p>Instantiation itself (<code>crates/wasmtime/src/instance.rs</code>) may look complicated,
but this is primarily due to the implementation of the Module Linking proposal.
The rough flow of instantiation looks like:</p>
<ol>
<li>
<p>First all imports are type-checked. The provided list of imports is
cross-referenced with the list of imports recorded in the
<code>wasmtime_environ::Module</code> and all types are verified to line up and match
(according to the core wasm specification's definition of type matching).</p>
</li>
<li>
<p>Each <code>wasmtime_environ::Module</code> has a list of initializers that need to be
completed before instantiation is finished. For MVP wasm this only involves
loading the import into the correct index array, but for module linking this
could involve instantiating other modules, handling <code>alias</code> fields, etc. In
any case the result of this step is a <code>wasmtime_runtime::Imports</code> array which
has the values for all imported items into the wasm module. Note that in
this case an import is typically some sort of raw pointer to the actual
state plus the <code>VMContext</code> of the instance that was imported from. The
final result of this step is an <code>InstanceAllocationRequest</code>, which is then
submitted to the configured instance allocator, either on-demand or pooling.</p>
</li>
<li>
<p>The <code>InstanceHandle</code> corresponding to this instance is allocated. How this
is allocated depends on the strategy (malloc for on-demand, slab allocation
for pooling). In addition to initialization of the fields of <code>InstanceHandle</code>
this also initializes all the fields of the <code>VMContext</code> for this handle
(which as mentioned above is adjacent to the <code>InstanceHandle</code> allocation
after it in memory). This does not process any data segments, element
segments, or the <code>start</code> function at this time.</p>
</li>
<li>
<p>At this point the <code>InstanceHandle</code> is stored within the <code>Store</code>. This is
the "point of no return" where the handle must be kept alive for the same
lifetime as the <code>Store</code> itself. If an initialization step fails then the
instance may still have had its functions, for example, inserted into an
imported table via an element segment. This means that even if we fail to
initialize this instance its state could still be visible to other
instances/objects so we need to keep it alive regardless.</p>
</li>
<li>
<p>The final step is performing wasm-defined instantiation. This involves
processing element segments, data segments, the <code>start</code> function, etc. Most
of this is just translating from Wasmtime's internal representation to the
specification's required behavior.</p>
</li>
</ol>
<p>Another part worth pointing out for instantiating a module is that a
<code>ModuleRegistry</code> is maintained within a <code>Store</code> of all instantiated modules
into the store. The purpose of this registry is to retain a strong reference to
items in the module needed to run instances. This includes the JIT code
primarily but also has information such as the <code>VMSharedSignatureIndex</code>
registration, metadata about function addresses and such, etc. Much of this
data is stored into a <code>GLOBAL_MODULES</code> map for later access during traps.</p>
<h2 id="traps"><a class="header" href="#traps">Traps</a></h2>
<p>Once instances have been created and wasm starts running most things are fairly
standard. Trampolines are used to enter wasm (or we can enter with a known ABI
if using <code>wasmtime::TypedFunc</code>) and JIT code generally does what it does to
execute wasm. An important aspect of the implementation to cover, however, is
traps.</p>
<p>Wasmtime today implements traps with <code>longjmp</code> and <code>setjmp</code>. The <code>setjmp</code>
function cannot be defined in Rust (even unsafely --
(https://github.com/rust-lang/rfcs/issues/2625) so the
<code>crates/runtime/src/helpers.c</code> file actually calls setjmp/longjmp. Note that in
general the operation of <code>longjmp</code> is not safe to execute in Rust because it
skips stack-based destructors, so after <code>setjmp</code> when we call back into Rust to
execute wasm we need to be careful in Wasmtime to not have any significant
destructors on the stack once wasm is called.</p>
<p>Traps can happen from a few different sources:</p>
<ul>
<li>
<p>Explicit traps - these can happen when a host call returns a trap, for
example. These bottom out in <code>raise_user_trap</code> or <code>raise_lib_trap</code>, both of
which immediately call <code>longjmp</code> to go back to the wasm starting point. Note
that these, like when calling wasm, have to have callers be very careful to
not have any destructors on the stack.</p>
</li>
<li>
<p>Signals - this is the main vector for trap. Basically we use segfault and
illegal instructions to implement traps in wasm code itself. Segfaults arise
when linear memory accesses go out of bounds and illegal instructions are how
the wasm <code>unreachable</code> instruction is implemented. In both of these cases
Wasmtime installs a platform-specific signal handler to catch the signal,
inspect the state of the signal, and then handle it. Note that Wasmtime tries
to only catch signals that happen from JIT code itself as to not accidentally
cover up other bugs. Exiting a signal handler happens via <code>longjmp</code> to get
back to the original wasm call-site.</p>
</li>
</ul>
<p>The general idea is that Wasmtime has very tight control over the stack frames
of wasm (naturally via Cranelift) and also very tight control over the code that
executes just before we enter wasm (aka before the <code>setjmp</code>) and just after we
reenter back into wasm (aka frames before a possible <code>longjmp</code>).</p>
<p>The signal handler for Wasmtime uses the <code>GLOBAL_MODULES</code> map populated during
instantiation to determine whether a program counter that triggered a signal is
indeed a valid wasm trap. This should be true except for cases where the host
program has another bug that triggered the signal.</p>
<p>A final note worth mentioning is that Wasmtime uses the Rust <code>backtrace</code> crate
to capture a stack trace when a wasm exception occurs. This forces Wasmtime to
generate native platform-specific unwinding information to correctly unwind the
stack and generate a stack trace for wasm code. This does have other benefits as
well such as improving generic sampling profilers when used with Wasmtime.</p>
<h2 id="linear-memory"><a class="header" href="#linear-memory">Linear Memory</a></h2>
<p>Linear memory in Wasmtime is implemented effectively with <code>mmap</code> (or the
platform equivalent thereof), but there are some subtle nuances that are worth
pointing out here too. The implementation of linear memory is relatively
configurable which gives rise to a number of situations that both the runtime
and generated code need to handle.</p>
<p>First there are a number of properties about linear memory which can be
configured:</p>
<ul>
<li><code>wasmtime::Config::static_memory_maximum_size</code></li>
<li><code>wasmtime::Config::static_memory_guard_size</code></li>
<li><code>wasmtime::Config::dynamic_memory_guard_size</code></li>
<li><code>wasmtime::Config::guard_before_linear_memory</code></li>
</ul>
<p>The methods on <code>Config</code> have a good bit of documentation to go over some
nitty-gritty, but the general gist is that Wasmtime has two modes of memory:
static and dynamic. Static memories represent an address space reservation that
never moves and pages are committed to represent memory growth. Dynamic
memories represent allocations where the committed portion exactly matches the
wasm memory's size and growth happens by allocating a bigger chunk of memory.</p>
<p>The guard size configuration indicates the size of the guard region that
happens after linear memory. This guard size affects whether generated JIT code
emits bounds checks or not. Bounds checks are elided if out-of-bounds addresses
provably encounter the guard pages.</p>
<p>The <code>guard_before_linear_memory</code> configuration additionally places guard pages
in front of linear memory as well as after linear memory (the same size on both
ends). This is only used to protect against possible Cranelift bugs and
otherwise serves no purpose.</p>
<p>The defaults for Wasmtime on 64-bit platforms are:</p>
<ul>
<li>4GB static maximum size meaning all 32-bit memories are static and 64-bit
memories are dynamic.</li>
<li>2GB static guard size meaning all loads/stores with less than 2GB offset
don't need bounds checks with 32-bit memories.</li>
<li>Guard pages before linear memory are enabled.</li>
</ul>
<p>Altogether this means that 32-bit linear memories result in an 8GB virtual
address space reservation by default in Wasmtime. With the pooling allocator
where we know that linear memories are contiguous this results in a 6GB
reservation per memory because the guard region after one memory is the guard
region before the next.</p>
<p>Note that 64-bit memories (the memory64 proposal for WebAssembly) can be
configured to be static but will never be able to elide bounds checks at this
time. This configuration is possible through the <code>static_memory_forced</code>
configuration option. Additionally note that support for 64-bit memories in
Wasmtime is functional but not yet tuned at this time so there's probably still
some performance work and better defaults to manage.</p>
<h2 id="tables-and-externref"><a class="header" href="#tables-and-externref">Tables and <code>externref</code></a></h2>
<p>WebAssembly tables contain reference types, currently either <code>funcref</code> or
<code>externref</code>. A <code>funcref</code> in Wasmtime is represented as <code>*mut VMCallerCheckedFuncRef</code> and an <code>externref</code> is represented as <code>VMExternRef</code>
(which is internally <code>*mut VMExternData</code>). Tables are consequently represented
as vectors of pointers.  Table storage memory management by default goes through
Rust's <code>Vec</code> which uses <code>malloc</code> and friends for memory. With the pooling
allocator this uses preallocated memory for storage.</p>
<p>As mentioned previously <code>Store</code> has no form of internal garbage
collection for wasm objects themselves so a <code>funcref</code> table in wasm is pretty
simple in that there's no lifetime management of any of the pointers stored
within, they're simply assumed to be valid for as long as the table is in use.</p>
<p>For tables of <code>externref</code> the story is more complicated. The <code>VMExternRef</code> is a
version of <code>Arc&lt;dyn Any&gt;</code> but specialized in Wasmtime so JIT code knows where
the offset of the reference count field to directly manipulate it is.
Furthermore tables of <code>externref</code> values need to manage the reference count
field themselves, since the pointer stored in the table is required to have a
strong reference count allocated to it.</p>
<h2 id="gc-and-externref"><a class="header" href="#gc-and-externref">GC and <code>externref</code></a></h2>
<p>Wasmtime implements the <code>externref</code> type of WebAssembly with an
atomically-reference-counted pointer. Note that the atomic part is not needed
by wasm itself but rather from the Rust embedding environment where it must be
safe to send <code>ExternRef</code> values to other threads. Wasmtime also does not
come with a cycle collector so cycles of host-allocated <code>ExternRef</code> objects
will leak.</p>
<p>Despite reference counting, though, a <code>Store::gc</code> method exists. This is an
implementation detail of how reference counts are managed while wasm code is
executing. Instead of managing the reference count of an <code>externref</code> value
individually as it moves around on the stack Wasmtime implements "deferred
reference counting" where there's an overly conservative list of <code>ExternRef</code>
values that may be in use, and periodically a GC is performed to make this
overly conservative list a precise one. This leverages the stack map support
of Cranelift plus the backtracing support of <code>backtrace</code> to determine live
roots on the stack. The <code>Store::gc</code> method forces the
possibly-overly-conservative list to become a precise list of <code>externref</code>
values that are actively in use on the stack.</p>
<h2 id="index-of-crates"><a class="header" href="#index-of-crates">Index of crates</a></h2>
<p>The main Wasmtime internal crates are:</p>
<ul>
<li><code>wasmtime</code> - the safe public API of <code>wasmtime</code>.</li>
<li><code>wasmtime-runtime</code> - low-level runtime implementation of Wasmtime. This
is where <code>VMContext</code> and <code>InstanceHandle</code> live. This crate is theoretically
agnostic to how JIT code was compiled and the runtime that it's running
within.</li>
<li><code>wasmtime-environ</code> - low-level compilation support. This is where translation
of the <code>Module</code> and its environment happens, although no compilation actually
happens in this crate (although it defines an interface for compilers). The
results of this crate are handed off to other crates for actual compilation.</li>
<li><code>wasmtime-cranelift</code> - implementation of function-level compilation using
Cranelift.</li>
</ul>
<p>Note that at this time Cranelift is a required dependency of wasmtime. Most of
the types exported from <code>wasmtime-environ</code> use cranelift types in their API. One
day it's a goal, though, to remove the required cranelift dependency and have
<code>wasmtime-environ</code> be a relatively standalone crate.</p>
<p>In addition to the above crates there are some other miscellaneous crates that
<code>wasmtime</code> depends on:</p>
<ul>
<li><code>wasmtime-cache</code> - optional dependency to manage default caches on the
filesystem. This is enabled in the CLI by default but not enabled in the
<code>wasmtime</code> crate by default.</li>
<li><code>wasmtime-fiber</code> - implementation of stack-switching used by <code>async</code> support
in Wasmtime</li>
<li><code>wasmtime-debug</code> - implementation of mapping wasm dwarf debug information to
native dwarf debug information.</li>
<li><code>wasmtime-profiling</code> - implementation of hooking up generated JIT code to
standard profiling runtimes.</li>
<li><code>wasmtime-obj</code> - implementation of creating an ELF image from compiled
functions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building"><a class="header" href="#building">Building</a></h1>
<p>This section describes everything required to build and run Wasmtime.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before we can actually build Wasmtime, we'll need to make sure these things are
installed first.</p>
<h3 id="git-submodules"><a class="header" href="#git-submodules">Git Submodules</a></h3>
<p>The Wasmtime repository contains a number of git submodules. To build Wasmtime
and most other crates in the repository, you have to ensure that those are
initialized with this command:</p>
<pre><code class="language-shell">git submodule update --init
</code></pre>
<h3 id="the-rust-toolchain"><a class="header" href="#the-rust-toolchain">The Rust Toolchain</a></h3>
<p><a href="https://www.rust-lang.org/tools/install">Install the Rust toolchain here.</a> This
includes <code>rustup</code>, <code>cargo</code>, <code>rustc</code>, etc...</p>
<h3 id="libclang-optional"><a class="header" href="#libclang-optional"><code>libclang</code> (optional)</a></h3>
<p>The <code>wasmtime-fuzzing</code> crate transitively depends on <code>bindgen</code>, which requires
that your system has a <code>libclang</code> installed. Therefore, if you want to hack on
Wasmtime's fuzzing infrastructure, you'll need <code>libclang</code>. <a href="https://rust-lang.github.io/rust-bindgen/requirements.html#clang">Details on how to
get <code>libclang</code> and make it available for <code>bindgen</code> are
here.</a></p>
<h2 id="building-the-wasmtime-cli"><a class="header" href="#building-the-wasmtime-cli">Building the <code>wasmtime</code> CLI</a></h2>
<p>To make an unoptimized, debug build of the <code>wasmtime</code> CLI tool, go to the root
of the repository and run this command:</p>
<pre><code class="language-shell">cargo build
</code></pre>
<p>The built executable will be located at <code>target/debug/wasmtime</code>.</p>
<p>To make an optimized build, run this command in the root of the repository:</p>
<pre><code class="language-shell">cargo build --release
</code></pre>
<p>The built executable will be located at <code>target/release/wasmtime</code>.</p>
<p>You can also build and run a local <code>wasmtime</code> CLI by replacing <code>cargo build</code>
with <code>cargo run</code>.</p>
<h2 id="building-the-wasmtime-c-api"><a class="header" href="#building-the-wasmtime-c-api">Building the Wasmtime C API</a></h2>
<p>To build the C API of Wasmtime you can run:</p>
<pre><code class="language-shell">cargo build --release -p wasmtime-c-api
</code></pre>
<p>This will place the shared library inside of <code>target/release</code>. On Linux it will
be called <code>libwasmtime.{a,so}</code>, on macOS it will be called
<code>libwasmtime.{a,dylib}</code>, and on Windows it will be called
<code>wasmtime.{lib,dll,dll.lib}</code>.</p>
<h2 id="building-other-wasmtime-crates"><a class="header" href="#building-other-wasmtime-crates">Building Other Wasmtime Crates</a></h2>
<p>You can build any of the Wasmtime crates by appending <code>-p wasmtime-whatever</code> to
the <code>cargo build</code> invocation. For example, to build the <code>wasmtime-environ</code> crate,
execute this command:</p>
<pre><code class="language-shell">cargo build -p wasmtime-environ
</code></pre>
<p>Alternatively, you can <code>cd</code> into the crate's directory, and run <code>cargo build</code>
there, without needing to supply the <code>-p</code> flag:</p>
<pre><code class="language-shell">cd crates/environ/
cargo build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>This section describes how to run Wasmtime's tests and add new tests.</p>
<p>Before continuing, make sure you can <a href="./contributing-building.html">build
Wasmtime</a> successfully. Can't run the tests if you
can't build it!</p>
<h2 id="installing-wasm32-targets"><a class="header" href="#installing-wasm32-targets">Installing <code>wasm32</code> Targets</a></h2>
<p>To compile the tests, you'll need the <code>wasm32-wasi</code> and
<code>wasm32-unknown-unknown</code> targets installed, which, assuming you're using
<a href="https://rustup.rs">rustup.rs</a> to manage your Rust versions, can be done as
follows:</p>
<pre><code class="language-shell">rustup target add wasm32-wasi wasm32-unknown-unknown
</code></pre>
<h2 id="running-all-tests"><a class="header" href="#running-all-tests">Running All Tests</a></h2>
<p>To run all of Wasmtime's tests, execute this command:</p>
<pre><code class="language-shell">cargo test --workspace
</code></pre>
<p>You can also exclude a particular crate from testing with <code>--exclude</code>. For
example, if you want to avoid testing the <code>wastime-fuzzing</code> crate  which
requires that <code>libclang</code> is installed on your system, and for some reason maybe
you don't have it  you can run:</p>
<pre><code class="language-shell">cargo test --workspace --exclude wasmtime-fuzzing
</code></pre>
<p>Similarly, to skip WASI integration tests, run:</p>
<pre><code class="language-shell">cargo test --workspace --exclude test-programs
</code></pre>
<h2 id="testing-a-specific-crate"><a class="header" href="#testing-a-specific-crate">Testing a Specific Crate</a></h2>
<p>You can test a particular Wasmtime crate with <code>cargo test -p wasmtime-whatever</code>. For example, to test the <code>wasmtime-environ</code> crate, execute
this command:</p>
<pre><code class="language-shell">cargo test -p wasmtime-environ
</code></pre>
<p>Alternatively, you can <code>cd</code> into the crate's directory, and run <code>cargo test</code>
there, without needing to supply the <code>-p</code> flag:</p>
<pre><code class="language-shell">cd crates/environ/
cargo test
</code></pre>
<h2 id="running-the-wasm-spec-tests"><a class="header" href="#running-the-wasm-spec-tests">Running the Wasm Spec Tests</a></h2>
<p>The spec testsuite itself is in a git submodule, so make sure you've
checked it out and initialized its submodule:</p>
<pre><code class="language-shell">git submodule update --init
</code></pre>
<p>When the submodule is checked out, Wasmtime runs the Wasm spec testsuite as part
of testing the <code>wasmtime-cli</code> crate:</p>
<pre><code class="language-shell">cargo test -p wasmtime-cli
</code></pre>
<h2 id="running-wasi-integration-tests-only"><a class="header" href="#running-wasi-integration-tests-only">Running WASI Integration Tests Only</a></h2>
<p>WASI integration tests can be run separately from all other tests which
can be useful when working on the <code>wasi-common</code> crate. This can be done by
executing this command:</p>
<pre><code class="language-shell">cargo test -p test-programs
</code></pre>
<h2 id="adding-new-tests"><a class="header" href="#adding-new-tests">Adding New Tests</a></h2>
<h3 id="adding-rusts-test-style-tests"><a class="header" href="#adding-rusts-test-style-tests">Adding Rust's <code>#[test]</code>-Style Tests</a></h3>
<p>For very "unit-y" tests, we add <code>test</code> modules in the same <code>.rs</code> file as the
code that is being tested. These <code>test</code> modules are configured to only get
compiled during testing with <code>#[cfg(test)]</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// some code...

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn some_test_for_that_code() {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If you're writing a unit test and a <code>test</code> module doesn't already exist, you can
create one.</p>
<p>For more "integration-y" tests, we create a <code>tests</code> directory within the crate,
and put the tests inside there. For example, there are various code
cache-related tests at <code>crates/environ/tests/cache_*.rs</code>. Always feel free to
add a <code>tests</code> directory to a crate, if you want to add a new test and there
aren't any existing tests.</p>
<h3 id="adding-specification-style-wast-tests"><a class="header" href="#adding-specification-style-wast-tests">Adding Specification-Style Wast Tests</a></h3>
<p>We use the spec testsuite as-is and without custom patches or a forked
version. This probably isn't what you want to modify when adding a new Wasmtime
test!</p>
<p>When you have a Wasmtime-specific test that you'd like to write in Wast and use
the Wast-style assertions, you can add it to our "misc testsuite". The misc
testsuite uses the same syntax and assertions as the spec testsuite, but lives
in <code>tests/misc_testsuite</code>. Feel free to add new tests to existing
<code>tests/misc_testsuite/*.wast</code> files or create new ones as needed. These tests
are run as part of the <code>wasmtime-cli</code> crate's tests.</p>
<p>If you have a new test that you think really belongs in the spec testsuite, make
sure it makes sense for every Wasm implementation to run your test (i.e. it
isn't Wasmtime-specific) and send a pull request
<a href="https://github.com/WebAssembly/testsuite/">upstream</a>. Once it is accepted in
the upstream repo, we can update our git submodule and we'll start running the
new tests.</p>
<h3 id="adding-wasi-integration-tests"><a class="header" href="#adding-wasi-integration-tests">Adding WASI Integration Tests</a></h3>
<p>When you have a WASI-specific test program that you'd like to include as a
test case to run against our WASI implementation, you can add it to our
<code>test-programs</code> crate. In particular, you should drop a main-style Rust source
file into <code>crates/test-programs/wasi-tests/src/bin/some_new_test.rs</code> with a
name of your choice. And that's it! The build script included in the
<code>test-programs</code> crate will automatically generate the necessary boilerplate
code for your test program so that it's run on all supported hosts.</p>
<p>If you would like to tweak which host to run the test program against however
(for instance, only on Unix but on Windows), you can tweak that in the build
script located under <code>crates/test-programs/build.rs</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fuzzing"><a class="header" href="#fuzzing">Fuzzing</a></h1>
<h2 id="test-case-generators-and-oracles"><a class="header" href="#test-case-generators-and-oracles">Test Case Generators and Oracles</a></h2>
<p>Test case generators and oracles live in the <code>wasmtime-fuzzing</code> crate, located
in the <code>crates/fuzzing</code> directory.</p>
<p>A <em>test case generator</em> takes raw, unstructured input from a fuzzer and
translates that into a test case. This might involve interpreting the raw input
as "DNA" or pre-determined choices through a decision tree and using it to
generate an in-memory data structure, or it might be a no-op where we interpret
the raw bytes as if they were Wasm.</p>
<p>An <em>oracle</em> takes a test case and determines whether we have a bug. For example,
one of the simplest oracles is to take a Wasm binary as an input test case,
validate and instantiate it, and (implicitly) check that no assertions failed or
segfaults happened. A more complicated oracle might compare the result of
executing a Wasm file with and without optimizations enabled, and make sure that
the two executions are observably identical.</p>
<p>Our test case generators and oracles strive to be fuzzer-agnostic: they can be
reused with libFuzzer or AFL or any other fuzzing engine or driver.</p>
<h2 id="libfuzzer-and-cargo-fuzz-fuzz-targets"><a class="header" href="#libfuzzer-and-cargo-fuzz-fuzz-targets">libFuzzer and <code>cargo fuzz</code> Fuzz Targets</a></h2>
<p>We combine a test case generator and one more more oracles into a <em>fuzz
target</em>. Because the target needs to pipe the raw input from a fuzzer into the
test case generator, it is specific to a particular fuzzer. This is generally
fine, since they're only a couple of lines of glue code.</p>
<p>Currently, all of our fuzz targets are written for
<a href="https://www.llvm.org/docs/LibFuzzer.html">libFuzzer</a> and <a href="https://rust-fuzz.github.io/book/cargo-fuzz.html"><code>cargo fuzz</code></a>. They are defined in
the <code>fuzz</code> subdirectory.</p>
<p>See
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/fuzz/README.md"><code>fuzz/README.md</code></a>
for details on how to run these fuzz targets and set up a corpus of seed inputs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration-ci"><a class="header" href="#continuous-integration-ci">Continuous Integration (CI)</a></h1>
<p>The Wasmtime and Cranelift projects heavily rely on Continuous Integration (CI)
to ensure everything keeps working and keep the final end state of the code at
consistently high quality. The CI setup for this repository is relatively
involved and extensive, and so it's worth covering here how it's organized and
what's expected of contributors.</p>
<p>All CI currently happens on GitHub Actions and is configured in the <a href="https://github.com/bytecodealliance/wasmtime/tree/main/.github"><code>.github</code>
directory</a> of the repository.</p>
<h2 id="prs-and-ci"><a class="header" href="#prs-and-ci">PRs and CI</a></h2>
<p>Currently on sample of the full CI test suite is run on every Pull Request. CI
on PRs is intended to be relatively quick and catch the majority of mistakes and
errors. By default the test suite is run on x86_64 Linux but this may change
depending on what files the PR is modifying. The intention is to run "mostly
relevant" CI on a PR by default.</p>
<p>PR authors are expected to fix CI failures in their PR, unless the CI failure is
systemic and unrelated to the PR. In that case other maintainers should be
alerted to ensure that the problem can be addressed. Some reviewers may also
wait to perform a review until CI is green on the PR as otherwise it may
indicate changes are needed.</p>
<p>The Wasmtime repository uses GitHub's Merge Queue feature to merge PRs which.
Entry in to the merge queue requires green CI on the PR beforehand. Maintainers
who have approved a PR will flag it for entry into the merge queue, and the PR
will automatically enter the merge queue once CI is green.</p>
<p>When entering the merge queue a PR will have the full test suite executed which
may include tests that weren't previously run on the PR. This may surface new
failures, and contributors are expected to fix these failures as well.</p>
<p>To force PRs to execute the full test suite, which takes longer than the default
test suite for PRs, then contributors can place the string "prtest:full"
somewhere in any commit of the PR. From that point on the PR will automatically
run the full test suite as-if it were in the merge queue. Note that when going
through the merge queue this will rerun tests.</p>
<h2 id="tests-run-on-ci"><a class="header" href="#tests-run-on-ci">Tests run on CI</a></h2>
<p>While this may not be fully exhaustive, the general idea of all the checks we
run on CI looks like this:</p>
<ul>
<li>
<p>Code formatting - we run <code>cargo fmt -- --check</code> on CI to ensure that all code
in the repository is formatted with rustfmt. All PRs are expected to be
formatted with the latest stable version of rustfmt.</p>
</li>
<li>
<p>Book documentation tests - code snippets (Rust ones at least) in the book
documentation (<a href="https://github.com/bytecodealliance/wasmtime/tree/main/docs">the <code>docs</code>
folder</a>) are
tested on CI to ensure they are working.</p>
</li>
<li>
<p>Crate tests - the moral equivalent of <code>cargo test --all</code> and <code>cargo test --all --release</code> is executed on CI. This means that all workspace crates have their
entire test suite run, documentation tests and all, in both debug and release
mode. Additionally we execute all crate tests on macOS, Windows, and Linux, to
ensure that everything works on all the platforms.</p>
</li>
<li>
<p>Fuzz regression tests - we take a random sampling of the <a href="https://github.com/bytecodealliance/wasmtime-libfuzzer-corpus">fuzz
corpus</a> and run
it through the fuzzers. This is mostly intended to be a pretty quick
regression test and testing the fuzzers still build, most of our fuzzing
happens on <a href="https://oss-fuzz.com">oss-fuzz</a>. Found issues are recorded in
the <a href="https://bugs.chromium.org/p/oss-fuzz/issues/list?q=-status%3AWontFix%2CDuplicate%20-component%3AInfra%20proj%3Awasmtime&amp;can=1">oss-fuzz bug tracker</a></p>
</li>
</ul>
<p>While we do run more tests here and there, this is the general shape of what you
can be expected to get tested on CI for all commits and all PRs. You can of
course always feel free to expand our CI coverage by editing the CI files
themselves, we always like to run more tests!</p>
<h2 id="artifacts-produced-on-ci"><a class="header" href="#artifacts-produced-on-ci">Artifacts produced on CI</a></h2>
<p>Our CI system is also responsible for producing all binary releases and
documentation of Wasmtime and Cranelift. Currently this consists of:</p>
<ul>
<li>
<p>Tarballs of the <code>wasmtime</code> CLI - produced for macOS, Windows, and Linux we try
to make these "binary compatible" wherever possible, for example producing the
Linux build in a really old CentOS container to have a very low glibc
requirement.</p>
</li>
<li>
<p>Tarballs of the Wasmtime C API - produced for the same set of platforms as the
CLI above.</p>
</li>
<li>
<p>Book and API documentation - the book is rendered with <code>mdbook</code> and we also
build all documentation with <code>cargo doc</code>.</p>
</li>
<li>
<p>A source code tarball which is entirely self-contained. This source tarball
has all dependencies vendored so the network is not needed to build it.</p>
</li>
<li>
<p>WebAssembly adapters for the component model to translate
<code>wasi_snapshot_preview1</code> to WASI Preview 2.</p>
</li>
</ul>
<p>Artifacts are produced as part of the full CI suite. This means that artifacts
are not produced on a PR by default but can be requested via "prtest:full". All
runs through the merge queue though, which means all merges to <code>main</code>, will
produce a full suite of artifacts. The latest artifacts are available through
Wasmtime's <a href="https://github.com/bytecodealliance/wasmtime/releases/tag/dev"><code>dev</code> release</a> and downloads are also available for recent CI
runs through the CI page in GitHub Actions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reducing-test-cases"><a class="header" href="#reducing-test-cases">Reducing Test Cases</a></h1>
<p>When reporting a bug, or investing a bug report, in Wasmtime it is easier for
everyone involved when there is a test case that reproduces the bug. It is even
better when that test case is as small as possible, so that developers don't
need to wade through megabytes of unrelated Wasm that isn't necessary to
showcase the bug. The process of taking a large test case and stripping out the
unnecessary bits is called <em>test case reduction</em>.</p>
<p><a href="github.com/bytecodealliance/wasm-tools">The <code>wasm-tools shrink</code> tool</a> can
automatically reduce Wasm test cases when given</p>
<ol>
<li>the original, unreduced test case, and</li>
<li>a predicate script to determine whether the bug reproduces on a given reduced
test case candidate.</li>
</ol>
<p>If the test case causes Wasmtime to segfault, the script can run Wasmtime and
check its exit code. If the test case produces a different result in Wasmtime vs
another Wasm engine, the script can run both engines and compare their
results. It is also often useful to <code>grep</code> through the candidate's WAT
disassembly to make sure that relevant features and instructions are present.</p>
<h2 id="case-study-issue-7779"><a class="header" href="#case-study-issue-7779">Case Study: <a href="https://github.com/bytecodealliance/wasmtime/issues/7779">Issue #7779</a></a></h2>
<p>A bug was reported involving the <code>memory.init</code> instruction. The attached test
case was larger than it needed to be and contained a bunch of functions and
other things that were irrelevant. A perfect use case for <code>wasm-tools shrink</code>!</p>
<p>First, we needed a predicate script to identify the reported buggy behavior. The
script is given the candidate test case as its first argument and must exit zero
if the candidate exhibits the bug and non-zero otherwise.</p>
<pre><code class="language-bash">#!/usr/bin/env bash

# Propagate failure: exit non-zero if any individual command exits non-zero.
set -e

# Disassembly the candidate into WAT. Make sure the `memory.init` instruction
# is present, since the bug report is about that instruction. Additionally, make
# sure it is referencing the same data segment.
wasm-tools print $1 | grep -q 'memory.init 2'

# Make sure that the data segment in question remains unchanged, as mutating its
# length can change the semantics of the `memory.init` instruction.
wasm-tools print $1 | grep -Eq '\(data \(;2;\) \(i32\.const 32\) "\\01\\02\\03\\04\\05\\06\\07\\08\\ff"\)'

# Make sure that the `_start` function that contains the `memory.init` is still
# exported, so that running the Wasm will run the `memory.init` instruction.
wasm-tools print $1 | grep -Eq '\(export "_start" \(func 0\)\)'

# Run the testcase in Wasmtime and make sure that it traps the same way as the
# original test case.
cargo run --manifest-path ~/wasmtime/Cargo.toml -- run $1 2&gt;&amp;1 \
    | grep -q 'wasm trap: out of bounds memory access'
</code></pre>
<p>Note that this script is a little fuzzy! It just checks for <code>memory.init</code> and a
particular trap. That trap can correctly occur according to Wasm semantics when
<code>memory.init</code> is given certain inputs! This means we need to double check that
the reduced test case actually exhibits a real bug and its inputs haven't been
transformed into something that Wasm semantics specify should indeed
trap. Sometimes writing very precise predicate scripts is difficult, but we do
the best we can and usually it works out fine.</p>
<p>With the predicate script in hand, we can automatically reduce the original test
case:</p>
<pre><code class="language-shell-session">$ wasm-tools shrink predicate.sh test-case.wasm
369 bytes (1.07% smaller)
359 bytes (3.75% smaller)
357 bytes (4.29% smaller)
354 bytes (5.09% smaller)
344 bytes (7.77% smaller)
...
118 bytes (68.36% smaller)
106 bytes (71.58% smaller)
94 bytes (74.80% smaller)
91 bytes (75.60% smaller)
90 bytes (75.87% smaller)

test-case.shrunken.wasm :: 90 bytes (75.87% smaller)
================================================================================
(module
  (type (;0;) (func))
  (func (;0;) (type 0)
    (local i32 f32 i64 f64)
    i32.const 0
    i32.const 9
    i32.const 0
    memory.init 2
  )
  (memory (;0;) 1 5)
  (export "_start" (func 0))
  (data (;0;) (i32.const 8) "")
  (data (;1;) (i32.const 16) "")
  (data (;2;) (i32.const 32) "\01\02\03\04\05\06\07\08\ff")
)
================================================================================
</code></pre>
<p>In this case, the arguments to the original <code>memory.init</code> instruction haven't
changed, and neither has the relevant data segment, so the reduced test case
should exhibit the same behavior as the original.</p>
<p>In the end, it was <a href="https://github.com/bytecodealliance/wasmtime/issues/7779#issuecomment-1894350625">determined that Wasmtime was behaving as
expected</a>,
but the presence of the reduced test case makes it much easier to make that
determination.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-compiling"><a class="header" href="#cross-compiling">Cross Compiling</a></h1>
<p>When contributing to Wasmtime and Cranelift you may run into issues that only
reproduce on a different architecture from your development machine. Luckily,
<code>cargo</code> makes cross compilation and running tests under <a href="https://www.qemu.org/">QEMU</a> pretty easy.</p>
<p>This guide will assume you are on an x86-64 with Ubuntu/Debian as your OS. The
basic approach (with commands, paths, and package names appropriately tweaked)
applies to other Linux distributions as well.</p>
<p>On Windows you can install build tools for AArch64 Windows, but targeting
platforms like Linux or macOS is not easy. While toolchains exist for targeting
non-Windows platforms you'll have to hunt yourself to find the right one.</p>
<p>On macOS you can install, through Xcode, toolchains for iOS but the main
<code>x86_64-apple-darwin</code> is really the only easy target to install. You'll need to
hunt for toolchains if you want to compile for Linux or Windows.</p>
<h2 id="install-rust-targets"><a class="header" href="#install-rust-targets">Install Rust Targets</a></h2>
<p>First, use <code>rustup</code> to install Rust targets for the other architectures that
Wasmtime and Cranelift support:</p>
<pre><code class="language-shell">$ rustup target add \
    s390x-unknown-linux-gnu \
    riscv64gc-unknown-linux-gnu \
    aarch64-unknown-linux-gnu
</code></pre>
<h2 id="install-gcc-cross-compilation-toolchains"><a class="header" href="#install-gcc-cross-compilation-toolchains">Install GCC Cross-Compilation Toolchains</a></h2>
<p>Next, you'll need to install a <code>gcc</code> for each cross-compilation target to serve
as a linker for <code>rustc</code>.</p>
<pre><code class="language-shell">$ sudo apt install \
    gcc-s390x-linux-gnu \
    gcc-riscv64-linux-gnu \
    gcc-aarch64-linux-gnu
</code></pre>
<h2 id="install-qemu"><a class="header" href="#install-qemu">Install <code>qemu</code></a></h2>
<p>You will also need to install <code>qemu</code> to emulate the cross-compilation targets.</p>
<pre><code class="language-shell">$ sudo apt install qemu-user
</code></pre>
<h2 id="configure-cargo"><a class="header" href="#configure-cargo">Configure Cargo</a></h2>
<p>The final bit to get out of the way is to configure <code>cargo</code> to use the
appropriate <code>gcc</code> and <code>qemu</code> when cross-compiling and running tests for other
architectures.</p>
<p>Add this to <code>.cargo/config.toml</code> in the Wasmtime repository (or create that file
if none already exists).</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-gnu]
linker = "aarch64-linux-gnu-gcc"
runner = "qemu-aarch64 -L /usr/aarch64-linux-gnu -E LD_LIBRARY_PATH=/usr/aarch64-linux-gnu/lib -E WASMTIME_TEST_NO_HOG_MEMORY=1"

[target.riscv64gc-unknown-linux-gnu]
linker = "riscv64-linux-gnu-gcc"
runner = "qemu-riscv64 -L /usr/riscv64-linux-gnu -E LD_LIBRARY_PATH=/usr/riscv64-linux-gnu/lib -E WASMTIME_TEST_NO_HOG_MEMORY=1"

[target.s390x-unknown-linux-gnu]
linker = "s390x-linux-gnu-gcc"
runner = "qemu-s390x -L /usr/s390x-linux-gnu -E LD_LIBRARY_PATH=/usr/s390x-linux-gnu/lib -E WASMTIME_TEST_NO_HOG_MEMORY=1"
</code></pre>
<h2 id="cross-compile-tests-and-run-them"><a class="header" href="#cross-compile-tests-and-run-them">Cross-Compile Tests and Run Them!</a></h2>
<p>Now you can use <code>cargo build</code>, <code>cargo run</code>, and <code>cargo test</code> as you normally
would for any crate inside the Wasmtime repository, just add the appropriate
<code>--target</code> flag!</p>
<p>A few examples:</p>
<ul>
<li>
<p>Build the <code>wasmtime</code> binary for <code>aarch64</code>:</p>
<pre><code class="language-shell">$ cargo build --target aarch64-unknown-linux-gnu
</code></pre>
</li>
<li>
<p>Run the tests under <code>riscv</code> emulation:</p>
<pre><code class="language-shell">$ cargo test --target riscv64gc-unknown-linux-gnu
</code></pre>
</li>
<li>
<p>Run the <code>wasmtime</code> binary under <code>s390x</code> emulation:</p>
<pre><code class="language-shell">$ cargo run --target s390x-unknown-linux-gnu -- compile example.wasm
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coding-guidelines"><a class="header" href="#coding-guidelines">Coding guidelines</a></h1>
<p>For the most part, Wasmtime and Cranelift follow common Rust conventions and
<a href="https://help.github.com/articles/about-pull-requests/">pull request</a> (PR) workflows, though we do have a few additional things to
be aware of.</p>
<h3 id="rustfmt"><a class="header" href="#rustfmt"><code>rustfmt</code></a></h3>
<p>All PRs must be formatted according to rustfmt, and this is checked in the
continuous integration tests. You can format code locally with:</p>
<pre><code class="language-sh">$ cargo fmt
</code></pre>
<p>at the root of the repository. You can find <a href="https://github.com/rust-lang/rustfmt">more information about rustfmt
online</a> too, such as how to configure
your editor.</p>
<h3 id="minimum-supported-rustc-version"><a class="header" href="#minimum-supported-rustc-version">Minimum Supported <code>rustc</code> Version</a></h3>
<p>Wasmtime and Cranelift support the latest three stable releases of Rust. This
means that if the latest version of Rust is 1.72.0 then Wasmtime supports Rust
1.70.0, 1.71.0, and 1.72.0. CI will test by default with 1.72.0 and there will
be one job running the full test suite on Linux x86_64 on 1.70.0.</p>
<p>Some of the CI jobs depend on nightly Rust, for example to run rustdoc with
nightly features, however these use pinned versions in CI that are updated
periodically and the general repository does not depend on nightly features.</p>
<p>Updating Wasmtime's MSRV is done by editing the <code>rust-version</code> field in the
workspace root's <code>Cargo.toml</code></p>
<h3 id="dependencies-of-wasmtime"><a class="header" href="#dependencies-of-wasmtime">Dependencies of Wasmtime</a></h3>
<p>Wasmtime and Cranelift have a higher threshold than default for adding
dependencies to the project. All dependencies are required to be "vetted"
through the <a href="https://mozilla.github.io/cargo-vet/"><code>cargo vet</code> tool</a>. This is
checked on CI and will run on all modifications to <code>Cargo.lock</code>.</p>
<p>A "vet" for Wasmtime is not a meticulous code review of a dependency for
correctness but rather it is a statement that the crate does not contain
malicious code and is safe for us to run during development and (optionally)
users to run when they run Wasmtime themselves. Wasmtime's vet entries are used
by other organizations which means that this isn't simply for our own personal
use. Wasmtime additionally uses vet entries from other organizations as well
which means we don't have to vet everything ourselves.</p>
<p>New vet entries are required to be made by trusted contributors to Wasmtime.
This is all configured in the <code>supply-chain</code> folder of Wasmtime. These files
generally aren't hand-edited though and are instead managed through the <code>cargo vet</code> tool itself. Note that our <code>supply-chain/audits.toml</code> additionally contains
entries which indicates that authors are trusted as opposed to vets of
individual crates. This lowers the burden of updating version of a crate from a
trusted author.</p>
<p>When put together this means that contributions to Wasmtime and Cranelift which
update existing dependencies or add new dependencies will not be mergeable by
default (CI will fail). This is expected from our project's configuration and
this situation will be handled one of a few ways:</p>
<p>Note that this process is not in place to prevent new dependencies or prevent
updates, but rather it ensures that development of Wasmtime is done with a
trusted set of code that has been reviewed by trusted parties. We welcome
dependency updates and new functionality, so please don't be too alarmed when
contributing and seeing a failure of <code>cargo vet</code> on CI!</p>
<h3 id="cargo-vet-for-contributors"><a class="header" href="#cargo-vet-for-contributors"><code>cargo vet</code> for Contributors</a></h3>
<p>If you're a contributor to Wasmtime and you've landed on this documentation,
hello and thanks for your contribution! Here's some guidelines for changing the
set of dependencies in Wasmtime:</p>
<ul>
<li>
<p>If a new dependency is being added it might be worth trying to slim down
what's required or avoiding the dependency altogether. Avoiding new
dependencies is best when reasonable, but it is not always reasonable to do
so. This is left to the judgement of the author and reviewer.</p>
</li>
<li>
<p>When updating dependencies this should be done for a specific purpose relevant
to the PR-at-hand. For example if the PR implements a new feature then the
dependency update should be required for the new feature. Otherwise it's best
to leave dependency updates to their own PRs. It's ok to update dependencies
"just for the update" but we prefer to have that as separate PRs.</p>
</li>
</ul>
<p>Dependency additions or updates require action on behalf of project maintainers
so we ask that you don't run <code>cargo vet</code> yourself or update the <code>supply-chain</code>
folder yourself. Instead a maintainer will review your PR and push a commit to
your PR which performs the vets as necessary. Note that reviewers will be
verifying that you haven't yourself made changes and that the changes they
approve to be merged match what they've done. It's still ok to rebase your PR if
needed, but we ask that if a maintainer has pushed a <code>cargo vet</code> entry update
that you leave it as a separate commit.</p>
<h3 id="cargo-vet-for-maintainers"><a class="header" href="#cargo-vet-for-maintainers"><code>cargo vet</code> for Maintainers</a></h3>
<p>Maintainers of Wasmtime are required to explicitly vet and approve all
dependency updates and modifications to Wasmtime. This means that when reviewing
a PR you should ensure that contributors are not modifying the <code>supply-chain</code>
directory themselves outside of commits authored by other maintainers. Otherwise
though to add vet entries this is done through one of a few methods:</p>
<ul>
<li>
<p>For a PR where maintainers themselves are modifying dependencies the <code>cargo vet</code> entries can be included inline with the PR itself by the author. The
reviewer knows that the author of the PR is themself a maintainer.</p>
</li>
<li>
<p>PRs that "just update dependencies" are ok to have at any time. You can do
this in preparation for a future feature or for a future contributor. This
more-or-less is the same as the previous categories.</p>
</li>
<li>
<p>For contributors who should not add vet entries themselves maintainers should
review the PR and then when the PR is ready to be approved the maintainer
should push a commit to the contributor's PR directly. Maintainers should
check out the PR locally, apply <code>cargo vet</code> entries as needed, and then push
to the contributor's PR directly.</p>
</li>
</ul>
<p>Note for the last case it's important to ensure that after you push to the PR
any future updates pushed by the contributor either contain or don't overwrite
your vet entries. Also verify that if the PR branch is rebased or force-pushed,
the details of your previously pushed vetting remain the same: e.g., versions
were not bumped and descriptive reasons remain the same. If pushing a vetting
commit to a contributor's PR and also asking for more changes, request that the
contributor make the requested fixes in an additional commit rather than
force-pushing a rewritten history, so your existing vetting commit remains
untouched. These guidelines make it easier to verify no tampering has occurred</p>
<h3 id="policy-for-adding-cargo-vet-entries"><a class="header" href="#policy-for-adding-cargo-vet-entries">Policy for adding <code>cargo vet</code> entries</a></h3>
<p>For maintainers this is intended to document the project's policy on adding
<code>cargo vet</code> entries. The goal of this policy is to not make dependency updates
so onerous that they never happen while still achieving much of the intended
benefit of <code>cargo vet</code> in protection against supply-chain style attacks.</p>
<ul>
<li>
<p>For dependencies <strong>that receive at least 10,000 downloads a day</strong> on crates.io
it's ok to add an entry to <code>exemptions</code> in <code>supply-chain/config.toml</code>. This
does not require careful review or review at all of these dependencies. The
assumption here is that a supply chain attack against a popular crate is
statistically likely to be discovered relatively quickly. Changes to <code>main</code> in
Wasmtime take at least 2 weeks to be released due to our release process, so
the assumption is that popular crates that are victim of a supply chain attack
would be discovered during this time. This policy additionally greatly helps
when updating dependencies on popular crates that are common to see without
increasing the burden too much on maintainers.</p>
</li>
<li>
<p>For other dependencies a manual vet is required. The <code>cargo vet</code> tool will
assist in adding a vet by pointing you towards the source code, as published
on crates.io, to be browsed online. Manual review should be done to ensure
that "nothing nefarious" is happening. For example <code>unsafe</code> should be
inspected as well as use of ambient system capabilities such as <code>std::fs</code>,
<code>std::net</code>, or <code>std::process</code>, and build scripts. Note that you're not
reviewing for correctness, instead only for whether a supply-chain attack
appears to be present.</p>
</li>
</ul>
<p>This policy intends to strike a rough balance between usability and security.
It's always recommended to add vet entries where possible, but the first bullet
above can be used to update an <code>exemptions</code> entry or add a new entry. Note that
when the "popular threshold" is used <strong>do not add a vet entry</strong> because the
crate is, in fact, not vetted. This is required to go through an
<code>[[exemptions]]</code> entry.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-process"><a class="header" href="#development-process">Development Process</a></h1>
<p>We use <a href="https://guides.github.com/features/issues/">issues</a> for asking questions (<a href="https://github.com/bytecodealliance/wasmtime/issues/new">open one here</a>!) and tracking
bugs and unimplemented features, and <a href="https://help.github.com/articles/about-pull-requests/">pull requests</a> (PRs) for tracking and
reviewing code submissions.</p>
<h3 id="before-submitting-a-pr"><a class="header" href="#before-submitting-a-pr">Before submitting a PR</a></h3>
<p>Consider opening an issue to talk about it. PRs without corresponding issues
are appropriate for fairly narrow technical matters, not for fixes to
user-facing bugs or for feature implementations, especially when those features
might have multiple implementation strategies that usefully could be discussed.</p>
<p>Our issue templates might help you through the process.</p>
<h3 id="when-submitting-prs"><a class="header" href="#when-submitting-prs">When submitting PRs</a></h3>
<ul>
<li>
<p>Please answer the questions in the pull request template. They are the
minimum information we need to know in order to understand your changes.</p>
</li>
<li>
<p>Write clear commit messages that start with a one-line summary of the
change (and if it's difficult to summarize in one line, consider
splitting the change into multiple PRs), optionally followed by
additional context. Good things to mention include which areas of the
code are affected, which features are affected, and anything that
reviewers might want to pay special attention to.</p>
</li>
<li>
<p>If there is code which needs explanation, prefer to put the explanation in a
comment in the code, or in documentation, rather than in the commit message.
Commit messages should explain why the new version is better than the old.</p>
</li>
<li>
<p>Please include new test cases that cover your changes, if you can. If you're
not sure how to do that, we'll help you during our review process.</p>
</li>
<li>
<p>For pull requests that fix existing issues, use <a href="https://help.github.com/articles/closing-issues-using-keywords/">issue keywords</a>. Note that
not all pull requests need to have accompanying issues.</p>
</li>
<li>
<p>When updating your pull request, please make sure to re-request review if
the request has been cancelled.</p>
</li>
</ul>
<h3 id="focused-commits-or-squashing"><a class="header" href="#focused-commits-or-squashing">Focused commits or squashing</a></h3>
<p>We are not picky about how your git commits are structured. When we merge your
PR, we will squash all of your commits into one, so it's okay if you add fixes
in new commits.</p>
<p>We appreciate it if you can organize your work into separate commits which each
make one focused change, because then we can more easily understand your
changes during review. But we don't require this.</p>
<p>Once someone has reviewed your PR, it's easier for us if you <em>don't</em> rebase it
when making further changes. Instead, at that point we prefer that you make new
commits on top of the already-reviewed work.</p>
<p>That said, sometimes we may need to ask you to rebase for various technical
reasons. If you need help doing that, please ask!</p>
<h3 id="review-and-merge"><a class="header" href="#review-and-merge">Review and merge</a></h3>
<p>Anyone may submit a pull request, and anyone may comment on or review others'
pull requests. However, one review from somebody in the <a href="https://github.com/orgs/bytecodealliance/people/">Core Team</a> is required
before the Core Team merges it.</p>
<p>Even Core Team members must create PRs and get review from another Core Team
member for every change, including minor work items such as version bumps,
removing warnings, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-webassembly-proposals"><a class="header" href="#implementing-webassembly-proposals">Implementing WebAssembly Proposals</a></h1>
<h2 id="adding-new-support-for-a-wasm-proposal"><a class="header" href="#adding-new-support-for-a-wasm-proposal">Adding New Support for a Wasm Proposal</a></h2>
<p>The following checkboxes enumerate the steps required to add support for a new
WebAssembly proposal to Wasmtime. They can be completed over the course of
multiple pull requests.</p>
<ul>
<li>
<p><input type="checkbox"/> Add support to the
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasmparser"><code>wasmparser</code></a>
crate.</p>
</li>
<li>
<p><input type="checkbox"/> Add support to the
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wat"><code>wat</code></a>
and
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wast"><code>wast</code></a>
crates.</p>
</li>
<li>
<p><input type="checkbox"/> Add support to the
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasmprinter"><code>wasmprinter</code></a>
crate.</p>
</li>
<li>
<p><input type="checkbox"/> Add support to the
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-encoder"><code>wasm-encoder</code></a>
crate.</p>
</li>
<li>
<p><input type="checkbox"/> Add support to the
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasm-smith"><code>wasm-smith</code></a>
crate.</p>
</li>
<li>
<p><input type="checkbox"/> Add a <code>wasmtime::Config::enable_foo_bar</code> method to
the <code>wasmtime</code> crate.</p>
</li>
<li>
<p><input type="checkbox"/> Add a <code>--enable-foo-bar</code> command line flag to the
<code>wasmtime</code> binary.</p>
</li>
<li>
<p><input type="checkbox"/> Enable the spec tests in
<a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/build.rs#L41-L52"><code>build.rs</code></a>
but <a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/build.rs#L196">mark them as
ignored</a>
for now.</p>
</li>
<li>
<p><input type="checkbox"/> Stop ignoring individual spec tests and get them
passing one by one.</p>
</li>
<li>
<p><input type="checkbox"/> Enable the proposal in <a href="./contributing-fuzzing.html">the fuzz
targets</a>.</p>
<ul>
<li>
<p><input type="checkbox"/> Add examples from the spec tests to <a href="https://github.com/bytecodealliance/wasmtime-libfuzzer-corpus">the relevant
corpora</a>.</p>
<blockquote>
<p>The <code>wast2json</code> tool from <a href="https://github.com/WebAssembly/wabt/">WABT</a> is useful for this.</p>
</blockquote>
</li>
<li>
<p><input type="checkbox"/> Write a custom fuzz target, oracle, and/or test
case generator for fuzzing this proposal in particular.</p>
<blockquote>
<p>For example, we wrote a <a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/crates/fuzzing/src/generators/table_ops.rs">custom
generator</a>,
<a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/crates/fuzzing/src/oracles.rs#L417-L467">oracle</a>,
and <a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/fuzz/fuzz_targets/table_ops.rs">fuzz
target</a>
for exercising <code>table.{get,set}</code> instructions and their interaction with
GC while implementing the reference types proposal.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><input type="checkbox"/> Expose the proposal's new functionality in the
<code>wasmtime</code> crate's API.</p>
<blockquote>
<p>For example, the bulk memory operations proposal introduced a <code>table.copy</code>
instruction, and we exposed its functionality as the <code>wasmtime::Table::copy</code>
method.</p>
</blockquote>
</li>
<li>
<p><input type="checkbox"/> Expose the proposal's new functionality in the C API.</p>
<blockquote>
<p>This may require extensions to the standard C API, and if so, should be
defined in
<a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/crates/c-api/include/wasmtime.h"><code>wasmtime.h</code></a>
and prefixed with <code>wasmtime_</code>.</p>
</blockquote>
</li>
<li>
<p><input type="checkbox"/> Use the C API to expose the proposal's new
functionality in the other language embedding APIs:</p>
<ul>
<li>
<p><input type="checkbox"/> <a href="https://github.com/bytecodealliance/wasmtime-py/">Python</a></p>
</li>
<li>
<p><input type="checkbox"/> <a href="https://github.com/bytecodealliance/wasmtime-go/">Go</a></p>
</li>
<li>
<p><input type="checkbox"/> <a href="https://github.com/bytecodealliance/wasmtime-dotnet/">.NET</a></p>
</li>
</ul>
</li>
<li>
<p><input type="checkbox"/> Document support for the proposal in
<code>wasmtime/docs/stability-wasm-proposals-support.md</code>.</p>
</li>
</ul>
<h2 id="enabling-support-for-a-proposal-by-default"><a class="header" href="#enabling-support-for-a-proposal-by-default">Enabling Support for a Proposal by Default</a></h2>
<p>These are the standards that must be met to enable support for a proposal by
default in Wasmtime, and can be used as a review checklist.</p>
<ul>
<li>
<p><input type="checkbox"/> The proposal must be in phase 4, or greater, of <a href="https://github.com/WebAssembly/meetings/blob/master/process/phases.md">the
WebAssembly standardization process</a>.</p>
</li>
<li>
<p><input type="checkbox"/> All spec tests must be passing in Wasmtime.</p>
</li>
<li>
<p><input type="checkbox"/> No open questions, design concerns, or serious known
bugs.</p>
</li>
<li>
<p><input type="checkbox"/> Has been fuzzed for at least a week minimum.</p>
</li>
<li>
<p><input type="checkbox"/> We are confident that the fuzzers are fully
exercising the proposal's functionality.</p>
<blockquote>
<p>For example, it would <em>not</em> have been enough to simply enable reference
types in the <code>compile</code> fuzz target to enable that proposal by
default. Compiling a module that uses reference types but not instantiating
it nor running any of its functions doesn't exercise any of the GC
implementation and does not run the inline fast paths for <code>table</code> operations
emitted by the JIT. Exercising these things was the motivation for writing
the custom fuzz target for <code>table.{get,set}</code> instructions.</p>
</blockquote>
</li>
<li>
<p><input type="checkbox"/> The proposal's functionality is exposed in the
<code>wasmtime</code> crate's API.</p>
</li>
<li>
<p><input type="checkbox"/> The proposal's functionality is exposed in the C API.</p>
</li>
<li>
<p><input type="checkbox"/> The proposal's functionality is exposed in at least
one of the other languages' APIs.</p>
</li>
</ul>
<h2 id="adding-component-functionality-to-wasi"><a class="header" href="#adding-component-functionality-to-wasi">Adding component functionality to WASI</a></h2>
<p>The <a href="https://github.com/bytecodealliance/cap-std">cap-std</a> repository contains
crates which implement the capability-based version of the Rust standard library
and extensions to that functionality. Once the functionality has been added to
the relevant crates of that repository, they can be added into wasmtime by
including them in the preview2 directory of the <a href="https://github.com/bytecodealliance/wasmtime/tree/main/crates/wasi">wasi crate</a>.</p>
<p>Currently, WebAssembly modules which rely on preview2 ABI cannot be directly
executed by the wasmtime command. The following steps allow for testing such
changes.</p>
<ol>
<li>
<p>Build wasmtime with the changes <code>cargo build --release</code></p>
</li>
<li>
<p>Create a simple Webassembly module to test the new component functionality by
compiling your test code to the <code>wasm32-wasi</code> build target.</p>
</li>
<li>
<p>Build the <a href="https://github.com/bytecodealliance/wasmtime/tree/main/crates/wasi-preview1-component-adapter">wasi-preview1-component-adapter</a>
as a command adapter. <code>cargo build -p wasi-preview1-component-adapter --target wasm32-wasi --release --features command --no-default-features</code></p>
</li>
<li>
<p>Use <a href="https://github.com/bytecodealliance/wasm-tools">wasm-tools</a> to convert
the test module to a component. <code>wasm-tools component new --adapt wasi_snapshot_preview1=wasi_snapshot_preview1.command.wasm -o component.wasm path/to/test/module</code></p>
</li>
<li>
<p>Run the test component created in the previous step with the locally built
wasmtime. <code>wasmtime -W component-model=y -S preview2=y component.wasm</code></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maintainer-guidelines"><a class="header" href="#maintainer-guidelines">Maintainer Guidelines</a></h1>
<p>This section describes procedures and expectations for Core Team members. It may
be of interest if you just want to understand how we work, or if you are joining
the Core Team yourself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="code-review"><a class="header" href="#code-review">Code Review</a></h1>
<p>We only merge changes submitted as GitHub Pull Requests, and only after they've
been approved by at least one Core Team reviewer who did not author the PR. This
section covers expectations for the people performing those reviews. These
guidelines are in addition to expectations which apply to everyone in the
community, such as following the Code of Conduct.</p>
<p>It is our goal to respond to every contribution in a timely fashion. Although we
make no guarantees, we aim to usually provide some kind of response within about
one business day.</p>
<p>That's important because we appreciate all the contributions we receive, made by
a diverse collection of people from all over the world. One way to show our
appreciation, and our respect for the effort that goes into contributing to this
project, is by not keeping contributors waiting. It's no fun to submit a pull
request and then sit around wondering if anyone is ever going to look at it.</p>
<p>That does not mean we will review every PR promptly, let alone merge them. Some
contributions have needed weeks of discussion and changes before they were ready
to merge. For some other contributions, we've had to conclude that we could not
merge them, no matter how much we appreciate the effort that went into them.</p>
<p>What this does mean is that we will communicate with each contributor to set
expectations around the review process. Some examples of good communication are:</p>
<ul>
<li>
<p>"I intend to review this but I can't yet. Please leave me a message if I
haven't responded by (a specific date in the near future)."</p>
</li>
<li>
<p>"I think (a specific other contributor) should review this."</p>
</li>
<li>
<p>"I'm having difficulty reviewing this PR because of (a specific reason, if
it's something the contributor might reasonably be able to help with). Are you
able to change that? If not, I'll ask my colleagues for help (or some other
concrete resolution)."</p>
</li>
</ul>
<p>If you are able to quickly review the PR, of course, you can just do that.</p>
<p>You can find open Wasmtime pull requests for which your review has been
requested with this search:</p>
<p><a href="https://github.com/bytecodealliance/wasmtime/pulls?q=is:open+type:pr+user-review-requested:@me">https://github.com/bytecodealliance/wasmtime/pulls?q=is:open+type:pr+user-review-requested:@me</a></p>
<h2 id="auto-assigned-reviewers"><a class="header" href="#auto-assigned-reviewers">Auto-assigned reviewers</a></h2>
<p>We automatically assign a reviewer to every newly opened pull request. We do
this to avoid the problem of diffusion of responsibility, where everyone thinks
somebody else will respond to the PR, so nobody does.</p>
<p>To be in the pool of auto-assigned reviewers, a Core Team member must commit to
following the above goals and guidelines around communicating in a timely
fashion.</p>
<p>We don't ask everyone to make this commitment. In particular, we don't believe
it's fair to expect quick responses from unpaid contributors, although we
gratefully accept any review work they do have time to contribute.</p>
<p>If you are in the auto-assignment pool, remember: <strong>You are not necessarily
expected to review the pull requests which are assigned to you.</strong> Your only
responsibility is to ensure that contributors know what to expect from us, and
to arrange that <em>somebody</em> reviews each PR.</p>
<p>We have several different teams that reviewers may be auto-assigned from. You
should be in teams where you are likely to know who to re-assign a PR to, if you
can't review it yourself. The teams are determined by the <code>CODEOWNERS</code> file at
the root of the Wasmtime repository. But despite the name, membership in these
teams is <em>not</em> about who is an authority or "owner" in a particular area. So
rather than creating a team for each fine-grained division in the repository
such as individual target architectures or WASI extensions, we use a few
coarse-grained teams:</p>
<ul>
<li><a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers">wasmtime-compiler-reviewers</a>: Cranelift and Winch</li>
<li><a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers">wasmtime-core-reviewers</a>: Wasmtime, including WASI</li>
<li><a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-fuzz-reviewers">wasmtime-fuzz-reviewers</a>: Fuzz testing targets</li>
<li><a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers">wasmtime-default-reviewers</a>: Anything else, including CI and documentation</li>
</ul>
<p>Ideally, auto-assigned reviewers should be attending the regular Wasmtime or
Cranelift meetings, as appropriate for the areas they're reviewing. This is to
help these reviewers stay aware of who is working on what, to more easily hand
off PRs to the most relevant reviewer for the work. However, this is only
advice, not a hard requirement.</p>
<p>If you are not sure who to hand off a PR review to, you can look at GitHub's
suggestions for reviewers, or look at <code>git log</code> for the paths that the PR
affects. You can also just ask other Core Team members for advice.</p>
<h2 id="general-advice"><a class="header" href="#general-advice">General advice</a></h2>
<p>This is a collection of general advice for people who are reviewing pull
requests. Feel free to take any that you find works for you and ignore the rest.
You can also open pull requests to suggest more references for this section.</p>
<p><a href="https://sage.thesharps.us/2014/09/01/the-gentle-art-of-patch-review/">The Gentle Art of Patch Review</a> suggests a "Three-Phase
Contribution Review" process:</p>
<ol>
<li>Is the idea behind the contribution sound?</li>
<li>Is the contribution architected correctly?</li>
<li>Is the contribution polished?</li>
</ol>
<p>Phase one should be a quick check for whether the pull request should move
forward at all, or needs a significantly different approach. If it needs
significant changes or is not going to be accepted, there's no point reviewing
in detail until those issues are addressed.</p>
<p>On the other end, it's a good idea to defer reviewing for typos or bikeshedding
about variable names until phase three. If there need to be significant
structural changes, entire paragraphs or functions might disappear, and then any
minor errors that were in them won't matter.</p>
<p>The full essay has much more advice and is recommended reading.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="release-process-1"><a class="header" href="#release-process-1">Release Process</a></h1>
<p>This is intended to serve as documentation for Wasmtime's release process. It's
largely an internal checklist for those of us performing a Wasmtime release, but
others might be curious in this as well!</p>
<h2 id="releasing-a-major-version"><a class="header" href="#releasing-a-major-version">Releasing a major version</a></h2>
<p>Major versions of Wasmtime are released once-a-month. Most of this is automatic
and all that needs to be done is to merge GitHub PRs that CI will
generate. At a high-level the structure of Wasmtime's release process is:</p>
<ul>
<li>On the 5th of every month a new <code>release-X.Y.Z</code> branch is created with the
current contents of <code>main</code>.</li>
<li>On the 20th of every month this release branch is published to crates.io and
release artifacts are built.</li>
</ul>
<p>This means that Wasmtime releases are always at least two weeks behind
development on <code>main</code> and additionally happen once a month. The lag time behind
<code>main</code> is intended to give time to fuzz changes on <code>main</code> as well as allow
testing for any users using <code>main</code>. It's expected, though, that most consumers
will likely use the release branches of wasmtime.</p>
<p>A detailed list of all the steps in the release automation process are below.
The steps requiring interactions are <strong>bolded</strong>, otherwise everything else is
automatic and this is documenting what automation does.</p>
<ol>
<li>On the 5th of every month, (configured via
<code>.github/workflows/release-process.yml</code>) a CI job
will run and do these steps:
<ul>
<li>Download the current <code>main</code> branch</li>
<li>Push the <code>main</code> branch to <code>release-X.Y.Z</code></li>
<li>Run <code>./scripts/publish.rs</code> with the <code>bump</code> argument</li>
<li>Commit the changes</li>
<li>Push these changes to a temporary <code>ci/*</code> branch</li>
<li>Open a PR with this branch against <code>main</code></li>
<li>This step can also be <a href="https://github.com/bytecodealliance/wasmtime/actions/workflows/release-process.yml">triggered manually</a> with the <code>main</code>
branch and the <code>cut</code> argument.</li>
</ul>
</li>
<li><strong>A maintainer of Wasmtime merges this PR</strong>
<ul>
<li>It's intended that this PR can be immediately merged as the release branch
has been created and all it's doing is bumping the version.</li>
</ul>
</li>
<li><strong>Time passes and the <code>release-X.Y.Z</code> branch is maintained</strong>
<ul>
<li>All changes land on <code>main</code> first, then are backported to <code>release-X.Y.Z</code> as
necessary.</li>
<li>Even changes to <code>RELEASES.md</code> are pushed to <code>main</code> first.</li>
</ul>
</li>
<li>On the 20th of every month (same CI job as before) another CI job will run
performing:
<ul>
<li>Download the current <code>main</code> branch.</li>
<li>Update the release date of <code>X.Y.Z</code> to today in <code>RELEASES.md</code></li>
<li>Open a PR against <code>main</code> for this change</li>
<li>Reset to <code>release-X.Y.Z</code></li>
<li>Update the release date of <code>X.Y.Z</code> to today in <code>RELEASES.md</code></li>
<li>Add a special marker to the commit message to indicate a tag should be made.</li>
<li>Open a PR against <code>release-X.Y.Z</code> for this change</li>
<li>This step can also be <a href="https://github.com/bytecodealliance/wasmtime/actions/workflows/release-process.yml">triggered manually</a> with the <code>main</code>
branch and the <code>release-latest</code> argument.</li>
</ul>
</li>
<li><strong>A maintainer of Wasmtime merges these two PRs</strong>
<ul>
<li>The PR against <code>main</code> is a small update to the release notes and should be
mergeable immediately.</li>
<li>The PR against <code>release-X.Y.Z</code>, when merged, will trigger the next steps due
to the marker in the commit message. A maintainer should double-check there
are <a href="https://github.com/bytecodealliance/wasmtime/issues?q=RUSTSEC+is%3Aissue+is%3Aopen+">no open security issues</a>, but otherwise it's expected
that all other release issues are resolved by this point.</li>
</ul>
</li>
<li>The <code>.github/workflow/push-tag.yml</code> workflow is triggered on all commits
including the one just created with a PR merge. This workflow will:
<ul>
<li>Scan the git logs of pushed changes for the special marker added by
<code>release-process.yml</code>.</li>
<li>If found, tags the current <code>main</code> commit and pushes that to the main
repository.</li>
</ul>
</li>
<li>Once a tag is created CI runs in full on the tag itself. CI for tags will
create a GitHub release with release artifacts and it will also publish
crates to crates.io. This is orchestrated by <code>.github/workflows/main.yml</code>.</li>
</ol>
<p>If all goes well you won't have to read up much on this and after hitting the
Big Green Button for the automatically created PRs everything will merrily
carry on its way.</p>
<h2 id="releasing-a-patch-version"><a class="header" href="#releasing-a-patch-version">Releasing a patch version</a></h2>
<p>Making a patch release is somewhat more manual than a major version, but like
before there's automation to help guide the process as well and take care of
more mundane bits.</p>
<p>This is a list of steps taken to perform a patch release for 2.0.1 for example.
Like above human interaction is indicated with <strong>bold</strong> text in these steps.</p>
<ol>
<li><strong>Necessary changes are backported to the <code>release-2.0.0</code> branch from
<code>main</code></strong>
<ul>
<li>All changes must land on <code>main</code> first (if applicable) and then get
backported to an older branch. Release branches should already exist from
the above major release steps.</li>
<li>CI may not have been run in some time for release branches so it may be
necessary to backport CI fixes and updates from <code>main</code> as well.</li>
<li>When merging backports maintainers need to double-check that the
<code>PUBLIC_CRATES</code> listed in <code>scripts/publish.rs</code> do not have
semver-API-breaking changes (in the strictest sense). All security fixes
must be done in such a way that the API doesn't break between the patch
version and the original version.</li>
<li>Don't forget to write patch notes in <code>RELEASES.md</code> for backported changes.</li>
</ul>
</li>
<li><strong>The patch release process is <a href="https://github.com/bytecodealliance/wasmtime/actions/workflows/release-process.yml">triggered manually</a> with
the <code>release-2.0.0</code> branch and the <code>release-patch</code> argument</strong>
<ul>
<li>This will run the <code>release-process.yml</code> workflow. The <code>scripts/publish.rs</code>
script will be run with the <code>bump-patch</code> argument.</li>
<li>The changes will be committed with a special marker indicating a release
needs to be made.</li>
<li>A PR will be created from a temporary <code>ci/*</code> branch to the <code>release-2.0.0</code>
branch which, when merged, will trigger the release process.</li>
</ul>
</li>
<li><strong>Review the generated PR and merge it</strong>
<ul>
<li>This will resume from step 6 above in the major release process where the
special marker in the commit message generated by CI will trigger a tag to
get pushed which will further trigger the rest of the release process.</li>
<li>Please make sure to update the <code>RELEASES.md</code> at this point to include the
<code>Released on</code> date by pushing directly to the branch associated with the
PR.</li>
</ul>
</li>
<li><strong>Forward-port the release notes to main</strong>
<ul>
<li>Once the release is done, please forward-port the release notes to the
<code>RELEASES.md</code> on the main branch, to ensure consistency in future releases.</li>
</ul>
</li>
</ol>
<p>After a patch release has been made you'll also want to double-check that the
release notes on the patch branch are in sync with the <code>main</code> branch.</p>
<h2 id="releasing-a-security-patch"><a class="header" href="#releasing-a-security-patch">Releasing a security patch</a></h2>
<p>When making a patch release that has a security-related fix the contents of the
patch are often kept private until the day of the patch release which means that
the process here is slightly different from the patch release process above. In
addition the precise <a href="https://github.com/bytecodealliance/rfcs/pull/20">runbook is currently under discussion in an
RFC</a> for security patches, so
this intends to document what we've been doing so far and it'll get updated when
the runbook is merged.</p>
<ol>
<li><strong>The fix for the security issue is developed in a GitHub Security
Advisory</strong>
<ul>
<li>This will not have any CI run, it's recommended to run <code>./ci/run-tests.sh</code>
locally at least.</li>
<li>Develop fixes for all branches that will get a patch release in the
advisory, one PR per branch. When the advisory is published all branches
will be merged simultaneously. Be sure to run <code>./ci/run-tests.sh</code> in each
branch.</li>
<li>Don't forget to update <code>RELEASES.md</code> with notes about the release on
each branch.</li>
</ul>
</li>
<li><strong>Send a PR for the version bump when an email goes out announcing there will
be a security release</strong>
<ul>
<li>An email is sent to the bytecodealliance security mailing list ahead of a
patch release to announce that a patch release will happen. At this time you
should <a href="https://github.com/bytecodealliance/wasmtime/actions/workflows/release-process.yml">trigger the version bump</a> against the appropriate
<code>release-x.y.z</code> branches with the <code>release-patch</code> argument.</li>
<li>This will send a PR, but you should not merge it. Instead use this PR and
the time ahead of the security release to fix any issues with CI. Older
<code>release-x.y.z</code> branches haven't run CI in awhile so they may need to
backport fixes of one variety or another. DO NOT include the actual fix for
the security issue into the PR, that comes in the next step.</li>
</ul>
</li>
<li><strong>Make the advisories/patches public</strong>
<ul>
<li>Publishing the GitHub Security Advisory will merge all the PRs into each
branch from the advisory. Note that CI will run for release branches but
<code>main</code> will probably fail CI since it expected to be merged through the
merge queue, but that's ok.</li>
<li>Double-check that CI for release branches finishes and completes
successfully.</li>
</ul>
</li>
<li><strong>Merge the version-bump PR</strong>
<ul>
<li>Like the patch release process this will kick everything else into motion.
Note that the actual security fixes should be merged either before or as
part of this PR.</li>
</ul>
</li>
</ol>
<p>After a security release has been made you'll also want to double-check that
the release notes on the branch are in sync with the <code>main</code> branch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="governance"><a class="header" href="#governance">Governance</a></h1>
<p>... more coming soon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributor-covenant-code-of-conduct"><a class="header" href="#contributor-covenant-code-of-conduct">Contributor Covenant Code of Conduct</a></h1>
<p><em>Note</em>: this Code of Conduct pertains to individuals' behavior. Please also see the <a href="https://github.com/bytecodealliance/wasmtime/blob/main/ORG_CODE_OF_CONDUCT.md">Organizational Code of Conduct</a>.</p>
<h2 id="our-pledge"><a class="header" href="#our-pledge">Our Pledge</a></h2>
<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>
<h2 id="our-standards"><a class="header" href="#our-standards">Our Standards</a></h2>
<p>Examples of behavior that contributes to creating a positive environment include:</p>
<ul>
<li>Using welcoming and inclusive language</li>
<li>Being respectful of differing viewpoints and experiences</li>
<li>Gracefully accepting constructive criticism</li>
<li>Focusing on what is best for the community</li>
<li>Showing empathy towards other community members</li>
</ul>
<p>Examples of unacceptable behavior by participants include:</p>
<ul>
<li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li>
<li>Trolling, insulting/derogatory comments, and personal or political attacks</li>
<li>Public or private harassment</li>
<li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li>
<li>Other conduct which could reasonably be considered inappropriate in a professional setting</li>
</ul>
<h2 id="our-responsibilities"><a class="header" href="#our-responsibilities">Our Responsibilities</a></h2>
<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p>
<p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>
<h2 id="enforcement"><a class="header" href="#enforcement">Enforcement</a></h2>
<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the Bytecode Alliance CoC team at <a href="mailto:report@bytecodealliance.org">report@bytecodealliance.org</a>. The CoC team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The CoC team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p>
<p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the Bytecode Alliance's leadership.</p>
<h2 id="attribution"><a class="header" href="#attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the <a href="https://www.contributor-covenant.org">Contributor Covenant</a>, version 1.4, available at <a href="https://www.contributor-covenant.org/version/1/4/">http://contributor-covenant.org/version/1/4</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
